declare module "packages/dev/latvian/mods/unit/operator/op/$AddOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $AddOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddOpUnit$Type = ($AddOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddOpUnit_ = $AddOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$ShapedKubeJSRecipe$SerializerKJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$ShapedKubeJSRecipe, $ShapedKubeJSRecipe$Type} from "packages/dev/latvian/mods/kubejs/recipe/special/$ShapedKubeJSRecipe"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ShapedKubeJSRecipe$SerializerKJS implements $RecipeSerializer<($ShapedKubeJSRecipe)> {

constructor()

public "fromJson"(id: $ResourceLocation$Type, json: $JsonObject$Type): $ShapedKubeJSRecipe
public "fromNetwork"(id: $ResourceLocation$Type, buf: $FriendlyByteBuf$Type): $ShapedKubeJSRecipe
public "toNetwork"(buf: $FriendlyByteBuf$Type, r: $ShapedKubeJSRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $ShapedKubeJSRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$SerializerKJS$Type = ($ShapedKubeJSRecipe$SerializerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedKubeJSRecipe$SerializerKJS_ = $ShapedKubeJSRecipe$SerializerKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Callable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $Callable {

 "call"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Scriptable$Type, arg3: (any)[]): any

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Scriptable$Type, arg3: (any)[]): any
}

export namespace $Callable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Callable$Type = ($Callable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Callable_ = $Callable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$KubeJSPaths" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$MutableBoolean, $MutableBoolean$Type} from "packages/org/apache/commons/lang3/mutable/$MutableBoolean"

export interface $KubeJSPaths {

}

export namespace $KubeJSPaths {
const FIRST_RUN: $MutableBoolean
const DIRECTORY: $Path
const DATA: $Path
const ASSETS: $Path
const STARTUP_SCRIPTS: $Path
const SERVER_SCRIPTS: $Path
const CLIENT_SCRIPTS: $Path
const CONFIG: $Path
const COMMON_PROPERTIES: $Path
const CLIENT_PROPERTIES: $Path
const CONFIG_DEV_PROPERTIES: $Path
const PACKICON: $Path
const README: $Path
const LOCAL: $Path
const LOCAL_CACHE: $Path
const LOCAL_DEV_PROPERTIES: $Path
const EXPORT: $Path
const EXPORTED_PACKS: $Path
function get(type: $PackType$Type): $Path
function dir(dir: $Path$Type): $Path
function dir(dir: $Path$Type, markFirstRun: boolean): $Path
function getLocalDevProperties(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPaths$Type = ($KubeJSPaths);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSPaths_ = $KubeJSPaths$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$RegistryEventJS" {
import {$CustomBuilderObject, $CustomBuilderObject$Type} from "packages/dev/latvian/mods/kubejs/registry/$CustomBuilderObject"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"

export class $RegistryEventJS<T> extends $StartupEventJS {
readonly "created": $List<($BuilderBase<(any)>)>

constructor(r: $RegistryInfo$Type<(T)>)

public "create"(id: string): $BuilderBase<(any)>
public "create"(id: string, type: string): $BuilderBase<(any)>
/**
 * 
 * @deprecated
 */
public "custom"(id: string, object: any): $CustomBuilderObject
public "createCustom"(id: string, object: $Supplier$Type<(any)>): $CustomBuilderObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryEventJS$Type<T> = ($RegistryEventJS<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryEventJS_<T> = $RegistryEventJS$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeSet" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeSet extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type)

public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeSet$Type = ($NativeSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeSet_ = $NativeSet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ComponentKJS" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$WrappedJS, $WrappedJS$Type} from "packages/dev/latvian/mods/kubejs/util/$WrappedJS"
import {$DataSource, $DataSource$Type} from "packages/net/minecraft/network/chat/contents/$DataSource"
import {$FormattedText$StyledContentConsumer, $FormattedText$StyledContentConsumer$Type} from "packages/net/minecraft/network/chat/$FormattedText$StyledContentConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Style, $Style$Type} from "packages/net/minecraft/network/chat/$Style"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$FormattedText, $FormattedText$Type} from "packages/net/minecraft/network/chat/$FormattedText"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ComponentContents, $ComponentContents$Type} from "packages/net/minecraft/network/chat/$ComponentContents"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$FormattedText$ContentConsumer, $FormattedText$ContentConsumer$Type} from "packages/net/minecraft/network/chat/$FormattedText$ContentConsumer"
import {$JsonSerializable, $JsonSerializable$Type} from "packages/dev/latvian/mods/rhino/mod/util/$JsonSerializable"
import {$ClickEvent, $ClickEvent$Type} from "packages/net/minecraft/network/chat/$ClickEvent"

export interface $ComponentKJS extends $Component, $JsonSerializable, $WrappedJS {

 "forEach"(action: $Consumer$Type<(any)>): void
 "self"(): $MutableComponent
 "darkBlue"(): $MutableComponent
 "darkGreen"(): $MutableComponent
 "black"(): $MutableComponent
 "hasStyle"(): boolean
 "hasSiblings"(): boolean
 "toJson"(): $JsonElement
 "darkAqua"(): $MutableComponent
 "darkRed"(): $MutableComponent
 "darkPurple"(): $MutableComponent
 "asIterable"(): $Iterable<($Component)>
 "darkGray"(): $MutableComponent
 "bold"(): $MutableComponent
 "bold"(value: boolean): $MutableComponent
 "noColor"(): $MutableComponent
 "gold"(): $MutableComponent
 "strikethrough"(value: boolean): $MutableComponent
 "strikethrough"(): $MutableComponent
 "underlined"(value: boolean): $MutableComponent
 "underlined"(): $MutableComponent
 "italic"(value: boolean): $MutableComponent
 "italic"(): $MutableComponent
 "obfuscated"(): $MutableComponent
 "obfuscated"(value: boolean): $MutableComponent
 "color"(c: $Color$Type): $MutableComponent
 "lightPurple"(): $MutableComponent
 "aqua"(): $MutableComponent
 "red"(): $MutableComponent
 "blue"(): $MutableComponent
 "yellow"(): $MutableComponent
 "gray"(): $MutableComponent
 "white"(): $MutableComponent
 "green"(): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawCopy"(): $MutableComponent
 "click"(s: $ClickEvent$Type): $MutableComponent
 "clickOpenFile"(path: string): $MutableComponent
/**
 * 
 * @deprecated
 */
 "rawComponent"(): $MutableComponent
 "insertion"(s: string): $MutableComponent
 "hover"(s: $Component$Type): $MutableComponent
 "clickCopy"(text: string): $MutableComponent
 "font"(s: $ResourceLocation$Type): $MutableComponent
 "clickOpenUrl"(url: string): $MutableComponent
/**
 * 
 * @deprecated
 */
 "component"(): $Component
 "isEmpty"(): boolean
 "clickChangePage"(page: string): $MutableComponent
 "clickRunCommand"(command: string): $MutableComponent
 "clickSuggestCommand"(command: string): $MutableComponent
 "getString"(): string
 "getVisualOrderText"(): $FormattedCharSequence
 "visit"<T>(arg0: $FormattedText$StyledContentConsumer$Type<(T)>, arg1: $Style$Type): $Optional<(T)>
 "visit"<T>(arg0: $FormattedText$ContentConsumer$Type<(T)>): $Optional<(T)>
 "plainCopy"(): $MutableComponent
 "getString"(arg0: integer): string
 "getContents"(): $ComponentContents
 "getSiblings"(): $List<($Component)>
 "copy"(): $MutableComponent
 "getStyle"(): $Style
 "toFlatList"(): $List<($Component)>
 "toFlatList"(arg0: $Style$Type): $List<($Component)>
 "contains"(arg0: $Component$Type): boolean
}

export namespace $ComponentKJS {
function translatable(arg0: string): $MutableComponent
function literal(arg0: string): $MutableComponent
function translatable(arg0: string, ...arg1: (any)[]): $MutableComponent
function empty(): $MutableComponent
function keybind(arg0: string): $MutableComponent
function translatableWithFallback(arg0: string, arg1: string): $MutableComponent
function nullToEmpty(arg0: string): $Component
function translatableWithFallback(arg0: string, arg1: string, ...arg2: (any)[]): $MutableComponent
function nbt(arg0: string, arg1: boolean, arg2: $Optional$Type<($Component$Type)>, arg3: $DataSource$Type): $MutableComponent
function selector(arg0: string, arg1: $Optional$Type<($Component$Type)>): $MutableComponent
function score(arg0: string, arg1: string): $MutableComponent
function of(arg0: string): $FormattedText
function of(arg0: string, arg1: $Style$Type): $FormattedText
function composite(...arg0: ($FormattedText$Type)[]): $FormattedText
function composite(arg0: $List$Type<(any)>): $FormattedText
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentKJS$Type = ($ComponentKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentKJS_ = $ComponentKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$NoMixinException" {
import {$IllegalStateException, $IllegalStateException$Type} from "packages/java/lang/$IllegalStateException"

export class $NoMixinException extends $IllegalStateException {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoMixinException$Type = ($NoMixinException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoMixinException_ = $NoMixinException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$FishingLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FishingLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "getDirectory"(): string
public "addFishing"(id: $ResourceLocation$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FishingLootEventJS$Type = ($FishingLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FishingLootEventJS_ = $FishingLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockRightClickedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

/**
 * Invoked when a player right clicks on a block.
 */
export class $BlockRightClickedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type)

/**
 * The position of the block that was right clicked.
 */
public "getItem"(): $ItemStack
/**
 * The block that was right clicked.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The face of the block being right clicked.
 */
public "getFacing"(): $Direction
/**
 * The hand that was used to right click the block.
 */
public "getHand"(): $InteractionHand
get "item"(): $ItemStack
get "block"(): $BlockContainerJS
get "facing"(): $Direction
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockRightClickedEventJS$Type = ($BlockRightClickedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockRightClickedEventJS_ = $BlockRightClickedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$MultipartBlockStateGenerator$Part" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$VariantBlockStateGenerator$Model, $VariantBlockStateGenerator$Model$Type} from "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator$Model"

export class $MultipartBlockStateGenerator$Part {

constructor()

public "toJson"(): $JsonObject
public "model"(s: string): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Part$Type = ($MultipartBlockStateGenerator$Part);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartBlockStateGenerator$Part_ = $MultipartBlockStateGenerator$Part$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ClassShutter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ClassShutter {

 "visibleToScripts"(arg0: string, arg1: integer): boolean

(arg0: string, arg1: integer): boolean
}

export namespace $ClassShutter {
const TYPE_UNKNOWN: integer
const TYPE_MEMBER: integer
const TYPE_CLASS_IN_PACKAGE: integer
const TYPE_EXCEPTION: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassShutter$Type = ($ClassShutter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassShutter_ = $ClassShutter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$LivingEntityEventJS, $LivingEntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS"

export class $PlayerEventJS extends $LivingEntityEventJS {

constructor()

public "getPlayer"(): $Player
/**
 * Checks if the player has the specified game stage
 */
public "hasGameStage"(stage: string): boolean
/**
 * Adds the specified game stage to the player
 */
public "addGameStage"(stage: string): void
/**
 * Removes the specified game stage from the player
 */
public "removeGameStage"(stage: string): void
get "player"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEventJS$Type = ($PlayerEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEventJS_ = $PlayerEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$SymbolScriptable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export interface $SymbolScriptable {

 "get"(arg0: $Context$Type, arg1: $Symbol$Type, arg2: $Scriptable$Type): any
 "put"(arg0: $Context$Type, arg1: $Symbol$Type, arg2: $Scriptable$Type, arg3: any): void
 "delete"(arg0: $Context$Type, arg1: $Symbol$Type): void
 "has"(arg0: $Context$Type, arg1: $Symbol$Type, arg2: $Scriptable$Type): boolean
}

export namespace $SymbolScriptable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymbolScriptable$Type = ($SymbolScriptable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SymbolScriptable_ = $SymbolScriptable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer" {
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $OutputReplacementTransformer {

 "transform"(arg0: $RecipeKJS$Type, arg1: $ReplacementMatch$Type, arg2: $OutputReplacement$Type, arg3: $OutputReplacement$Type): any

(arg0: $RecipeKJS$Type, arg1: $ReplacementMatch$Type, arg2: $OutputReplacement$Type, arg3: $OutputReplacement$Type): any
}

export namespace $OutputReplacementTransformer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputReplacementTransformer$Type = ($OutputReplacementTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputReplacementTransformer_ = $OutputReplacementTransformer$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/wrapper/$DirectionWrapper" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $DirectionWrapper {

}

export namespace $DirectionWrapper {
const down: $Direction
const up: $Direction
const north: $Direction
const south: $Direction
const west: $Direction
const east: $Direction
const DOWN: $Direction
const UP: $Direction
const NORTH: $Direction
const SOUTH: $Direction
const WEST: $Direction
const EAST: $Direction
const ALL: $Map<(string), ($Direction)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DirectionWrapper$Type = ($DirectionWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DirectionWrapper_ = $DirectionWrapper$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$NegateOpUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnaryOpUnit, $UnaryOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$UnaryOpUnit"

export class $NegateOpUnit extends $UnaryOpUnit {
readonly "symbol": $UnitSymbol
 "unit": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(unit: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NegateOpUnit$Type = ($NegateOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NegateOpUnit_ = $NegateOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$NotFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $NotFilter extends $Record implements $BiomeFilter {

constructor(original: $BiomeFilter$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "original"(): $BiomeFilter
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotFilter$Type = ($NotFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotFilter_ = $NotFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$PoiTypeBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$PoiType, $PoiType$Type} from "packages/net/minecraft/world/entity/ai/village/poi/$PoiType"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $PoiTypeBuilder extends $BuilderBase<($PoiType)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "block"(r: $Block$Type): $PoiTypeBuilder
public "blocks"(r: ($BlockState$Type)[]): $PoiTypeBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
public "maxTickets"(i: integer): $PoiTypeBuilder
public "validRange"(i: integer): $PoiTypeBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PoiTypeBuilder$Type = ($PoiTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PoiTypeBuilder_ = $PoiTypeBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$CreateInputFluid" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$FluidLike, $FluidLike$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidLike"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/simibubi/create/foundation/fluid/$FluidIngredient"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $CreateInputFluid extends $Record implements $InputFluid {
static readonly "EMPTY": $CreateInputFluid

constructor(ingredient: $FluidIngredient$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "copy"(amount: long): $FluidLike
public "getAmount"(): long
public "ingredient"(): $FluidIngredient
public "isEmpty"(): boolean
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
public "matches"(other: $FluidLike$Type): boolean
public static "of"(o: any): $InputReplacement
public "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
get "amount"(): long
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreateInputFluid$Type = ($CreateInputFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreateInputFluid_ = $CreateInputFluid$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$TypeInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TypeInfo {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeInfo$Type = ($TypeInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeInfo_ = $TypeInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent$Callback" {
import {$ChestMenuClickEvent, $ChestMenuClickEvent$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent"

export interface $ChestMenuClickEvent$Callback {

 "onClick"(arg0: $ChestMenuClickEvent$Type): void

(arg0: $ChestMenuClickEvent$Type): void
}

export namespace $ChestMenuClickEvent$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Callback$Type = ($ChestMenuClickEvent$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickEvent$Callback_ = $ChestMenuClickEvent$Callback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$PainterFactory" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$PainterObject, $PainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObject"

export interface $PainterFactory {

 "create"(arg0: $Painter$Type): $PainterObject

(arg0: $Painter$Type): $PainterObject
}

export namespace $PainterFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PainterFactory$Type = ($PainterFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PainterFactory_ = $PainterFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$EntityFallenOnBlockCallbackJS" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$EntitySteppedOnBlockCallbackJS"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityFallenOnBlockCallbackJS extends $EntitySteppedOnBlockCallbackJS {

constructor(level: $Level$Type, entity: $Entity$Type, pos: $BlockPos$Type, state: $BlockState$Type, fallHeight: float)

/**
 * Get the height the entity has fallen
 */
public "getFallHeight"(): float
/**
 * Applies fall damage to the entity as if they had fallen from the provided height, and multiplies it by the provided multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float): boolean
/**
 * Damages the entity using the provided damage source, using the fall height and multiplier to calculate the damage amount.
 * Note this does not force the damage, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(fallHeight: float, multiplier: float, damageSource: $DamageSource$Type): boolean
/**
 * Applies fall damage to the entity, multiplier by the multiplier.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(multiplier: float): boolean
/**
 * Applies default fall damage to the entity.
 * Note this does not force it, so entities that do not take fall damage are not affected.
 */
public "applyFallDamage"(): boolean
get "fallHeight"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityFallenOnBlockCallbackJS$Type = ($EntityFallenOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityFallenOnBlockCallbackJS_ = $EntityFallenOnBlockCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$HideFromJS" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $HideFromJS extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $HideFromJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HideFromJS$Type = ($HideFromJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HideFromJS_ = $HideFromJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipesEventJS, $RecipesEventJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipesEventJS"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$WrappedJS, $WrappedJS$Type} from "packages/dev/latvian/mods/kubejs/util/$WrappedJS"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RecipeSchemaType, $RecipeSchemaType$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $RecipeTypeFunction extends $BaseFunction implements $WrappedJS {
static readonly "SKIP_ERROR": $Pattern
readonly "event": $RecipesEventJS
readonly "id": $ResourceLocation
readonly "idString": string
readonly "schemaType": $RecipeSchemaType
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(event: $RecipesEventJS$Type, schemaType: $RecipeSchemaType$Type)

public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getMod"(): string
public "createRecipe"(args: (any)[]): $RecipeJS
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "mod"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeTypeFunction$Type = ($RecipeTypeFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeTypeFunction_ = $RecipeTypeFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid" {
import {$FluidLike, $FluidLike$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidLike"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer$Replacement, $OutputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $OutputFluid extends $FluidLike, $OutputReplacement {

 "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
 "matches"(other: $FluidLike$Type): boolean
 "copy"(amount: long): $FluidLike
 "getAmount"(): long
 "isEmpty"(): boolean
 "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement

(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
}

export namespace $OutputFluid {
function of(o: any): $OutputReplacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputFluid$Type = ($OutputFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputFluid_ = $OutputFluid$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/predicate/$BlockEntityPredicateDataCheck" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"

export interface $BlockEntityPredicateDataCheck {

 "checkData"(arg0: $CompoundTag$Type): boolean

(arg0: $CompoundTag$Type): boolean
}

export namespace $BlockEntityPredicateDataCheck {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicateDataCheck$Type = ($BlockEntityPredicateDataCheck);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityPredicateDataCheck_ = $BlockEntityPredicateDataCheck$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$PlayerMainInvWrapper" {
import {$RangedWrapper, $RangedWrapper$Type} from "packages/dev/latvian/mods/kubejs/item/$RangedWrapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"

export class $PlayerMainInvWrapper extends $RangedWrapper {

constructor(inv: $Inventory$Type)

public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "getInventoryPlayer"(): $Inventory
get "inventoryPlayer"(): $Inventory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerMainInvWrapper$Type = ($PlayerMainInvWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerMainInvWrapper_ = $PlayerMainInvWrapper$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$TernaryUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $TernaryUnitToken extends $Record implements $UnitToken {

constructor(cond: $UnitToken$Type, ifTrue: $UnitToken$Type, ifFalse: $UnitToken$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "cond"(): $UnitToken
public "ifFalse"(): $UnitToken
public "ifTrue"(): $UnitToken
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TernaryUnitToken$Type = ($TernaryUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TernaryUnitToken_ = $TernaryUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FunctionFactory$FuncSupplier" {
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $FunctionFactory$FuncSupplier {

 "create"(arg0: ($Unit$Type)[]): $Unit

(arg0: ($Unit$Type)[]): $Unit
}

export namespace $FunctionFactory$FuncSupplier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionFactory$FuncSupplier$Type = ($FunctionFactory$FuncSupplier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionFactory$FuncSupplier_ = $FunctionFactory$FuncSupplier$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeArrayIterator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ES6Iterator, $ES6Iterator$Type} from "packages/dev/latvian/mods/rhino/$ES6Iterator"
import {$NativeArrayIterator$ArrayIteratorType, $NativeArrayIterator$ArrayIteratorType$Type} from "packages/dev/latvian/mods/rhino/$NativeArrayIterator$ArrayIteratorType"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeArrayIterator extends $ES6Iterator {
static readonly "NEXT_METHOD": string
static readonly "DONE_PROPERTY": string
static readonly "RETURN_PROPERTY": string
static readonly "VALUE_PROPERTY": string
static readonly "RETURN_METHOD": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type, scope: $Scriptable$Type, arrayLike: $Scriptable$Type, type: $NativeArrayIterator$ArrayIteratorType$Type)

public "getClassName"(): string
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeArrayIterator$Type = ($NativeArrayIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeArrayIterator_ = $NativeArrayIterator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$KubeJSPlayerEventHandler" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$ChatEvent$ChatComponent, $ChatEvent$ChatComponent$Type} from "packages/dev/architectury/event/events/common/$ChatEvent$ChatComponent"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$EventResult, $EventResult$Type} from "packages/dev/architectury/event/$EventResult"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export class $KubeJSPlayerEventHandler {

constructor()

public static "init"(): void
public static "tick"(player: $Player$Type): void
public static "loggedOut"(player: $ServerPlayer$Type): void
public static "loggedIn"(player: $ServerPlayer$Type): void
public static "advancement"(player: $ServerPlayer$Type, advancement: $Advancement$Type): void
public static "inventoryOpened"(player: $Player$Type, menu: $AbstractContainerMenu$Type): void
public static "inventoryClosed"(player: $Player$Type, menu: $AbstractContainerMenu$Type): void
public static "respawn"(oldPlayer: $ServerPlayer$Type, newPlayer: $ServerPlayer$Type, keepData: boolean): void
public static "chatDecorate"(player: $ServerPlayer$Type, component: $ChatEvent$ChatComponent$Type): void
public static "chatReceived"(player: $ServerPlayer$Type, component: $Component$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPlayerEventHandler$Type = ($KubeJSPlayerEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSPlayerEventHandler_ = $KubeJSPlayerEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$GteOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $GteOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GteOpUnit$Type = ($GteOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GteOpUnit_ = $GteOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ClassFileMethod" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClassFileMethod {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFileMethod$Type = ($ClassFileMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFileMethod_ = $ClassFileMethod$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerStatsJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Stat, $Stat$Type} from "packages/net/minecraft/stats/$Stat"
import {$StatsCounter, $StatsCounter$Type} from "packages/net/minecraft/stats/$StatsCounter"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $PlayerStatsJS {
readonly "player": $Player

constructor(p: $Player$Type, s: $StatsCounter$Type)

public "add"(stat: $Stat$Type<(any)>, value: integer): void
public "get"(stat: $Stat$Type<(any)>): integer
public "set"(stat: $Stat$Type<(any)>, value: integer): void
public "getMobKills"(): integer
public "getItemsBroken"(item: $Item$Type): integer
public "getKilled"(entity: $EntityType$Type<(any)>): integer
public "getSwimDistance"(): integer
public "getItemsPickedUp"(item: $Item$Type): integer
public "getJumps"(): integer
public "getDeaths"(): integer
public "getSprintDistance"(): integer
public "getItemsDropped"(item: $Item$Type): integer
public "getAnimalsBred"(): integer
public "getWalkDistance"(): integer
public "getTimeSinceDeath"(): integer
public "getDamageTaken"(): integer
public "getItemsCrafted"(item: $Item$Type): integer
public "getCrouchDistance"(): integer
public "getTimeSinceRest"(): integer
public "getDamageAbsorbed"(): integer
public "getPlayerKills"(): integer
public "getFishCaught"(): integer
public "getTimeCrouchTime"(): integer
public "getItemsUsed"(item: $Item$Type): integer
public "getPlayTime"(): integer
public "getBlocksMined"(block: $Block$Type): integer
public "getDamageResisted"(): integer
public "getKilledBy"(entity: $EntityType$Type<(any)>): integer
public "getDamageDealt_absorbed"(): integer
public "getDamageDealt_resisted"(): integer
public "getDamageBlocked_by_shield"(): integer
public "getDamageDealt"(): integer
public static "statOf"(o: any): $Stat<(any)>
get "mobKills"(): integer
get "swimDistance"(): integer
get "jumps"(): integer
get "deaths"(): integer
get "sprintDistance"(): integer
get "animalsBred"(): integer
get "walkDistance"(): integer
get "timeSinceDeath"(): integer
get "damageTaken"(): integer
get "crouchDistance"(): integer
get "timeSinceRest"(): integer
get "damageAbsorbed"(): integer
get "playerKills"(): integer
get "fishCaught"(): integer
get "timeCrouchTime"(): integer
get "playTime"(): integer
get "damageResisted"(): integer
get "damageDealt_absorbed"(): integer
get "damageDealt_resisted"(): integer
get "damageBlocked_by_shield"(): integer
get "damageDealt"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerStatsJS$Type = ($PlayerStatsJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerStatsJS_ = $PlayerStatsJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$RegexIDFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $RegexIDFilter implements $RecipeFilter {


public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(recipe: $RecipeKJS$Type): boolean
public static "of"(i: $Pattern$Type): $RegexIDFilter
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexIDFilter$Type = ($RegexIDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexIDFilter_ = $RegexIDFilter$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$BitAndOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $BitAndOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BitAndOpUnit$Type = ($BitAndOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BitAndOpUnit_ = $BitAndOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$SpecialFluidHandlerEvent" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/simibubi/create/foundation/fluid/$FluidIngredient"
import {$OpenEndedPipe, $OpenEndedPipe$Type} from "packages/com/simibubi/create/content/fluids/$OpenEndedPipe"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export class $SpecialFluidHandlerEvent extends $EventJS {

constructor()

public "add"(fluidIngredient: $FluidIngredient$Type, handler: $BiConsumer$Type<($OpenEndedPipe$Type), ($FluidStackJS$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialFluidHandlerEvent$Type = ($SpecialFluidHandlerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialFluidHandlerEvent_ = $SpecialFluidHandlerEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $InputReplacementTransformer {

 "transform"(arg0: $RecipeKJS$Type, arg1: $ReplacementMatch$Type, arg2: $InputReplacement$Type, arg3: $InputReplacement$Type): any

(arg0: $RecipeKJS$Type, arg1: $ReplacementMatch$Type, arg2: $InputReplacement$Type, arg3: $InputReplacement$Type): any
}

export namespace $InputReplacementTransformer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputReplacementTransformer$Type = ($InputReplacementTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputReplacementTransformer_ = $InputReplacementTransformer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AllMatchRuleTest" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $AllMatchRuleTest extends $RuleTest {
static readonly "CODEC": $Codec<($AllMatchRuleTest)>
readonly "rules": $List<($RuleTest)>

constructor()
constructor(rules: $List$Type<($RuleTest$Type)>)

public "test"(blockState: $BlockState$Type, random: $RandomSource$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllMatchRuleTest$Type = ($AllMatchRuleTest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AllMatchRuleTest_ = $AllMatchRuleTest$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$WithStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $WithStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setStatement"(statement: $AstNode$Type): void
public "setParens"(lp: integer, rp: integer): void
public "getExpression"(): $AstNode
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "setExpression"(expression: $AstNode$Type): void
public "getStatement"(): $AstNode
set "statement"(value: $AstNode$Type)
get "expression"(): $AstNode
set "lp"(value: integer)
set "rp"(value: integer)
get "lp"(): integer
get "rp"(): integer
set "expression"(value: $AstNode$Type)
get "statement"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithStatement$Type = ($WithStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithStatement_ = $WithStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidBucketItemBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$FluidBuilder, $FluidBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidBuilder"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$BucketItem, $BucketItem$Type} from "packages/net/minecraft/world/item/$BucketItem"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FluidBucketItemBuilder extends $ItemBuilder {
readonly "fluidBuilder": $FluidBuilder
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(b: $FluidBuilder$Type)

public "createObject"(): $BucketItem
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBucketItemBuilder$Type = ($FluidBucketItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBucketItemBuilder_ = $FluidBucketItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$SendDataFromServerMessage" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SendDataFromServerMessage extends $BaseS2CMessage {

constructor(c: string, d: $CompoundTag$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SendDataFromServerMessage$Type = ($SendDataFromServerMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SendDataFromServerMessage_ = $SendDataFromServerMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$BuilderFactory" {
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $BuilderFactory {

 "createBuilder"(arg0: $ResourceLocation$Type): $BuilderBase<(any)>

(arg0: $ResourceLocation$Type): $BuilderBase<(any)>
}

export namespace $BuilderFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderFactory$Type = ($BuilderFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderFactory_ = $BuilderFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$TinyMap$Entry" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $TinyMap$Entry<K, V> extends $Record {

constructor(key: K, value: V)

public "value"(): V
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Entry$Type<K, V> = ($TinyMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinyMap$Entry_<K, V> = $TinyMap$Entry$Type<(K), (V)>;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$GenericLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GenericLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "getDirectory"(): string
public "addGeneric"(id: $ResourceLocation$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericLootEventJS$Type = ($GenericLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericLootEventJS_ = $GenericLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapperProvider" {
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"

export interface $CustomJavaToJsWrapperProvider<T> {

 "create"(arg0: T): $CustomJavaToJsWrapper

(arg0: T): $CustomJavaToJsWrapper
}

export namespace $CustomJavaToJsWrapperProvider {
const NONE: $CustomJavaToJsWrapperProvider<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJavaToJsWrapperProvider$Type<T> = ($CustomJavaToJsWrapperProvider<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJavaToJsWrapperProvider_<T> = $CustomJavaToJsWrapperProvider$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$WallBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$MultipartShapedBlockBuilder, $MultipartShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$MultipartShapedBlockBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export class $WallBlockBuilder extends $MultipartShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WallBlockBuilder$Type = ($WallBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WallBlockBuilder_ = $WallBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$LshOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $LshOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LshOpUnit$Type = ($LshOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LshOpUnit_ = $LshOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$LegacyCodeHandler$LegacyError" {
import {$MutedError, $MutedError$Type} from "packages/dev/latvian/mods/kubejs/util/$MutedError"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $LegacyCodeHandler$LegacyError extends $RuntimeException implements $MutedError {

constructor(message: string)

public "toString"(): string
public "isMuted"(): boolean
get "muted"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyCodeHandler$LegacyError$Type = ($LegacyCodeHandler$LegacyError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyCodeHandler$LegacyError_ = $LegacyCodeHandler$LegacyError$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$IngredientKJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$IngredientSupplierKJS"
import {$ItemStackSet, $ItemStackSet$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemStackSet"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$JsonSerializable, $JsonSerializable$Type} from "packages/dev/latvian/mods/rhino/mod/util/$JsonSerializable"

export interface $IngredientKJS extends $IngredientSupplierKJS, $JsonSerializable {

 "self"(): $Ingredient
 "getItemTypes"(): $Set<($Item)>
 "testItem"(item: $Item$Type): boolean
 "getItemIds"(): $Set<(string)>
 "or"(ingredient: $Ingredient$Type): $Ingredient
 "getStacks"(): $ItemStackSet
 "getFirst"(): $ItemStack
 "and"(ingredient: $Ingredient$Type): $Ingredient
 "subtract"(subtracted: $Ingredient$Type): $Ingredient
 "asStack"(): $InputItem
 "asIngredient"(): $Ingredient
 "withCount"(count: integer): $InputItem
 "isWildcard"(): boolean
 "toJson"(): $JsonElement
 "canBeUsedForMatching"(): boolean
 "getDisplayStacks"(): $ItemStackSet
}

export namespace $IngredientKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientKJS$Type = ($IngredientKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientKJS_ = $IngredientKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$RecipeFlags" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RecipeFlags {

}

export namespace $RecipeFlags {
const INGREDIENT_ACTIONS: integer
const STAGE: integer
const MIRROR: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFlags$Type = ($RecipeFlags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFlags_ = $RecipeFlags$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$KubeJSPlugin" {
import {$LangEventJS, $LangEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$LangEventJS"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$RegisterRecipeSchemasEvent, $RegisterRecipeSchemasEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RegisterRecipeSchemasEvent"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$CommonProperties, $CommonProperties$Type} from "packages/dev/latvian/mods/kubejs/$CommonProperties"
import {$RecipesEventJS, $RecipesEventJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipesEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$DevProperties, $DevProperties$Type} from "packages/dev/latvian/mods/kubejs/$DevProperties"
import {$DataJsonGenerator, $DataJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$DataJsonGenerator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachmentType"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$DataExport, $DataExport$Type} from "packages/dev/latvian/mods/kubejs/server/$DataExport"
import {$CustomJavaToJsWrappersEvent, $CustomJavaToJsWrappersEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$CustomJavaToJsWrappersEvent"
import {$RecipeComponentFactoryRegistryEvent, $RecipeComponentFactoryRegistryEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactoryRegistryEvent"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$ClassFilter, $ClassFilter$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassFilter"
import {$ClientProperties, $ClientProperties$Type} from "packages/dev/latvian/mods/kubejs/client/$ClientProperties"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSPlugin {

constructor()

public "toString"(): string
public "init"(): void
public "clientInit"(): void
public "registerBindings"(event: $BindingsEvent$Type): void
public "initStartup"(): void
public "afterInit"(): void
public "registerEvents"(): void
public "registerClasses"(type: $ScriptType$Type, filter: $ClassFilter$Type): void
public "onServerReload"(): void
public "loadDevProperties"(properties: $DevProperties$Type): void
public "clearCaches"(): void
public "generateLang"(event: $LangEventJS$Type): void
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "exportServerData"(arg0: $DataExport$Type): void
public "attachServerData"(event: $AttachedData$Type<($MinecraftServer$Type)>): void
public "generateDataJsons"(generator: $DataJsonGenerator$Type): void
public "attachPlayerData"(event: $AttachedData$Type<($Player$Type)>): void
public "attachLevelData"(event: $AttachedData$Type<($Level$Type)>): void
public "registerTypeWrappers"(type: $ScriptType$Type, typeWrappers: $TypeWrappers$Type): void
public "registerBlockEntityAttachments"(types: $List$Type<($BlockEntityAttachmentType$Type)>): void
public "injectRuntimeRecipes"(event: $RecipesEventJS$Type, manager: $RecipeManager$Type, recipesByName: $Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>): void
public "loadCommonProperties"(properties: $CommonProperties$Type): void
public "registerRecipeSchemas"(event: $RegisterRecipeSchemasEvent$Type): void
public "registerRecipeComponents"(event: $RecipeComponentFactoryRegistryEvent$Type): void
public "loadClientProperties"(properties: $ClientProperties$Type): void
public "registerCustomJavaToJsWrappers"(event: $CustomJavaToJsWrappersEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPlugin$Type = ($KubeJSPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSPlugin_ = $KubeJSPlugin$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdScriptableObject" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"
import {$ScriptableObject, $ScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject"

export class $IdScriptableObject extends $ScriptableObject implements $IdFunctionCall {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()
constructor(scope: $Scriptable$Type, prototype: $Scriptable$Type)

public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, name: string): void
public "delete"(cx: $Context$Type, key: $Symbol$Type): void
public "getAttributes"(cx: $Context$Type, key: $Symbol$Type): integer
public "getAttributes"(cx: $Context$Type, name: string): integer
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, name: string, start: $Scriptable$Type): boolean
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "exportAsJSClass"(maxPrototypeId: integer, scope: $Scriptable$Type, sealed: boolean, cx: $Context$Type): $IdFunctionObject
public "hasPrototypeMap"(): boolean
public "initPrototypeValue"(id: integer, key: $Symbol$Type, value: any, attributes: integer): void
public "initPrototypeValue"(id: integer, name: string, value: any, attributes: integer): void
public "setAttributes"(cx: $Context$Type, name: string, attributes: integer): void
public "initPrototypeConstructor"(f: $IdFunctionObject$Type, cx: $Context$Type): void
public "activatePrototypeMap"(maxPrototypeId: integer): void
public "initPrototypeMethod"(tag: any, id: integer, key: $Symbol$Type, functionName: string, arity: integer, cx: $Context$Type): $IdFunctionObject
public "initPrototypeMethod"(tag: any, id: integer, name: string, arity: integer, cx: $Context$Type): $IdFunctionObject
public "initPrototypeMethod"(tag: any, id: integer, propertyName: string, functionName: string, arity: integer, cx: $Context$Type): $IdFunctionObject
public "defineOwnProperty"(cx: $Context$Type, key: any, desc: $ScriptableObject$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdScriptableObject$Type = ($IdScriptableObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdScriptableObject_ = $IdScriptableObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Block" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $Block extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "addStatement"(statement: $AstNode$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Block$Type = ($Block);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Block_ = $Block$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS extends $RecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "afterLoaded"(): void
public "createRecipe"(): $Recipe<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS$Type = ($SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS_ = $SequencedAssemblyRecipeSchema$SequencedAssemblyRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventHandlerContainer" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$EventResult, $EventResult$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult"
import {$IEventHandler, $IEventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$IEventHandler"
import {$EventExceptionHandler, $EventExceptionHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventExceptionHandler"

export class $EventHandlerContainer {
readonly "extraId": any
readonly "handler": $IEventHandler
readonly "source": string
readonly "line": integer

constructor(extraId: any, handler: $IEventHandler$Type, source: string, line: integer)

public "add"(extraId: any, handler: $IEventHandler$Type, source: string, line: integer): void
public "toString"(): string
public static "isEmpty"(array: ($EventHandlerContainer$Type)[]): boolean
public "handle"(event: $EventJS$Type, exh: $EventExceptionHandler$Type): $EventResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerContainer$Type = ($EventHandlerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventHandlerContainer_ = $EventHandlerContainer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$DevProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DevProperties {
 "debugInfo": boolean
 "dataPackOutput": boolean
 "logAddedRecipes": boolean
 "logRemovedRecipes": boolean
 "logModifiedRecipes": boolean
 "logSkippedRecipes": boolean
 "logSkippedTags": boolean
 "logErroringRecipes": boolean
 "logInvalidRecipeHandlers": boolean
 "logSkippedPlugins": boolean
 "logGeneratedData": boolean
 "strictTags": boolean
 "alwaysCaptureErrors": boolean


public "remove"(key: string): void
public "get"(key: string, def: boolean): boolean
public "get"(key: string, def: string): string
public static "get"(): $DevProperties
public "save"(): void
public static "reload"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DevProperties$Type = ($DevProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DevProperties_ = $DevProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ShovelItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HandheldItemBuilder, $HandheldItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ShovelItemBuilder extends $HandheldItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShovelItemBuilder$Type = ($ShovelItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShovelItemBuilder_ = $ShovelItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export interface $MobFilter extends $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)> {

 "test"(arg0: $MobCategory$Type, arg1: $MobSpawnSettings$SpawnerData$Type): boolean
 "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
 "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
 "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>

(arg0: $MobCategory$Type, arg1: $MobSpawnSettings$SpawnerData$Type): boolean
}

export namespace $MobFilter {
const ALWAYS_TRUE: $MobFilter
const ALWAYS_FALSE: $MobFilter
function of(cx: $Context$Type, o: any): $MobFilter
function idFilter(cx: $Context$Type, s: string): $MobFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobFilter$Type = (Special.EntityType) | (($MobFilter$Type)[]) | ({"id"?: Special.EntityType, "category": string, "or"?: $MobFilter$Type, "type"?: Special.EntityType, "not"?: $MobFilter$Type}) | ($MobFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobFilter_ = $MobFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$AddJEIEventJS" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"

export class $AddJEIEventJS<T> extends $EventJS {

constructor(r: $IJeiRuntime$Type, t: $IIngredientType$Type<(T)>, f: $Function$Type<(any), (T)>, i: $Predicate$Type<(T)>)

public "add"(o: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddJEIEventJS$Type<T> = ($AddJEIEventJS<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddJEIEventJS_<T> = $AddJEIEventJS$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ShearsItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ShearsItemBuilder extends $ItemBuilder {
static readonly "TAG": $ResourceLocation
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
public "speedBaseline"(f: float): $ShearsItemBuilder
public static "isCustomShears"(stack: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShearsItemBuilder$Type = ($ShearsItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShearsItemBuilder_ = $ShearsItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$BlockStateComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockStateComponent extends $Record implements $RecipeComponent<($BlockState)> {
static readonly "INPUT": $RecipeComponent<($BlockState)>
static readonly "OUTPUT": $RecipeComponent<($BlockState)>
static readonly "BLOCK": $RecipeComponent<($BlockState)>
static readonly "INPUT_STRING": $RecipeComponent<($BlockState)>
static readonly "OUTPUT_STRING": $RecipeComponent<($BlockState)>
static readonly "BLOCK_STRING": $RecipeComponent<($BlockState)>

constructor(crole: $ComponentRole$Type, preferObjectForm: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: $BlockState$Type): $JsonElement
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: $BlockState$Type, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $BlockState$Type, match: $ReplacementMatch$Type): boolean
public "checkEmpty"(key: $RecipeKey$Type<($BlockState$Type)>, value: $BlockState$Type): string
public "crole"(): $ComponentRole
public "preferObjectForm"(): boolean
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($BlockState)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($BlockState)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($BlockState), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($BlockState), (O)>
public "asArray"(): $ArrayRecipeComponent<($BlockState)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($BlockState)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($BlockState)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($BlockState)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($BlockState$Type)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($BlockState$Type)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($BlockState$Type)>, map: $Map$Type<(any), (any)>): void
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "orSelf"(): $RecipeComponent<($BlockState)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($BlockState)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($BlockState)>)>
public "replaceOutput"(recipe: $RecipeJS$Type, original: $BlockState$Type, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $BlockState
public "replaceInput"(recipe: $RecipeJS$Type, original: $BlockState$Type, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $BlockState
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: $BlockState$Type, newValue: $BlockState$Type): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateComponent$Type = ($BlockStateComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateComponent_ = $BlockStateComponent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$CachedPowers" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CachedPowers {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CachedPowers$Type = ($CachedPowers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CachedPowers_ = $CachedPowers$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$NamespaceFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$WrappedJS, $WrappedJS$Type} from "packages/dev/latvian/mods/kubejs/util/$WrappedJS"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$RecipeNamespace, $RecipeNamespace$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NamespaceFunction extends $BaseFunction implements $WrappedJS {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(namespace: $RecipeNamespace$Type, map: $Map$Type<(string), ($RecipeTypeFunction$Type)>)

public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args0: (any)[]): any
public "getMod"(): string
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "mod"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamespaceFunction$Type = ($NamespaceFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamespaceFunction_ = $NamespaceFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$Extra$Transformer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Extra$Transformer {

 "transform"(arg0: any): any

(arg0: any): any
}

export namespace $Extra$Transformer {
const IDENTITY: $Extra$Transformer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Extra$Transformer$Type = ($Extra$Transformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Extra$Transformer_ = $Extra$Transformer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/mixin/common/$EventHandlerInvoker" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$EventResult, $EventResult$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"

export interface $EventHandlerInvoker {

 "callPost"(arg0: $EventJS$Type, arg1: any): $EventResult
 "callHasResult"(): $EventHandler
}

export namespace $EventHandlerInvoker {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandlerInvoker$Type = ($EventHandlerInvoker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventHandlerInvoker_ = $EventHandlerInvoker$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$RecipeKJS" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $RecipeKJS {

 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $RecipeKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKJS$Type = ($RecipeKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeKJS_ = $RecipeKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$LinkedHashMap, $LinkedHashMap$Type} from "packages/java/util/$LinkedHashMap"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$RecipeSchemaType, $RecipeSchemaType$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $RecipeNamespace extends $LinkedHashMap<(string), ($RecipeSchemaType)> {
readonly "name": string

constructor(name: string)

public "toString"(): string
public "register"(id: string, type: $RecipeSchema$Type): $RecipeNamespace
public static "getAll"(): $Map<(string), ($RecipeNamespace)>
public "registerBasic"(id: string, ...keys: ($RecipeKey$Type<(any)>)[]): $RecipeNamespace
public static "getMappedRecipes"(): $Map<(string), ($ResourceLocation)>
public "shapeless"(id: string): $RecipeNamespace
public "shaped"(id: string): $RecipeNamespace
public "special"(id: string): $RecipeNamespace
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "put"(arg0: K, arg1: V): V
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "size"(): integer
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
get "all"(): $Map<(string), ($RecipeNamespace)>
get "mappedRecipes"(): $Map<(string), ($ResourceLocation)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeNamespace$Type = ($RecipeNamespace);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeNamespace_ = $RecipeNamespace$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnitParseException" {
import {$IllegalStateException, $IllegalStateException$Type} from "packages/java/lang/$IllegalStateException"

export class $UnitParseException extends $IllegalStateException {

constructor(s: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitParseException$Type = ($UnitParseException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitParseException_ = $UnitParseException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/properties/$RemoveOresProperties" {
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"

export class $RemoveOresProperties {
 "worldgenLayer": $GenerationStep$Decoration
 "blocks": $BlockStatePredicate
 "biomes": $BiomeFilter

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveOresProperties$Type = ($RemoveOresProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveOresProperties_ = $RemoveOresProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/$KubeJSMenu" {
import {$KubeJSGUI, $KubeJSGUI$Type} from "packages/dev/latvian/mods/kubejs/gui/$KubeJSGUI"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/dev/architectury/registry/registries/$DeferredRegister"

export class $KubeJSMenu extends $AbstractContainerMenu {
static readonly "MENU_TYPES": $DeferredRegister<($MenuType<(any)>)>
static readonly "KUBEJS_MENU": $Supplier<($MenuType<($KubeJSMenu)>)>
readonly "player": $Player
readonly "guiData": $KubeJSGUI
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(id: integer, inventory: $Inventory$Type, buf: $FriendlyByteBuf$Type)
constructor(id: integer, inventory: $Inventory$Type, guiData: $KubeJSGUI$Type)

public static "init"(): void
public "stillValid"(player: $Player$Type): boolean
public "quickMoveStack"(player: $Player$Type, i: integer): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSMenu$Type = ($KubeJSMenu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSMenu_ = $KubeJSMenu$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$ModFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $ModFilter implements $RecipeFilter {

constructor(m: string)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModFilter$Type = ($ModFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModFilter_ = $ModFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$KubeJSCraftingRecipe" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$CraftingRecipe, $CraftingRecipe$Type} from "packages/net/minecraft/world/item/crafting/$CraftingRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export interface $KubeJSCraftingRecipe extends $CraftingRecipe {

 "kjs$getModifyResult"(): $ModifyRecipeResultCallback
 "kjs$getIngredientActions"(): $List<($IngredientAction)>
 "kjs$getRemainingItems"(container: $CraftingContainer$Type): $NonNullList<($ItemStack)>
 "kjs$assemble"(container: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
 "kjs$getStage"(): string
 "category"(): $CraftingBookCategory
 "getResultItem"(arg0: $RegistryAccess$Type): $ItemStack
 "getRemainingItems"(arg0: $CraftingContainer$Type): $NonNullList<($ItemStack)>
 "getIngredients"(): $NonNullList<($Ingredient)>
 "getToastSymbol"(): $ItemStack
 "isIncomplete"(): boolean
 "canCraftInDimensions"(arg0: integer, arg1: integer): boolean
 "getSerializer"(): $RecipeSerializer<(any)>
 "showNotification"(): boolean
 "assemble"(arg0: $CraftingContainer$Type, arg1: $RegistryAccess$Type): $ItemStack
 "getId"(): $ResourceLocation
 "matches"(arg0: $CraftingContainer$Type, arg1: $Level$Type): boolean
 "isSpecial"(): boolean
 "getType"(): $ResourceLocation
 "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
 "setGroup"(group: string): void
 "hasInput"(match: $ReplacementMatch$Type): boolean
 "getOrCreateId"(): $ResourceLocation
 "getSchema"(): $RecipeSchema
 "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
 "hasOutput"(match: $ReplacementMatch$Type): boolean
 "getGroup"(): string
 "getMod"(): string
}

export namespace $KubeJSCraftingRecipe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCraftingRecipe$Type = ($KubeJSCraftingRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCraftingRecipe_ = $KubeJSCraftingRecipe$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptFile" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$ScriptPack, $ScriptPack$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPack"
import {$ScriptFileInfo, $ScriptFileInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptFileInfo"
import {$ScriptSource, $ScriptSource$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptSource"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFile implements $Comparable<($ScriptFile)> {
readonly "pack": $ScriptPack
readonly "info": $ScriptFileInfo
readonly "source": $ScriptSource

constructor(p: $ScriptPack$Type, i: $ScriptFileInfo$Type, s: $ScriptSource$Type)

public "compareTo"(o: $ScriptFile$Type): integer
public "load"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFile$Type = ($ScriptFile);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptFile_ = $ScriptFile$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Log10FuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $Log10FuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Log10FuncUnit$Type = ($Log10FuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Log10FuncUnit_ = $Log10FuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ItemStackKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$IngredientSupplierKJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$SpecialEquality, $SpecialEquality$Type} from "packages/dev/latvian/mods/rhino/util/$SpecialEquality"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$NBTSerializable, $NBTSerializable$Type} from "packages/dev/latvian/mods/rhino/mod/util/$NBTSerializable"
import {$JsonSerializable, $JsonSerializable$Type} from "packages/dev/latvian/mods/rhino/mod/util/$JsonSerializable"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ItemStackKJS extends $SpecialEquality, $NBTSerializable, $JsonSerializable, $IngredientSupplierKJS {

 "self"(): $ItemStack
 "asIngredient"(): $Ingredient
 "getTags"(): $Collection<($ResourceLocation)>
 "enchant"(enchantment: $Enchantment$Type, level: integer): $ItemStack
 "enchant"(enchantments: $Map$Type<(any), (any)>): $ItemStack
 "hasTag"(tag: $ResourceLocation$Type): boolean
 "hasEnchantment"(enchantment: $Enchantment$Type, level: integer): boolean
 "isBlock"(): boolean
 "getNbtString"(): string
 "withNBT"(nbt: $CompoundTag$Type): $ItemStack
 "removeTag"(): void
 "withName"(displayName: $Component$Type): $ItemStack
 "withCount"(c: integer): $ItemStack
 "strongNBT"(): $Ingredient
/**
 * 
 * @deprecated
 */
 "ignoreNBT"(): $Ingredient
 "weakNBT"(): $Ingredient
 "toItemString"(): string
 "toNBT"(): $CompoundTag
 "areItemsEqual"(other: $ItemStack$Type): boolean
 "isNBTEqual"(other: $ItemStack$Type): boolean
 "withLore"(text: ($Component$Type)[]): $ItemStack
 "withChance"(chance: double): $OutputItem
 "getIdLocation"(): $ResourceLocation
 "getId"(): string
 "getTypeData"(): $CompoundTag
 "getMod"(): string
 "getHarvestSpeed"(): float
 "getHarvestSpeed"(block: $BlockContainerJS$Type): float
 "equalsIgnoringCount"(stack: $ItemStack$Type): boolean
 "getEnchantments"(): $Map<(string), (integer)>
 "toJson"(): $JsonObject
 "specialEquals"(o: any, shallow: boolean): boolean
}

export namespace $ItemStackKJS {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKJS$Type = ($ItemStackKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackKJS_ = $ItemStackKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$Callback" {
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export interface $ScheduledEvents$Callback {

 "onCallback"(arg0: $ScheduledEvents$ScheduledEvent$Type): void

(arg0: $ScheduledEvents$ScheduledEvent$Type): void
}

export namespace $ScheduledEvents$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Callback$Type = ($ScheduledEvents$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents$Callback_ = $ScheduledEvents$Callback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ScreenPainterObject, $ScreenPainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenPainterObject"
import {$PainterObject, $PainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObject"

export class $PainterObjectStorage {
readonly "painter": $Painter

constructor(p: $Painter$Type)

public "remove"(id: string): void
public "clear"(): void
public "handle"(root: $CompoundTag$Type): void
public "getObject"(key: string): $PainterObject
public "getObjects"(): $Collection<($PainterObject)>
public "createScreenObjects"(): ($ScreenPainterObject)[]
get "objects"(): $Collection<($PainterObject)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PainterObjectStorage$Type = ($PainterObjectStorage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PainterObjectStorage_ = $PainterObjectStorage$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ObjectProperty" {
import {$InfixExpression, $InfixExpression$Type} from "packages/dev/latvian/mods/rhino/ast/$InfixExpression"

export class $ObjectProperty extends $InfixExpression {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "isMethod"(): boolean
public "setIsNormalMethod"(): void
public "setIsSetterMethod"(): void
public "setIsGetterMethod"(): void
public "isSetterMethod"(): boolean
public "isGetterMethod"(): boolean
public "isNormalMethod"(): boolean
public "setNodeType"(nodeType: integer): void
get "method"(): boolean
get "setterMethod"(): boolean
get "getterMethod"(): boolean
get "normalMethod"(): boolean
set "nodeType"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectProperty$Type = ($ObjectProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectProperty_ = $ObjectProperty$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$TaggedTemplateLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $TaggedTemplateLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getTarget"(): $AstNode
public "setTarget"(target: $AstNode$Type): void
public "setTemplateLiteral"(templateLiteral: $AstNode$Type): void
public "getTemplateLiteral"(): $AstNode
get "target"(): $AstNode
set "target"(value: $AstNode$Type)
set "templateLiteral"(value: $AstNode$Type)
get "templateLiteral"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TaggedTemplateLiteral$Type = ($TaggedTemplateLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TaggedTemplateLiteral_ = $TaggedTemplateLiteral$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/wrap/$ArrayTypeWrapperFactory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TypeWrapper, $TypeWrapper$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapper"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"

export class $ArrayTypeWrapperFactory<T> implements $TypeWrapperFactory<((T)[])> {
readonly "typeWrapper": $TypeWrapper<(T)>
readonly "target": $Class<(T)>
readonly "arrayTarget": $Class<((T)[])>

constructor(tw: $TypeWrapper$Type<(T)>, t: $Class$Type<(T)>, at: $Class$Type<((T)[])>)

public "wrap"(cx: $Context$Type, o: any): (T)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayTypeWrapperFactory$Type<T> = ($ArrayTypeWrapperFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayTypeWrapperFactory_<T> = $ArrayTypeWrapperFactory$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$AndFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $AndFilter implements $RecipeFilter {
readonly "list": $List<($RecipeFilter)>

constructor()

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndFilter$Type = ($AndFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndFilter_ = $AndFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$TagFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $TagFilter extends $Record implements $BiomeFilter {

constructor(id: string)
constructor(tag: $TagKey$Type<($Biome$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "tag"(): $TagKey<($Biome)>
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagFilter$Type = ($TagFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagFilter_ = $TagFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$GeneratedClassLoader" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $GeneratedClassLoader {

 "defineClass"(arg0: string, arg1: (byte)[]): $Class<(any)>
 "linkClass"(arg0: $Class$Type<(any)>): void
}

export namespace $GeneratedClassLoader {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedClassLoader$Type = ($GeneratedClassLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedClassLoader_ = $GeneratedClassLoader$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$CustomIngredientActionCallback" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $CustomIngredientActionCallback {

 "transform"(arg0: $ItemStack$Type, arg1: integer, arg2: $InventoryKJS$Type): $ItemStack

(arg0: $ItemStack$Type, arg1: integer, arg2: $InventoryKJS$Type): $ItemStack
}

export namespace $CustomIngredientActionCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientActionCallback$Type = ($CustomIngredientActionCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomIngredientActionCallback_ = $CustomIngredientActionCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$BasicMobEffect$Builder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MobEffectBuilder, $MobEffectBuilder$Type} from "packages/dev/latvian/mods/kubejs/misc/$MobEffectBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $BasicMobEffect$Builder extends $MobEffectBuilder {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $MobEffect
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicMobEffect$Builder$Type = ($BasicMobEffect$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicMobEffect$Builder_ = $BasicMobEffect$Builder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$LevelKJS" {
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptTypeHolder, $ScriptTypeHolder$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypeHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$WithAttachedData, $WithAttachedData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithAttachedData"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FireworksJS, $FireworksJS$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ExplosionJS, $ExplosionJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $LevelKJS extends $WithAttachedData<($Level)>, $ScriptTypeHolder {

 "self"(): $Level
 "getBlock"(x: integer, y: integer, z: integer): $BlockContainerJS
 "getBlock"(pos: $BlockPos$Type): $BlockContainerJS
 "getBlock"(blockEntity: $BlockEntity$Type): $BlockContainerJS
 "getSide"(): $ScriptType
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "createExplosion"(x: double, y: double, z: double): $ExplosionJS
 "getEntitiesWithin"(aabb: $AABB$Type): $EntityArrayList
 "createEntityList"(entities: $Collection$Type<(any)>): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "getEntities"(): $EntityArrayList
 "isOverworld"(): boolean
 "getDimension"(): $ResourceLocation
 "createEntity"(type: $EntityType$Type<(any)>): $Entity
 "spawnFireworks"(x: double, y: double, z: double, f: $FireworksJS$Type): void
 "spawnParticles"(options: $ParticleOptions$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(): $Level
}

export namespace $LevelKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelKJS$Type = ($LevelKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelKJS_ = $LevelKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$StringBuilderAppendable" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export interface $StringBuilderAppendable {

 "appendString"(arg0: $StringBuilder$Type): void

(arg0: $StringBuilder$Type): void
}

export namespace $StringBuilderAppendable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringBuilderAppendable$Type = ($StringBuilderAppendable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringBuilderAppendable_ = $StringBuilderAppendable$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$TopLevel" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$TopLevel$Builtins, $TopLevel$Builtins$Type} from "packages/dev/latvian/mods/rhino/$TopLevel$Builtins"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $TopLevel extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()

public "getClassName"(): string
public "cacheBuiltins"(scope: $Scriptable$Type, sealed: boolean, cx: $Context$Type): void
public static "getBuiltinCtor"(cx: $Context$Type, scope: $Scriptable$Type, type: $TopLevel$Builtins$Type): $Function
public "getBuiltinCtor"(type: $TopLevel$Builtins$Type): $BaseFunction
public "getBuiltinPrototype"(cx: $Context$Type, type: $TopLevel$Builtins$Type): $Scriptable
public static "getBuiltinPrototype"(scope: $Scriptable$Type, type: $TopLevel$Builtins$Type, cx: $Context$Type): $Scriptable
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TopLevel$Type = ($TopLevel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TopLevel_ = $TopLevel$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ImplementationVersion" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ImplementationVersion {


public static "get"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImplementationVersion$Type = ($ImplementationVersion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImplementationVersion_ = $ImplementationVersion$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Context" {
import {$GeneratedClassLoader, $GeneratedClassLoader$Type} from "packages/dev/latvian/mods/rhino/$GeneratedClassLoader"
import {$RegExp, $RegExp$Type} from "packages/dev/latvian/mods/rhino/regexp/$RegExp"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CustomJavaToJsWrapperProvider, $CustomJavaToJsWrapperProvider$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapperProvider"
import {$Script, $Script$Type} from "packages/dev/latvian/mods/rhino/$Script"
import {$ClassShutter, $ClassShutter$Type} from "packages/dev/latvian/mods/rhino/$ClassShutter"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$WrapFactory, $WrapFactory$Type} from "packages/dev/latvian/mods/rhino/$WrapFactory"
import {$Remapper, $Remapper$Type} from "packages/dev/latvian/mods/rhino/util/$Remapper"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"
import {$ScriptableObject, $ScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject"

export class $Context {
readonly "lock": any
 "generateObserverCount": boolean


public "getProperty"<T>(key: string, def: T): T
public "getProperty"(key: string): any
public "newArray"(scope: $Scriptable$Type, length: integer): $Scriptable
public "newArray"(scope: $Scriptable$Type, elements: (any)[]): $Scriptable
public "setProperty"(key: string, value: any): void
public "getImplementationVersion"(): string
public static "reportError"(cx: $Context$Type, message: string): void
public static "reportError"(cx: $Context$Type, message: string, lineno: integer, lineSource: string, lineOffset: integer, sourceName: string): void
public "createClassLoader"(parent: $ClassLoader$Type): $GeneratedClassLoader
public "getMaximumInterpreterStackDepth"(): integer
public "setMaximumInterpreterStackDepth"(max: integer): void
public "getInstructionObserverThreshold"(): integer
public "setGenerateObserverCount"(generateObserverCount: boolean): void
public "setInstructionObserverThreshold"(threshold: integer): void
public "getApplicationClassLoader"(): $ClassLoader
public static "reportRuntimeError4"(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any, cx: $Context$Type): $EvaluatorException
public "initSafeStandardObjects"(scope: $ScriptableObject$Type): $Scriptable
public "initSafeStandardObjects"(): $ScriptableObject
public "initSafeStandardObjects"(scope: $ScriptableObject$Type, sealed: boolean): $ScriptableObject
public static "reportRuntimeError3"(messageId: string, arg1: any, arg2: any, arg3: any, cx: $Context$Type): $EvaluatorException
public "newClassSerialNumber"(): integer
public "lastStoredScriptable"(): $Scriptable
public "addCustomJavaToJsWrapper"<T>(type: $Class$Type<(T)>, provider: $CustomJavaToJsWrapperProvider$Type<(T)>): void
public "addCustomJavaToJsWrapper"<T>(predicate: $Predicate$Type<(T)>, provider: $CustomJavaToJsWrapperProvider$Type<(T)>): void
public static "enter"(): $Context
public static "reportRuntimeError"(message: string, cx: $Context$Type): $EvaluatorException
public static "reportRuntimeError"(cx: $Context$Type, message: string, sourceName: string, lineno: integer, lineSource: string, lineOffset: integer): $EvaluatorException
public "getTypeWrappers"(): $TypeWrappers
public "setClassShutter"(shutter: $ClassShutter$Type): void
public "setRemapper"(remapper: $Remapper$Type): void
public static "reportRuntimeError0"(messageId: string, cx: $Context$Type): $EvaluatorException
public "getRemapper"(): $Remapper
public static "getSourcePositionFromStack"(cx: $Context$Type, linep: (integer)[]): string
public "setApplicationClassLoader"(loader: $ClassLoader$Type): void
public "initStandardObjects"(scope: $ScriptableObject$Type): $Scriptable
public "initStandardObjects"(scope: $ScriptableObject$Type, sealed: boolean): $ScriptableObject
public "initStandardObjects"(): $ScriptableObject
public static "jsToJava"(cx: $Context$Type, value: any, desiredType: $Class$Type<(any)>): any
public "getWrapFactory"(): $WrapFactory
public "doTopCall"(scope: $Scriptable$Type, callable: $Callable$Type, thisObj: $Scriptable$Type, args: (any)[], isTopLevelStrict: boolean): any
public "getTopCallScope"(): $Scriptable
public "getClassShutter"(): $ClassShutter
public "setWrapFactory"(wrapFactory: $WrapFactory$Type): void
public "storeScriptable"(value: $Scriptable$Type): void
public "callSync"(callable: $Callable$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "setTopCall"(scope: $Scriptable$Type): void
public "getTopCallOrThrow"(): $Scriptable
public "hasTopCallScope"(): boolean
public static "getUndefinedValue"(): any
public static "reportWarning"(cx: $Context$Type, message: string, sourceName: string, lineno: integer, lineSource: string, lineOffset: integer): void
public static "reportWarning"(message: string, cx: $Context$Type): void
public static "javaToJS"(cx: $Context$Type, value: any, scope: $Scriptable$Type): any
public "hasTypeWrappers"(): boolean
public "compileReader"(arg0: $Reader$Type, sourceName: string, lineno: integer, securityDomain: any): $Script
public "removeThreadLocal"(key: any): void
public "evaluateReader"(scope: $Scriptable$Type, arg1: $Reader$Type, sourceName: string, lineno: integer, securityDomain: any): any
public "compileString"(source: string, sourceName: string, lineno: integer, securityDomain: any): $Script
public "getThreadLocal"(key: any): any
public "evaluateString"(scope: $Scriptable$Type, source: string, sourceName: string, lineno: integer, securityDomain: any): any
public "putThreadLocal"(key: any, value: any): void
public "addToScope"(scope: $Scriptable$Type, name: string, value: any): void
public "wrapCustomJavaToJs"(javaObject: any): $CustomJavaToJsWrapper
public "isStrictMode"(): boolean
public static "throwAsScriptRuntimeEx"(e: $Throwable$Type, cx: $Context$Type): $RuntimeException
public "getErrorReporter"(): $ErrorReporter
public "getRegExp"(): $RegExp
public "newObject"(scope: $Scriptable$Type, constructorName: string, args: (any)[]): $Scriptable
public "newObject"(scope: $Scriptable$Type, constructorName: string): $Scriptable
public "newObject"(scope: $Scriptable$Type): $Scriptable
public static "reportRuntimeError1"(messageId: string, arg1: any, cx: $Context$Type): $EvaluatorException
public static "reportRuntimeError2"(messageId: string, arg1: any, arg2: any, cx: $Context$Type): $EvaluatorException
get "implementationVersion"(): string
get "maximumInterpreterStackDepth"(): integer
set "maximumInterpreterStackDepth"(value: integer)
get "instructionObserverThreshold"(): integer
set "generateObserverCount"(value: boolean)
set "instructionObserverThreshold"(value: integer)
get "applicationClassLoader"(): $ClassLoader
get "typeWrappers"(): $TypeWrappers
set "classShutter"(value: $ClassShutter$Type)
set "remapper"(value: $Remapper$Type)
get "remapper"(): $Remapper
set "applicationClassLoader"(value: $ClassLoader$Type)
get "wrapFactory"(): $WrapFactory
get "topCallScope"(): $Scriptable
get "classShutter"(): $ClassShutter
set "wrapFactory"(value: $WrapFactory$Type)
set "topCall"(value: $Scriptable$Type)
get "topCallOrThrow"(): $Scriptable
get "undefinedValue"(): any
get "strictMode"(): boolean
get "errorReporter"(): $ErrorReporter
get "regExp"(): $RegExp
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Context$Type = ($Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Context_ = $Context$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptPackInfo" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptFileInfo, $ScriptFileInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptFileInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPackInfo {
readonly "namespace": string
readonly "displayName": $Component
readonly "scripts": $List<($ScriptFileInfo)>
readonly "pathStart": string

constructor(n: string, p: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPackInfo$Type = ($ScriptPackInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptPackInfo_ = $ScriptPackInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabIconSupplier" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $CreativeTabIconSupplier {

 "getIcon"(): $ItemStack

(): $ItemStack
}

export namespace $CreativeTabIconSupplier {
const DEFAULT: $CreativeTabIconSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIconSupplier$Type = ($CreativeTabIconSupplier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabIconSupplier_ = $CreativeTabIconSupplier$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$OrderedCompoundTag" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$TagType, $TagType$Type} from "packages/net/minecraft/nbt/$TagType"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$DataOutput, $DataOutput$Type} from "packages/java/io/$DataOutput"

export class $OrderedCompoundTag extends $CompoundTag {
readonly "tagMap": $Map<(string), ($Tag)>
static readonly "CODEC": $Codec<($CompoundTag)>
static readonly "TYPE": $TagType<($CompoundTag)>
readonly "tags": $Map<(string), ($Tag)>

constructor(map: $Map$Type<(string), ($Tag$Type)>)
constructor()

public "write"(dataOutput: $DataOutput$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrderedCompoundTag$Type = ($OrderedCompoundTag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrderedCompoundTag_ = $OrderedCompoundTag$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$CeilFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $CeilFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CeilFuncUnit$Type = ($CeilFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CeilFuncUnit_ = $CeilFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$BoilerHeaterHandlerEvent$BoilerHeaterCallback" {
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"

export interface $BoilerHeaterHandlerEvent$BoilerHeaterCallback {

 "updateHeat"(arg0: $BlockContainerJS$Type): float

(arg0: $BlockContainerJS$Type): float
}

export namespace $BoilerHeaterHandlerEvent$BoilerHeaterCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type = ($BoilerHeaterHandlerEvent$BoilerHeaterCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilerHeaterHandlerEvent$BoilerHeaterCallback_ = $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$EmptyExpression" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $EmptyExpression extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyExpression$Type = ($EmptyExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyExpression_ = $EmptyExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuData" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent$Callback"
import {$ChestMenuInventoryClickEvent$Callback, $ChestMenuInventoryClickEvent$Callback$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuInventoryClickEvent$Callback"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$ChestMenuSlot, $ChestMenuSlot$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuSlot"

export class $ChestMenuData {
readonly "player": $ServerPlayer
 "title": $Component
readonly "rows": integer
readonly "slots": ($ChestMenuSlot)[]
 "anyClicked": $ChestMenuClickEvent$Callback
 "inventoryClicked": $ChestMenuInventoryClickEvent$Callback
 "playerSlots": boolean
 "closed": $Runnable
 "mouseItem": $ItemStack
 "capturedInventory": $Container

constructor(player: $ServerPlayer$Type, title: $Component$Type, rows: integer)

public "slot"(x0: integer, y0: integer, x1: integer, y1: integer, slot: $Consumer$Type<($ChestMenuSlot$Type)>): void
public "slot"(x: integer, y: integer, slot: $Consumer$Type<($ChestMenuSlot$Type)>): void
public "getSlot"(x: integer, y: integer): $ChestMenuSlot
public "sync"(): void
public "handleClick"(index: integer, type: $ClickType$Type, button: integer): void
public "button"(x: integer, y: integer, stack: $ItemStack$Type, displayName: $Component$Type, leftClicked: $ChestMenuClickEvent$Callback$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuData$Type = ($ChestMenuData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuData_ = $ChestMenuData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$SmithingTrimRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"

export interface $SmithingTrimRecipeSchema {

}

export namespace $SmithingTrimRecipeSchema {
const TEMPLATE: $RecipeKey<($InputItem)>
const BASE: $RecipeKey<($InputItem)>
const ADDITION: $RecipeKey<($InputItem)>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTrimRecipeSchema$Type = ($SmithingTrimRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmithingTrimRecipeSchema_ = $SmithingTrimRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$MultiMaxFunc" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MultiMaxFunc extends $Unit {
readonly "units": $List<($Unit)>
static "EMPTY_ARRAY": ($Unit)[]

constructor(units: $List$Type<($Unit$Type)>)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiMaxFunc$Type = ($MultiMaxFunc);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiMaxFunc_ = $MultiMaxFunc$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$REBackTrackData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $REBackTrackData {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $REBackTrackData$Type = ($REBackTrackData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $REBackTrackData_ = $REBackTrackData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$ServerEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"

export class $ServerEventJS extends $EventJS {
readonly "server": $MinecraftServer

constructor(s: $MinecraftServer$Type)

public "getServer"(): $MinecraftServer
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerEventJS$Type = ($ServerEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerEventJS_ = $ServerEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeGlobal" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeGlobal implements $IdFunctionCall {

constructor()

public static "init"(cx: $Context$Type, scope: $Scriptable$Type, sealed: boolean): void
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeGlobal$Type = ($NativeGlobal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeGlobal_ = $NativeGlobal$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$ServerSettings" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ServerSettings {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerSettings$Type = ($ServerSettings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerSettings_ = $ServerSettings$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentValueMap" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$IdentityHashMap, $IdentityHashMap$Type} from "packages/java/util/$IdentityHashMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $ComponentValueMap extends $IdentityHashMap<($RecipeKey<(any)>), (any)> {

constructor(init: integer)

public "getValue"<T>(recipe: $RecipeJS$Type, key: $RecipeKey$Type<(T)>): T
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentValueMap$Type = ($ComponentValueMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentValueMap_ = $ComponentValueMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Pair, $Pair$Type} from "packages/org/apache/commons/lang3/tuple/$Pair"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AndRecipeComponent<A, B> extends $Record implements $RecipeComponent<($Pair<(A), (B)>)> {

constructor(a: $RecipeComponent$Type<(A)>, b: $RecipeComponent$Type<(B)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "b"(): $RecipeComponent<(B)>
public "a"(): $RecipeComponent<(A)>
public "write"(recipe: $RecipeJS$Type, value: $Pair$Type<(A), (B)>): $JsonArray
public "componentClass"(): $Class<(any)>
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Pair<(A), (B)>)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($Pair<(A), (B)>)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($Pair<(A), (B)>), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($Pair<(A), (B)>), (O)>
public "asArray"(): $ArrayRecipeComponent<($Pair<(A), (B)>)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Pair<(A), (B)>)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($Pair<(A), (B)>)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($Pair<(A), (B)>)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Pair$Type<(A), (B)>)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Pair$Type<(A), (B)>)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Pair$Type<(A), (B)>)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: $Pair$Type<(A), (B)>, match: $ReplacementMatch$Type): boolean
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $Pair$Type<(A), (B)>, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<($Pair<(A), (B)>)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($Pair<(A), (B)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Pair<(A), (B)>)>)>
public "checkEmpty"(key: $RecipeKey$Type<($Pair$Type<(A), (B)>)>, value: $Pair$Type<(A), (B)>): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: $Pair$Type<(A), (B)>, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $Pair<(A), (B)>
public "replaceInput"(recipe: $RecipeJS$Type, original: $Pair$Type<(A), (B)>, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $Pair<(A), (B)>
public "checkValueHasChanged"(oldValue: $Pair$Type<(A), (B)>, newValue: $Pair$Type<(A), (B)>): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Pair<(A), (B)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndRecipeComponent$Type<A, B> = ($AndRecipeComponent<(A), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndRecipeComponent_<A, B> = $AndRecipeComponent$Type<(A), (B)>;
}}
declare module "packages/dev/latvian/mods/kubejs/block/predicate/$BlockEntityPredicate" {
import {$BlockEntityPredicateDataCheck, $BlockEntityPredicateDataCheck$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockEntityPredicateDataCheck"
import {$BlockPredicate, $BlockPredicate$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockPredicate"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BlockEntityPredicate implements $BlockPredicate {

constructor(i: $ResourceLocation$Type)

public "toString"(): string
public "data"(cd: $BlockEntityPredicateDataCheck$Type): $BlockEntityPredicate
public "check"(block: $BlockContainerJS$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityPredicate$Type = ($BlockEntityPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityPredicate_ = $BlockEntityPredicate$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS" {
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"

export class $LivingEntityEventJS extends $EntityEventJS {

constructor()

public "getEntity"(): $LivingEntity
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityEventJS$Type = ($LivingEntityEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityEventJS_ = $LivingEntityEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$BuiltinKubeJSPlugin" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$KubeJSPlugin, $KubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSPlugin"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$ClassFilter, $ClassFilter$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassFilter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachmentType"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"
import {$RegisterRecipeSchemasEvent, $RegisterRecipeSchemasEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RegisterRecipeSchemasEvent"
import {$CustomJavaToJsWrappersEvent, $CustomJavaToJsWrappersEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$CustomJavaToJsWrappersEvent"
import {$RecipeComponentFactoryRegistryEvent, $RecipeComponentFactoryRegistryEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactoryRegistryEvent"

export class $BuiltinKubeJSPlugin extends $KubeJSPlugin {
static readonly "GLOBAL": $HashMap<(string), (any)>

constructor()

public "init"(): void
public "registerBindings"(event: $BindingsEvent$Type): void
public "initStartup"(): void
public "registerEvents"(): void
public "registerClasses"(type: $ScriptType$Type, filter: $ClassFilter$Type): void
public "clearCaches"(): void
public "registerTypeWrappers"(type: $ScriptType$Type, typeWrappers: $TypeWrappers$Type): void
public "registerBlockEntityAttachments"(types: $List$Type<($BlockEntityAttachmentType$Type)>): void
public "registerRecipeSchemas"(event: $RegisterRecipeSchemasEvent$Type): void
public "registerRecipeComponents"(event: $RecipeComponentFactoryRegistryEvent$Type): void
public "registerCustomJavaToJsWrappers"(event: $CustomJavaToJsWrappersEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuiltinKubeJSPlugin$Type = ($BuiltinKubeJSPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuiltinKubeJSPlugin_ = $BuiltinKubeJSPlugin$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$WrappedReflectionMethod" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"
import {$WrappedExecutable, $WrappedExecutable$Type} from "packages/dev/latvian/mods/rhino/$WrappedExecutable"
import {$Executable, $Executable$Type} from "packages/java/lang/reflect/$Executable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $WrappedReflectionMethod extends $Record implements $WrappedExecutable {

constructor(method: $Method$Type)

public "invoke"(cx: $Context$Type, scope: $Scriptable$Type, self: any, args: (any)[]): any
public "equals"(o: any): boolean
public "toString"(): string
public "method"(): $Method
public "hashCode"(): integer
public static "of"(method: $Method$Type): $WrappedExecutable
public "getReturnType"(): $Class<(any)>
public "isStatic"(): boolean
public "unwrap"(): $Executable
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): any
get "returnType"(): $Class<(any)>
get "static"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedReflectionMethod$Type = ($WrappedReflectionMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedReflectionMethod_ = $WrappedReflectionMethod$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuSlot" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ChestMenuData, $ChestMenuData$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuData"
import {$ChestMenuClickHandler, $ChestMenuClickHandler$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickHandler"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent$Callback"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ChestMenuSlot {
readonly "gui": $ChestMenuData
readonly "index": integer
readonly "x": integer
readonly "y": integer
 "clicked": integer
 "data": $Map<(string), (any)>
readonly "clickHandlers": $List<($ChestMenuClickHandler)>
 "inventory": $InventoryKJS
 "inventorySlot": integer

constructor(gui: $ChestMenuData$Type, index: integer)

public "toString"(): string
public "setThrown"(callback: $ChestMenuClickEvent$Callback$Type): void
public "getItem"(): $ItemStack
public "setItem"(stack: $ItemStack$Type): void
public "clicked"(type: $ClickType$Type, button: integer, callback: $ChestMenuClickEvent$Callback$Type, autoHandle: boolean): void
public "setLeftClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
public "setShiftRightClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
public "setShiftLeftClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
public "setSwapped"(callback: $ChestMenuClickEvent$Callback$Type): void
public "setRightClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
public "setDoubleClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
public "resetClickHandlers"(): void
public "setMiddleClicked"(callback: $ChestMenuClickEvent$Callback$Type): void
set "thrown"(value: $ChestMenuClickEvent$Callback$Type)
get "item"(): $ItemStack
set "item"(value: $ItemStack$Type)
set "leftClicked"(value: $ChestMenuClickEvent$Callback$Type)
set "shiftRightClicked"(value: $ChestMenuClickEvent$Callback$Type)
set "shiftLeftClicked"(value: $ChestMenuClickEvent$Callback$Type)
set "swapped"(value: $ChestMenuClickEvent$Callback$Type)
set "rightClicked"(value: $ChestMenuClickEvent$Callback$Type)
set "doubleClicked"(value: $ChestMenuClickEvent$Callback$Type)
set "middleClicked"(value: $ChestMenuClickEvent$Callback$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuSlot$Type = ($ChestMenuSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuSlot_ = $ChestMenuSlot$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$FenceGateBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$WoodType, $WoodType$Type} from "packages/net/minecraft/world/level/block/state/properties/$WoodType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $FenceGateBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "behaviour"(wt: $WoodType$Type): $FenceGateBlockBuilder
public "behaviour"(wt: string): $FenceGateBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceGateBlockBuilder$Type = ($FenceGateBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FenceGateBlockBuilder_ = $FenceGateBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$DataExport" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$Callable, $Callable$Type} from "packages/java/util/concurrent/$Callable"

export class $DataExport {
 "source": $CommandSourceStack

constructor()

public "add"(path: string, data: $Callable$Type<((byte)[])>): void
public static "exportData"(): void
public "addString"(path: string, data: string): void
public "addJson"(path: string, json: $JsonElement$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataExport$Type = ($DataExport);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataExport_ = $DataExport$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$JavaMembers$MethodInfo" {
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $JavaMembers$MethodInfo {
 "method": $Method
 "name": string
 "hidden": boolean

constructor(m: $Method$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaMembers$MethodInfo$Type = ($JavaMembers$MethodInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaMembers$MethodInfo_ = $JavaMembers$MethodInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$RemoveJEICategoriesEvent" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"

export class $RemoveJEICategoriesEvent extends $EventJS {

constructor(r: $IJeiRuntime$Type)

public "remove"(...categoriesToYeet: ($ResourceLocation$Type)[]): void
public "removeIf"(filter: $Predicate$Type<($IRecipeCategory$Type<(any)>)>): void
public "getCategoryIds"(): $Collection<($ResourceLocation)>
public "getCategories"(): $Collection<($IRecipeCategory<(any)>)>
get "categoryIds"(): $Collection<($ResourceLocation)>
get "categories"(): $Collection<($IRecipeCategory<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveJEICategoriesEvent$Type = ($RemoveJEICategoriesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveJEICategoriesEvent_ = $RemoveJEICategoriesEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$KubeJSItemProperties" {
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"

export class $KubeJSItemProperties extends $Item$Properties {
readonly "itemBuilder": $ItemBuilder

constructor(itemBuilder: $ItemBuilder$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSItemProperties$Type = ($KubeJSItemProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSItemProperties_ = $KubeJSItemProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$SimpleLevelEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$LevelEventJS, $LevelEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$LevelEventJS"

export class $SimpleLevelEventJS extends $LevelEventJS {

constructor(l: $Level$Type)

public "getLevel"(): $Level
get "level"(): $Level
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleLevelEventJS$Type = ($SimpleLevelEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleLevelEventJS_ = $SimpleLevelEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/$Info" {
import {$Param, $Param$Type} from "packages/dev/latvian/mods/kubejs/typings/$Param"
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Info extends $Annotation {

 "value"(): string
 "params"(): ($Param)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Info {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Info$Type = ($Info);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Info_ = $Info$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientActionFilter, $IngredientActionFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientActionFilter"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $IngredientAction extends $IngredientActionFilter {
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor()

public "transform"(arg0: $ItemStack$Type, arg1: integer, arg2: $CraftingContainer$Type): $ItemStack
public "getType"(): string
public static "getRemaining"(container: $CraftingContainer$Type, index: integer, ingredientActions: $List$Type<($IngredientAction$Type)>): $ItemStack
public "toJson"(json: $JsonObject$Type): void
public "toJson"(): $JsonObject
public static "parseList"(json: $JsonElement$Type): $List<($IngredientAction)>
public static "writeList"(buf: $FriendlyByteBuf$Type, list: $List$Type<($IngredientAction$Type)>): void
public static "readList"(buf: $FriendlyByteBuf$Type): $List<($IngredientAction)>
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientAction$Type = ($IngredientAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientAction_ = $IngredientAction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/custom/$SandpaperItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SandpaperItemBuilder extends $ItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SandpaperItemBuilder$Type = ($SandpaperItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SandpaperItemBuilder_ = $SandpaperItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$GameRulesKJS" {
import {$GameRules$Value, $GameRules$Value$Type} from "packages/net/minecraft/world/level/$GameRules$Value"

export interface $GameRulesKJS {

 "kjs$get"(arg0: string): $GameRules$Value<(any)>
 "kjs$getInt"(rule: string): integer
 "kjs$set"(arg0: string, arg1: string): void
 "kjs$getString"(rule: string): string
 "kjs$getBoolean"(rule: string): boolean
}

export namespace $GameRulesKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameRulesKJS$Type = ($GameRulesKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameRulesKJS_ = $GameRulesKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$LongRange" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$NumberComponent$IntRange, $NumberComponent$IntRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$IntRange"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$NumberComponent, $NumberComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NumberComponent$FloatRange, $NumberComponent$FloatRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$FloatRange"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$NumberComponent$DoubleRange, $NumberComponent$DoubleRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$DoubleRange"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NumberComponent$LongRange extends $Record implements $NumberComponent<(long)> {

constructor(min: long, max: long)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): long
public "min"(min: long): $NumberComponent$LongRange
public "max"(): long
public "max"(max: long): $NumberComponent$LongRange
public "write"(recipe: $RecipeJS$Type, value: long): $JsonPrimitive
public "componentClass"(): $Class<(any)>
public "componentType"(): string
public static "doubleRange"(min: double, max: double): $NumberComponent$DoubleRange
public static "floatRange"(min: float, max: float): $NumberComponent$FloatRange
public static "intRange"(min: integer, max: integer): $NumberComponent$IntRange
public static "longRange"(min: long, max: long): $NumberComponent$LongRange
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(long)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(long)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(long), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(long), (O)>
public "asArray"(): $ArrayRecipeComponent<(long)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (long)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(long)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(long)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: long, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: long, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(long)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(long)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (long)>)>
public "checkEmpty"(key: $RecipeKey$Type<(long)>, value: long): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: long, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): long
public "replaceInput"(recipe: $RecipeJS$Type, original: long, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): long
public "checkValueHasChanged"(oldValue: long, newValue: long): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(long)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberComponent$LongRange$Type = ($NumberComponent$LongRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberComponent$LongRange_ = $NumberComponent$LongRange$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Token" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Token {

}

export namespace $Token {
const ERROR: integer
const EOF: integer
const EOL: integer
const FIRST_BYTECODE_TOKEN: integer
const ENTERWITH: integer
const LEAVEWITH: integer
const RETURN: integer
const GOTO: integer
const IFEQ: integer
const IFNE: integer
const SETNAME: integer
const BITOR: integer
const BITXOR: integer
const BITAND: integer
const EQ: integer
const NE: integer
const LT: integer
const LE: integer
const GT: integer
const GE: integer
const LSH: integer
const RSH: integer
const URSH: integer
const ADD: integer
const SUB: integer
const MUL: integer
const DIV: integer
const MOD: integer
const NOT: integer
const BITNOT: integer
const POS: integer
const NEG: integer
const NEW: integer
const DELPROP: integer
const TYPEOF: integer
const GETPROP: integer
const GETPROPNOWARN: integer
const SETPROP: integer
const GETELEM: integer
const SETELEM: integer
const CALL: integer
const NAME: integer
const NUMBER: integer
const STRING: integer
const NULL: integer
const THIS: integer
const FALSE: integer
const TRUE: integer
const SHEQ: integer
const SHNE: integer
const REGEXP: integer
const BINDNAME: integer
const THROW: integer
const RETHROW: integer
const IN: integer
const INSTANCEOF: integer
const LOCAL_LOAD: integer
const GETVAR: integer
const SETVAR: integer
const CATCH_SCOPE: integer
const ENUM_INIT_KEYS: integer
const ENUM_INIT_VALUES: integer
const ENUM_INIT_ARRAY: integer
const ENUM_INIT_VALUES_IN_ORDER: integer
const ENUM_NEXT: integer
const ENUM_ID: integer
const THISFN: integer
const RETURN_RESULT: integer
const ARRAYLIT: integer
const OBJECTLIT: integer
const GET_REF: integer
const SET_REF: integer
const DEL_REF: integer
const REF_CALL: integer
const REF_SPECIAL: integer
const YIELD: integer
const STRICT_SETNAME: integer
const NULLISH_COALESCING: integer
const POW: integer
const OPTIONAL_CHAINING: integer
const GETOPTIONAL: integer
const LAST_BYTECODE_TOKEN: integer
const TRY: integer
const SEMI: integer
const LB: integer
const RB: integer
const LC: integer
const RC: integer
const LP: integer
const RP: integer
const COMMA: integer
const ASSIGN: integer
const ASSIGN_BITOR: integer
const ASSIGN_BITXOR: integer
const ASSIGN_BITAND: integer
const ASSIGN_LSH: integer
const ASSIGN_RSH: integer
const ASSIGN_URSH: integer
const ASSIGN_ADD: integer
const ASSIGN_SUB: integer
const ASSIGN_MUL: integer
const ASSIGN_DIV: integer
const ASSIGN_MOD: integer
const FIRST_ASSIGN: integer
const LAST_ASSIGN: integer
const HOOK: integer
const COLON: integer
const OR: integer
const AND: integer
const INC: integer
const DEC: integer
const DOT: integer
const FUNCTION: integer
const EXPORT: integer
const IMPORT: integer
const IF: integer
const ELSE: integer
const SWITCH: integer
const CASE: integer
const DEFAULT: integer
const WHILE: integer
const DO: integer
const FOR: integer
const BREAK: integer
const CONTINUE: integer
const VAR: integer
const WITH: integer
const CATCH: integer
const FINALLY: integer
const VOID: integer
const RESERVED: integer
const EMPTY: integer
const BLOCK: integer
const LABEL: integer
const TARGET: integer
const LOOP: integer
const EXPR_VOID: integer
const EXPR_RESULT: integer
const JSR: integer
const SCRIPT: integer
const TYPEOFNAME: integer
const USE_STACK: integer
const SETPROP_OP: integer
const SETELEM_OP: integer
const LOCAL_BLOCK: integer
const SET_REF_OP: integer
const TO_OBJECT: integer
const TO_DOUBLE: integer
const GET: integer
const SET: integer
const LET: integer
const CONST: integer
const SETCONST: integer
const SETCONSTVAR: integer
const ARRAYCOMP: integer
const LETEXPR: integer
const WITHEXPR: integer
const COMMENT: integer
const GENEXPR: integer
const METHOD: integer
const ARROW: integer
const YIELD_STAR: integer
const TEMPLATE_LITERAL: integer
const TEMPLATE_CHARS: integer
const TEMPLATE_LITERAL_SUBST: integer
const TAGGED_TEMPLATE_LITERAL: integer
const LAST_TOKEN: integer
function name(token: integer): string
function isValidToken(code: integer): boolean
function typeToName(token: integer): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Token$Type = ($Token);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Token_ = $Token$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$OpResultUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $OpResultUnitToken extends $Record implements $UnitToken {

constructor(operator: $UnitSymbol$Type, left: $UnitToken$Type, right: $UnitToken$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "operator"(): $UnitSymbol
public "left"(): $UnitToken
public "right"(): $UnitToken
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpResultUnitToken$Type = ($OpResultUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpResultUnitToken_ = $OpResultUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ParenthesizedExpression" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ParenthesizedExpression extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, expr: $AstNode$Type)
constructor(expr: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getExpression"(): $AstNode
public "setExpression"(expression: $AstNode$Type): void
get "expression"(): $AstNode
set "expression"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParenthesizedExpression$Type = ($ParenthesizedExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParenthesizedExpression_ = $ParenthesizedExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$DoubleRange" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$NumberComponent$IntRange, $NumberComponent$IntRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$IntRange"
import {$NumberComponent$LongRange, $NumberComponent$LongRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$LongRange"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$NumberComponent, $NumberComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NumberComponent$FloatRange, $NumberComponent$FloatRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$FloatRange"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NumberComponent$DoubleRange extends $Record implements $NumberComponent<(double)> {

constructor(min: double, max: double)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): double
public "min"(min: double): $NumberComponent$DoubleRange
public "max"(): double
public "max"(max: double): $NumberComponent$DoubleRange
public "write"(recipe: $RecipeJS$Type, value: double): $JsonPrimitive
public "componentClass"(): $Class<(any)>
public "componentType"(): string
public static "doubleRange"(min: double, max: double): $NumberComponent$DoubleRange
public static "floatRange"(min: float, max: float): $NumberComponent$FloatRange
public static "intRange"(min: integer, max: integer): $NumberComponent$IntRange
public static "longRange"(min: long, max: long): $NumberComponent$LongRange
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(double)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(double)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(double), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(double), (O)>
public "asArray"(): $ArrayRecipeComponent<(double)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (double)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(double)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(double)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(double)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(double)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(double)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: double, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: double, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(double)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(double)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (double)>)>
public "checkEmpty"(key: $RecipeKey$Type<(double)>, value: double): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: double, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): double
public "replaceInput"(recipe: $RecipeJS$Type, original: double, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): double
public "checkValueHasChanged"(oldValue: double, newValue: double): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(double)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberComponent$DoubleRange$Type = ($NumberComponent$DoubleRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberComponent$DoubleRange_ = $NumberComponent$DoubleRange$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$AbsFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $AbsFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbsFuncUnit$Type = ($AbsFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbsFuncUnit_ = $AbsFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$RemapPrefixForJSRep" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$RemapPrefixForJS, $RemapPrefixForJS$Type} from "packages/dev/latvian/mods/rhino/util/$RemapPrefixForJS"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $RemapPrefixForJSRep extends $Annotation {

 "value"(): ($RemapPrefixForJS)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $RemapPrefixForJSRep {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemapPrefixForJSRep$Type = ($RemapPrefixForJSRep);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemapPrefixForJSRep_ = $RemapPrefixForJSRep$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$JsonIO" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$DataOutputStream, $DataOutputStream$Type} from "packages/java/io/$DataOutputStream"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $JsonIO {

constructor()

public static "toString"(json: $JsonElement$Type): string
public static "toArray"(element: $JsonElement$Type): $JsonArray
public static "of"(o: any): $JsonElement
public static "write"(path: $Path$Type, json: $JsonObject$Type): void
public static "read"(path: $Path$Type): $Map<(any), (any)>
public static "copy"(element: $JsonElement$Type): $JsonElement
public static "parse"(string: string): any
public static "readString"(path: $Path$Type): string
public static "readJson"(path: $Path$Type): $JsonElement
public static "toPrettyString"(json: $JsonElement$Type): string
public static "writeJsonHash"(stream: $DataOutputStream$Type, element: $JsonElement$Type): void
public static "getJsonHashBytes"(json: $JsonElement$Type): (byte)[]
public static "parseRaw"(string: string): $JsonElement
public static "getJsonHashString"(json: $JsonElement$Type): string
public static "primitiveOf"(o: any): $JsonPrimitive
public static "toPrimitive"(element: $JsonElement$Type): any
public static "toObject"(json: $JsonElement$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonIO$Type = ($JsonIO);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonIO_ = $JsonIO$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$KubeJSForgeClient" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSForgeClient {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSForgeClient$Type = ($KubeJSForgeClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSForgeClient_ = $KubeJSForgeClient$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ItemEntityKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EntityKJS, $EntityKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$EntityKJS"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $ItemEntityKJS extends $EntityKJS {

 "getItem"(): $ItemStack
 "setDefaultPickUpDelay"(): void
 "setTicksUntilDespawn"(ticks: integer): void
 "setInfinitePickUpDelay"(): void
 "getTicksUntilDespawn"(): integer
 "setNoPickUpDelay"(): void
 "setNoDespawn"(): void
 "setLifespan"(lifespan: integer): void
 "getLifespan"(): integer
 "getProfile"(): $GameProfile
 "spawn"(): void
 "isPlayer"(): boolean
 "isLiving"(): boolean
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$Type): void
}

export namespace $ItemEntityKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityKJS$Type = ($ItemEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEntityKJS_ = $ItemEntityKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$IngredientMatch" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemMatch, $ItemMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ItemMatch"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemStackSet, $ItemStackSet$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemStackSet"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $IngredientMatch implements $ItemMatch {
readonly "ingredient": $Ingredient
readonly "exact": boolean

constructor(ingredient: $Ingredient$Type, exact: boolean)

public "toString"(): string
public "contains"(item: $ItemStack$Type): boolean
public "contains"(arg0: $Ingredient$Type): boolean
public "getAllItems"(): $ItemStackSet
public "getAllItemArray"(): ($ItemStack)[]
public "contains"(itemLike: $ItemLike$Type): boolean
/**
 * 
 * @deprecated
 */
public "contains"(block: $Block$Type): boolean
public "containsAny"(itemLikes: $Iterable$Type<($ItemLike$Type)>): boolean
public "containsAny"(...itemLikes: ($ItemLike$Type)[]): boolean
public static "of"(o: any): $ReplacementMatch
get "allItems"(): $ItemStackSet
get "allItemArray"(): ($ItemStack)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientMatch$Type = ($IngredientMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientMatch_ = $IngredientMatch$Type;
}}
declare module "packages/dev/latvian/mods/unit/$UnitVariables" {
import {$VariableSet, $VariableSet$Type} from "packages/dev/latvian/mods/unit/$VariableSet"

export interface $UnitVariables {

 "getVariables"(): $VariableSet

(): $VariableSet
}

export namespace $UnitVariables {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitVariables$Type = ($UnitVariables);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitVariables_ = $UnitVariables$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$RemappingHelper" {
import {$RemappingHelper$Callback, $RemappingHelper$Callback$Type} from "packages/dev/latvian/mods/rhino/mod/util/$RemappingHelper$Callback"
import {$MinecraftRemapper, $MinecraftRemapper$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MinecraftRemapper"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $RemappingHelper {
static readonly "GENERATE": boolean
static readonly "LOGGER": $Logger

constructor()

public static "run"(mcVersion: string, callback: $RemappingHelper$Callback$Type): void
public static "getClass"(name: string): $Optional<($Class<(any)>)>
public static "readUtf"(stream: $InputStream$Type): string
public static "getMinecraftRemapper"(debug: boolean): $MinecraftRemapper
public static "getMinecraftRemapper"(): $MinecraftRemapper
public static "createReader"(url: string): $Reader
public static "writeUtf"(stream: $OutputStream$Type, value: string): void
public static "writeVarInt"(stream: $OutputStream$Type, value: integer): void
public static "readVarInt"(stream: $InputStream$Type): integer
get "minecraftRemapper"(): $MinecraftRemapper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappingHelper$Type = ($RemappingHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappingHelper_ = $RemappingHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$CookingRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $CookingRecipeSchema {

}

export namespace $CookingRecipeSchema {
const PLATFORM_OUTPUT_ITEM: $RecipeComponent<($OutputItem)>
const RESULT: $RecipeKey<($OutputItem)>
const INGREDIENT: $RecipeKey<($InputItem)>
const XP: $RecipeKey<(float)>
const COOKING_TIME: $RecipeKey<(long)>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CookingRecipeSchema$Type = ($CookingRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CookingRecipeSchema_ = $CookingRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/properties/$RemoveSpawnsProperties" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"

export class $RemoveSpawnsProperties {
 "biomes": $BiomeFilter
 "mobs": $MobFilter

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveSpawnsProperties$Type = ($RemoveSpawnsProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveSpawnsProperties_ = $RemoveSpawnsProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$RecordItemJS$Builder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecordItemJS$Builder extends $ItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "getSoundEvent"(): $SoundEvent
/**
 * Sets the redstone output of the jukebox when this record is played.
 */
public "analogOutput"(o: integer): $RecordItemJS$Builder
/**
 * Sets the song that will play when this record is played.
 * 
 * @param s - The location of sound event.
 * @param seconds - The length of the song in seconds.
 */
public "song"(s: $ResourceLocation$Type, seconds: integer): $RecordItemJS$Builder
get "soundEvent"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordItemJS$Builder$Type = ($RecordItemJS$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordItemJS$Builder_ = $RecordItemJS$Builder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/json/$JsonParser" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $JsonParser {

constructor(scope: $Scriptable$Type)

public "parseValue"(cx: $Context$Type, json: string): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonParser$Type = ($JsonParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonParser_ = $JsonParser$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$DataObject" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $DataObject {

 "createDataObject"<T>(arg0: $Supplier$Type<(T)>, arg1: $Context$Type): T
 "isDataObjectList"(): boolean
 "createDataObjectList"<T>(arg0: $Supplier$Type<(T)>, arg1: $Context$Type): $List<(T)>
}

export namespace $DataObject {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataObject$Type = ($DataObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataObject_ = $DataObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$HurtEnemyContext" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $ItemBuilder$HurtEnemyContext extends $Record {

constructor(getItem: $ItemStack$Type, getTarget: $LivingEntity$Type, getAttacker: $LivingEntity$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getTarget"(): $LivingEntity
public "getItem"(): $ItemStack
public "getAttacker"(): $LivingEntity
get "target"(): $LivingEntity
get "item"(): $ItemStack
get "attacker"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$HurtEnemyContext$Type = ($ItemBuilder$HurtEnemyContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$HurtEnemyContext_ = $ItemBuilder$HurtEnemyContext$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdEnumeration" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $IdEnumeration implements $Consumer<(any)> {
 "tempResult": any

constructor()

public "getValue"(cx: $Context$Type): any
public "next"(cx: $Context$Type): boolean
public "accept"(o: any): void
public "getId"(cx: $Context$Type): any
public "nextExec"(cx: $Context$Type, scope: $Scriptable$Type): any
public "changeObject"(cx: $Context$Type): void
public "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdEnumeration$Type = ($IdEnumeration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdEnumeration_ = $IdEnumeration$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$ForgeEventConsumer" {
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $ForgeEventConsumer extends $Consumer<($Event)> {

 "accept"(arg0: $Event$Type): void
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<($Event)>

(arg0: $Event$Type): void
}

export namespace $ForgeEventConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEventConsumer$Type = ($ForgeEventConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEventConsumer_ = $ForgeEventConsumer$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$VariableInitializer" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $VariableInitializer extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getTarget"(): $AstNode
public "setTarget"(target: $AstNode$Type): void
public "setInitializer"(initializer: $AstNode$Type): void
public "getInitializer"(): $AstNode
public "setNodeType"(nodeType: integer): void
public "isDestructuring"(): boolean
get "target"(): $AstNode
set "target"(value: $AstNode$Type)
set "initializer"(value: $AstNode$Type)
get "initializer"(): $AstNode
set "nodeType"(value: integer)
get "destructuring"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableInitializer$Type = ($VariableInitializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableInitializer_ = $VariableInitializer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ZipFile, $ZipFile$Type} from "packages/java/util/zip/$ZipFile"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ZipEntry, $ZipEntry$Type} from "packages/java/util/zip/$ZipEntry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedData extends $Record implements $IoSupplier<($InputStream)> {
static readonly "INTERNAL_RELOAD": $GeneratedData
static readonly "PACK_META": $GeneratedData
static readonly "PACK_ICON": $GeneratedData

constructor(id: $ResourceLocation$Type, data: $Lazy$Type<((byte)[])>, alwaysForget: boolean)

public "get"(): $InputStream
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "data"(): $Lazy<((byte)[])>
public "id"(): $ResourceLocation
public "alwaysForget"(): boolean
public static "create"(arg0: $Path$Type): $IoSupplier<($InputStream)>
public static "create"(arg0: $ZipFile$Type, arg1: $ZipEntry$Type): $IoSupplier<($InputStream)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedData$Type = ($GeneratedData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedData_ = $GeneratedData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$ServerScriptManager" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$MultiPackResourceManager, $MultiPackResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$MultiPackResourceManager"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptPack, $ScriptPack$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPack"
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$PreTagEventJS, $PreTagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$PreTagEventJS"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$CloseableResourceManager, $CloseableResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$CloseableResourceManager"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"

export class $ServerScriptManager extends $ScriptManager {
static "instance": $ServerScriptManager
readonly "server": $MinecraftServer
readonly "preTagEvents": $Map<($ResourceKey<(any)>), ($PreTagEventJS)>
readonly "scriptType": $ScriptType
readonly "packs": $Map<(string), ($ScriptPack)>
 "firstLoad": boolean
 "context": $Context
 "topLevelScope": $Scriptable
 "canListenEvents": boolean

constructor(server: $MinecraftServer$Type)

public "updateResources"(serverResources: $ReloadableServerResources$Type, registryAccess: $RegistryAccess$Type): void
public "wrapResourceManager"(original: $CloseableResourceManager$Type): $MultiPackResourceManager
public static "getScriptManager"(): $ScriptManager
get "scriptManager"(): $ScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerScriptManager$Type = ($ServerScriptManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerScriptManager_ = $ServerScriptManager$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$MinecraftEnvironmentKJS" {
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MessageSenderKJS, $MessageSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS"
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$Callback"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export interface $MinecraftEnvironmentKJS extends $MessageSenderKJS {

 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeatingInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component

(): $ScheduledEvents
}

export namespace $MinecraftEnvironmentKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftEnvironmentKJS$Type = ($MinecraftEnvironmentKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftEnvironmentKJS_ = $MinecraftEnvironmentKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeCollectionIterator$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $NativeCollectionIterator$Type extends $Enum<($NativeCollectionIterator$Type)> {
static readonly "KEYS": $NativeCollectionIterator$Type
static readonly "VALUES": $NativeCollectionIterator$Type
static readonly "BOTH": $NativeCollectionIterator$Type


public static "values"(): ($NativeCollectionIterator$Type)[]
public static "valueOf"(name: string): $NativeCollectionIterator$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeCollectionIterator$Type$Type = (("keys") | ("values") | ("both")) | ($NativeCollectionIterator$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeCollectionIterator$Type_ = $NativeCollectionIterator$Type$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$RENode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RENode {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RENode$Type = ($RENode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RENode_ = $RENode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$KubeJSInventoryListener" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$ContainerListener, $ContainerListener$Type} from "packages/net/minecraft/world/inventory/$ContainerListener"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $KubeJSInventoryListener implements $ContainerListener {
readonly "player": $Player

constructor(p: $Player$Type)

public "slotChanged"(container: $AbstractContainerMenu$Type, index: integer, stack: $ItemStack$Type): void
public "dataChanged"(container: $AbstractContainerMenu$Type, id: integer, value: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSInventoryListener$Type = ($KubeJSInventoryListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSInventoryListener_ = $KubeJSInventoryListener$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemEntityInteractedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * Invoked when a player right clicks on an entity.
 */
export class $ItemEntityInteractedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, entity: $Entity$Type, hand: $InteractionHand$Type)

/**
 * The entity that was interacted with.
 */
public "getTarget"(): $Entity
/**
 * The item that was used to interact with the entity.
 */
public "getItem"(): $ItemStack
/**
 * The hand that was used to interact with the entity.
 */
public "getHand"(): $InteractionHand
get "target"(): $Entity
get "item"(): $ItemStack
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEntityInteractedEventJS$Type = ($ItemEntityInteractedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEntityInteractedEventJS_ = $ItemEntityInteractedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$InventoryEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"

/**
 * Invoked when a player opens or closes a container.
 */
export class $InventoryEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, menu: $AbstractContainerMenu$Type)

/**
 * Gets the container that was opened or closed.
 */
public "getInventoryContainer"(): $AbstractContainerMenu
/**
 * Gets the player that opened or closed the container.
 */
public "getEntity"(): $Player
get "inventoryContainer"(): $AbstractContainerMenu
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryEventJS$Type = ($InventoryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryEventJS_ = $InventoryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$CommonProperties" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CommonProperties {
 "hideServerScriptErrors": boolean
 "serverOnly": boolean
 "announceReload": boolean
 "packMode": string
 "saveDevPropertiesInConfig": boolean
 "allowAsyncStreams": boolean
 "matchJsonRecipes": boolean
 "ignoreCustomUniqueRecipeIds": boolean
 "startupErrorGUI": boolean
 "startupErrorReportUrl": string
 "creativeModeTabIcon": string


public "remove"(key: string): void
public "get"(key: string, def: string): string
public "get"(key: string, def: boolean): boolean
public static "get"(): $CommonProperties
public "save"(): void
public static "reload"(): void
public "setPackMode"(s: string): void
set "packMode"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommonProperties$Type = ($CommonProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommonProperties_ = $CommonProperties$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$LetNode" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$VariableDeclaration, $VariableDeclaration$Type} from "packages/dev/latvian/mods/rhino/ast/$VariableDeclaration"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $LetNode extends $Scope {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getBody"(): $AstNode
public "getVariables"(): $VariableDeclaration
public "setParens"(lp: integer, rp: integer): void
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "setVariables"(variables: $VariableDeclaration$Type): void
public "getLp"(): integer
public "getRp"(): integer
public "setBody"(body: $AstNode$Type): void
get "body"(): $AstNode
get "variables"(): $VariableDeclaration
set "lp"(value: integer)
set "rp"(value: integer)
set "variables"(value: $VariableDeclaration$Type)
get "lp"(): integer
get "rp"(): integer
set "body"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LetNode$Type = ($LetNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LetNode_ = $LetNode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment$Factory" {
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"
import {$BlockEntityAttachment, $BlockEntityAttachment$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment"

export interface $BlockEntityAttachment$Factory {

 "create"(arg0: $BlockEntityJS$Type): $BlockEntityAttachment

(arg0: $BlockEntityJS$Type): $BlockEntityAttachment
}

export namespace $BlockEntityAttachment$Factory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$Factory$Type = ($BlockEntityAttachment$Factory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachment$Factory_ = $BlockEntityAttachment$Factory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$KubeJSWorldEventHandler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSWorldEventHandler {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSWorldEventHandler$Type = ($KubeJSWorldEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSWorldEventHandler_ = $KubeJSWorldEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$NameCallback" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ItemBuilder$NameCallback {

 "apply"(arg0: $ItemStack$Type): $Component

(arg0: $ItemStack$Type): $Component
}

export namespace $ItemBuilder$NameCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$NameCallback$Type = ($ItemBuilder$NameCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$NameCallback_ = $ItemBuilder$NameCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeComponent<T> {

 "componentType"(): string
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
 "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
 "write"(arg0: $RecipeJS$Type, arg1: T): $JsonElement
 "key"(name: string): $RecipeKey<(T)>
 "read"(arg0: $RecipeJS$Type, arg1: any): T
 "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
 "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
 "asArray"(): $ArrayRecipeComponent<(T)>
 "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
 "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
 "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
 "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "componentClass"(): $Class<(any)>
 "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
 "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
 "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "orSelf"(): $RecipeComponent<(T)>
 "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
 "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
 "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
 "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
 "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
 "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
 "role"(): $ComponentRole
}

export namespace $RecipeComponent {
function builder(): $RecipeComponentBuilder
function builder(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponent$Type<T> = ($RecipeComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponent_<T> = $RecipeComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Assignment" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$InfixExpression, $InfixExpression$Type} from "packages/dev/latvian/mods/rhino/ast/$InfixExpression"

export class $Assignment extends $InfixExpression {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(operator: integer, left: $AstNode$Type, right: $AstNode$Type, operatorPos: integer)
constructor(left: $AstNode$Type, right: $AstNode$Type)
constructor(pos: integer, len: integer, left: $AstNode$Type, right: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Assignment$Type = ($Assignment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Assignment_ = $Assignment$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$CustomProperty" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"

export interface $CustomProperty {

 "get"(arg0: $Context$Type): any

(arg0: $Context$Type): any
}

export namespace $CustomProperty {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomProperty$Type = ($CustomProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomProperty_ = $CustomProperty$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$MutableToolTier" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $MutableToolTier implements $Tier {
readonly "parent": $Tier

constructor(p: $Tier$Type)

public "setLevel"(i: integer): void
public "setSpeed"(f: float): void
public "getEnchantmentValue"(): integer
public "getSpeed"(): float
public "getUses"(): integer
public "getAttackDamageBonus"(): float
public "getLevel"(): integer
public "getVanillaRepairIngredient"(): $Ingredient
public "setUses"(i: integer): void
public "setRepairIngredient"(arg0: $Ingredient$Type): void
public "setEnchantmentValue"(i: integer): void
public "setAttackDamageBonus"(f: float): void
public "getTag"(): $TagKey<($Block)>
set "level"(value: integer)
set "speed"(value: float)
get "enchantmentValue"(): integer
get "speed"(): float
get "uses"(): integer
get "attackDamageBonus"(): float
get "level"(): integer
get "vanillaRepairIngredient"(): $Ingredient
set "uses"(value: integer)
set "repairIngredient"(value: $Ingredient$Type)
set "enchantmentValue"(value: integer)
set "attackDamageBonus"(value: float)
get "tag"(): $TagKey<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableToolTier$Type = ($MutableToolTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableToolTier_ = $MutableToolTier$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$JEIEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $JEIEvents {

}

export namespace $JEIEvents {
const GROUP: $EventGroup
const SUBTYPES: $EventHandler
const HIDE_ITEMS: $EventHandler
const HIDE_FLUIDS: $EventHandler
const HIDE_CUSTOM: $EventHandler
const REMOVE_CATEGORIES: $EventHandler
const REMOVE_RECIPES: $EventHandler
const ADD_ITEMS: $EventHandler
const ADD_FLUIDS: $EventHandler
const INFORMATION: $EventHandler
function register(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEIEvents$Type = ($JEIEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEIEvents_ = $JEIEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$EnumComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnumComponent<T extends $Enum<(T)>> extends $Record implements $RecipeComponent<(T)> {
static readonly "DYNAMIC": $DynamicRecipeComponent

constructor(enumType: $Class$Type<(T)>)
constructor(enumType: $Class$Type<(T)>, toStringFunc: $Function$Type<(T), (string)>, toEnumFunc: $BiFunction$Type<($Class$Type<(T)>), (string), (T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: T): $JsonPrimitive
public "enumType"(): $Class<(T)>
public "componentClass"(): $Class<(any)>
public "toStringFunc"(): $Function<(T), (string)>
public "toEnumFunc"(): $BiFunction<($Class<(T)>), (string), (T)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(T)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
public "asArray"(): $ArrayRecipeComponent<(T)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(T)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
public "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
public "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumComponent$Type<T> = ($EnumComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumComponent_<T> = $EnumComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers" {
import {$TypeWrapperFactory$Simple, $TypeWrapperFactory$Simple$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory$Simple"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"

export class $TypeWrappers {

constructor()

public "register"<T>(target: $Class$Type<(T)>, factory: $TypeWrapperFactory$Type<(T)>): void
public "register"<T>(target: $Class$Type<(T)>, validator: $Predicate$Type<(any)>, factory: $TypeWrapperFactory$Type<(T)>): void
public "getWrapperFactory"(target: $Class$Type<(any)>, from: any): $TypeWrapperFactory<(any)>
public "registerSimple"<T>(target: $Class$Type<(T)>, factory: $TypeWrapperFactory$Simple$Type<(T)>): void
public "registerSimple"<T>(target: $Class$Type<(T)>, validator: $Predicate$Type<(any)>, factory: $TypeWrapperFactory$Simple$Type<(T)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrappers$Type = ($TypeWrappers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrappers_ = $TypeWrappers$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FuncUnit" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $FuncUnit extends $Unit {
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(factory: $FunctionFactory$Type)

public "toString"(builder: $StringBuilder$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FuncUnit$Type = ($FuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FuncUnit_ = $FuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptTypeHolder" {
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypeHolder {

 "kjs$getScriptType"(): $ScriptType

(): $ScriptType
}

export namespace $ScriptTypeHolder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypeHolder$Type = ($ScriptTypeHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptTypeHolder_ = $ScriptTypeHolder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$KubeJSCreatePlugin" {
import {$KubeJSPlugin, $KubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSPlugin"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"
import {$RegisterRecipeSchemasEvent, $RegisterRecipeSchemasEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RegisterRecipeSchemasEvent"

export class $KubeJSCreatePlugin extends $KubeJSPlugin {

constructor()

public "init"(): void
public "afterInit"(): void
public "registerEvents"(): void
public "registerTypeWrappers"(type: $ScriptType$Type, typeWrappers: $TypeWrappers$Type): void
public "registerRecipeSchemas"(event: $RegisterRecipeSchemasEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCreatePlugin$Type = ($KubeJSCreatePlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCreatePlugin_ = $KubeJSCreatePlugin$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ES6Iterator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $ES6Iterator extends $IdScriptableObject {
static readonly "NEXT_METHOD": string
static readonly "DONE_PROPERTY": string
static readonly "RETURN_PROPERTY": string
static readonly "VALUE_PROPERTY": string
static readonly "RETURN_METHOD": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ES6Iterator$Type = ($ES6Iterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ES6Iterator_ = $ES6Iterator$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$DestructuringForm" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $DestructuringForm {

 "setIsDestructuring"(arg0: boolean): void
 "isDestructuring"(): boolean
}

export namespace $DestructuringForm {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DestructuringForm$Type = ($DestructuringForm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DestructuringForm_ = $DestructuringForm$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeMap" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeMap extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type)

public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeMap$Type = ($NativeMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeMap_ = $NativeMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddOreProperties" {
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$VerticalAnchor, $VerticalAnchor$Type} from "packages/net/minecraft/world/level/levelgen/$VerticalAnchor"
import {$HeightRangePlacement, $HeightRangePlacement$Type} from "packages/net/minecraft/world/level/levelgen/placement/$HeightRangePlacement"

export class $AddOreProperties {
 "id": $ResourceLocation
 "worldgenLayer": $GenerationStep$Decoration
 "biomes": $BiomeFilter
 "targets": $List<($OreConfiguration$TargetBlockState)>
 "size": integer
 "noSurface": float
 "count": $IntProvider
 "chance": integer
 "squared": boolean
 "height": $HeightRangePlacement
 "retrogen": integer

constructor()

public "size"(s: integer): $AddOreProperties
public "count"(min: integer, max: integer): $AddOreProperties
public "count"(c: $IntProvider$Type): $AddOreProperties
public "count"(c: integer): $AddOreProperties
/**
 * 
 * @deprecated
 */
public "top"(): $VerticalAnchor
/**
 * 
 * @deprecated
 */
public "bottom"(): $VerticalAnchor
public "addTarget"(ruleTest: $RuleTest$Type, targetState: $BlockStatePredicate$Type): void
public "chance"(c: integer): $AddOreProperties
public "triangleHeight"(min: integer, max: integer): $AddOreProperties
public "triangleHeight"(absolute: $VerticalAnchor$Type, absolute1: $VerticalAnchor$Type): $AddOreProperties
public "uniformHeight"(absolute: $VerticalAnchor$Type, absolute1: $VerticalAnchor$Type): $AddOreProperties
public "uniformHeight"(min: integer, max: integer): $AddOreProperties
/**
 * 
 * @deprecated
 */
public "aboveBottom"(y: integer): $VerticalAnchor
public "squared"(): $AddOreProperties
/**
 * 
 * @deprecated
 */
public "belowTop"(y: integer): $VerticalAnchor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddOreProperties$Type = ($AddOreProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddOreProperties_ = $AddOreProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptManager" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$NativeJavaClass, $NativeJavaClass$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaClass"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptPack, $ScriptPack$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPack"
import {$ClassShutter, $ClassShutter$Type} from "packages/dev/latvian/mods/rhino/$ClassShutter"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$CallbackInfoReturnable, $CallbackInfoReturnable$Type} from "packages/org/spongepowered/asm/mixin/injection/callback/$CallbackInfoReturnable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptManager implements $ClassShutter {
readonly "scriptType": $ScriptType
readonly "packs": $Map<(string), ($ScriptPack)>
 "firstLoad": boolean
 "context": $Context
 "topLevelScope": $Scriptable
 "canListenEvents": boolean

constructor(t: $ScriptType$Type)

public "load"(): void
public "unload"(): void
public "reload"(resourceManager: $ResourceManager$Type): void
public "loadFromDirectory"(): void
public static "getCurrentContext"(): $Context
public "isClassAllowed"(name: string): boolean
public "loadJavaClass"(name: string, error: boolean): $NativeJavaClass
public "visibleToScripts"(fullClassName: string, type: integer): boolean
public "handler$bll000$loadJavaClass"(name0: string, warn: boolean, cir: $CallbackInfoReturnable$Type<(any)>): void
get "currentContext"(): $Context
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptManager$Type = ($ScriptManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptManager_ = $ScriptManager$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeMath" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeMath extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeMath$Type = ($NativeMath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeMath_ = $NativeMath$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$HashSlotMap" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ScriptableObject$Slot, $ScriptableObject$Slot$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$Slot"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SlotMap, $SlotMap$Type} from "packages/dev/latvian/mods/rhino/$SlotMap"
import {$ScriptableObject$SlotAccess, $ScriptableObject$SlotAccess$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$SlotAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $HashSlotMap implements $SlotMap {

constructor()

public "remove"(key: any, index: integer, cx: $Context$Type): void
public "get"(key: any, index: integer, accessType: $ScriptableObject$SlotAccess$Type): $ScriptableObject$Slot
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $Iterator<($ScriptableObject$Slot)>
public "query"(key: any, index: integer): $ScriptableObject$Slot
public "addSlot"(newSlot: $ScriptableObject$Slot$Type): void
public "spliterator"(): $Spliterator<($ScriptableObject$Slot)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ScriptableObject$Slot>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HashSlotMap$Type = ($HashSlotMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HashSlotMap_ = $HashSlotMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$KeepAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $KeepAction extends $IngredientAction {
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor()

public "transform"(old: $ItemStack$Type, index: integer, container: $CraftingContainer$Type): $ItemStack
public "getType"(): string
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeepAction$Type = ($KeepAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeepAction_ = $KeepAction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$UtilsJS" {
import {$UtilsJS$TryIO, $UtilsJS$TryIO$Type} from "packages/dev/latvian/mods/kubejs/util/$UtilsJS$TryIO"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$File, $File$Type} from "packages/java/io/$File"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$MobType, $MobType$Type} from "packages/net/minecraft/world/entity/$MobType"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Calendar, $Calendar$Type} from "packages/java/util/$Calendar"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$JSObjectType, $JSObjectType$Type} from "packages/dev/latvian/mods/kubejs/util/$JSObjectType"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Type, $Type$Type} from "packages/java/lang/reflect/$Type"
import {$EntitySelector, $EntitySelector$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelector"

export class $UtilsJS {
static readonly "RANDOM": $Random
static readonly "REGEX_PATTERN": $Pattern
static readonly "AIR_LOCATION": $ResourceLocation
static readonly "SNAKE_CASE_SPLIT": $Pattern
static readonly "ALWAYS_LOWER_CASE": $Set<(string)>
static readonly "EMPTY_OBJECT_ARRAY": (any)[]
static readonly "EMPTY_STRING_ARRAY": (string)[]
static "staticServer": $MinecraftServer
static "staticRegistryAccess": $RegistryAccess
static readonly "UNKNOWN_ID": $ResourceLocation
static readonly "ALWAYS_TRUE": $Predicate<(any)>
static readonly "TEMPORAL_AMOUNT_PATTERN": $Pattern

constructor()

public static "cast"<T>(o: any): T
public static "wrap"(o: any, type: $JSObjectType$Type): any
public static "regex"(string: string): $Pattern
public static "copy"(o: any): any
public static "getPath"(s: string): string
public static "getPath"(o: any): $Path
public static "getRawType"(type: $Type$Type): $Class<(any)>
public static "toTitleCase"(s: string, ignoreSpecial: boolean): string
public static "toTitleCase"(s: string): string
public static "parseInt"(object: any, def: integer): integer
public static "parseDouble"(object: any, def: double): double
public static "parseLong"(object: any, def: long): long
public static "getID"(s: string): string
public static "getDuration"(o: any): $Duration
public static "getUniqueId"<T>(input: T, codec: $Codec$Type<(T)>): string
public static "getUniqueId"(json: $JsonElement$Type): string
public static "appendTimestamp"(builder: $StringBuilder$Type, calendar: $Calendar$Type): void
public static "getNamespace"(s: string): string
public static "toRegexString"(pattern: $Pattern$Type): string
public static "onMatchDo"<T>(predicate: $Predicate$Type<(T)>, onMatch: $Consumer$Type<(T)>): $Predicate<(T)>
public static "rollChestLoot"(id: $ResourceLocation$Type, entity: $Entity$Type): $List<($ItemStack)>
public static "queueIO"(runnable: $Runnable$Type): void
public static "tryIO"(tryIO: $UtilsJS$TryIO$Type): void
public static "parseBlockState"(string: string): $BlockState
public static "numberProviderJson"(gen: $NumberProvider$Type): $JsonElement
public static "makeFunctionProxy"<T>(type: $ScriptType$Type, targetClass: $Class$Type<(T)>, arg2: $BaseFunction$Type): T
public static "stripEventName"(s: string): string
public static "stripIdForEvent"(id: $ResourceLocation$Type): string
public static "getTickDuration"(o: any): long
public static "toMappedTypeString"(type: $Type$Type): string
public static "getAllBlockStates"(): $Collection<($BlockState)>
public static "findCreativeTab"(id: $ResourceLocation$Type): $CreativeModeTab
public static "getMobTypeId"(type: $MobType$Type): string
public static "writeColor"(buf: $FriendlyByteBuf$Type, color: $Color$Type): void
public static "readColor"(buf: $FriendlyByteBuf$Type): $Color
public static "mobCategoryByName"(s: string): $MobCategory
public static "getMCID"(cx: $Context$Type, o: any): $ResourceLocation
public static "parseRegex"(o: any): $Pattern
public static "getFileFromPath"(o: any): $File
public static "blockPosOf"(o: any): $BlockPos
public static "intProviderOf"(o: any): $IntProvider
public static "numberProviderOf"(o: any): $NumberProvider
public static "getTemporalAmount"(o: any): $TemporalAmount
public static "vec3Of"(o: any): $Vec3
public static "entitySelector"(o: any): $EntitySelector
public static "postModificationEvents"(): void
public static "snakeCaseToCamelCase"(string: string): string
public static "snakeCaseToTitleCase"(string: string): string
get "allBlockStates"(): $Collection<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsJS$Type = ($UtilsJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UtilsJS_ = $UtilsJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$OutputItem" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer$Replacement, $OutputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement"
import {$IntProvider, $IntProvider$Type} from "packages/net/minecraft/util/valueproviders/$IntProvider"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $OutputItem implements $OutputReplacement {
static readonly "EMPTY": $OutputItem
readonly "item": $ItemStack
readonly "chance": double
readonly "rolls": $IntProvider


public "toString"(): string
public "isEmpty"(): boolean
public static "of"(item: $ItemStack$Type, chance: double): $OutputItem
public static "of"(from: $OutputItem$Type): $OutputItem
public "getCount"(): integer
public "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
public "withCount"(count: integer): $OutputItem
public "withRolls"(rolls: $IntProvider$Type): $OutputItem
public "withRolls"(min: integer, max: integer): $OutputItem
public "hasChance"(): boolean
public "withChance"(chance: double): $OutputItem
/**
 * 
 * @deprecated
 */
public "ignoreNBT"(): $InputItem
public "getNbt"(): $CompoundTag
public "strongNBT"(): $InputItem
public "weakNBT"(): $InputItem
public "getChance"(): double
public "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement
get "empty"(): boolean
get "count"(): integer
get "nbt"(): $CompoundTag
get "chance"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputItem$Type = ($ItemStack$Type) | ({"item": Special.Item, "chance": double}) | ({"item": Special.Item, "maxRolls": integer, "minRolls": integer}) | ($OutputItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputItem_ = $OutputItem$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$PlayerKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"
import {$WithAttachedData, $WithAttachedData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithAttachedData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$DataSenderKJS, $DataSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$DataSenderKJS"
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NotificationBuilder, $NotificationBuilder$Type} from "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityPotionEffectsJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntityKJS, $LivingEntityKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$LivingEntityKJS"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$Type} from "packages/dev/latvian/mods/kubejs/player/$KubeJSInventoryListener"
import {$PlayerStatsJS, $PlayerStatsJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerStatsJS"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"

export interface $PlayerKJS extends $LivingEntityKJS, $DataSenderKJS, $WithAttachedData<($Player)> {

 "getInventory"(): $InventoryKJS
 "getStages"(): $Stages
 "isFake"(): boolean
 "getProfile"(): $GameProfile
 "give"(item: $ItemStack$Type): void
 "setMouseItem"(item: $ItemStack$Type): void
 "isMiningBlock"(): boolean
 "getMouseItem"(): $ItemStack
 "spawn"(): void
 "getStats"(): $PlayerStatsJS
 "addFood"(f: integer, m: float): void
 "giveInHand"(item: $ItemStack$Type): void
 "paint"(renderer: $CompoundTag$Type): void
 "getFoodLevel"(): integer
 "isPlayer"(): boolean
 "notify"(builder: $NotificationBuilder$Type): void
 "notify"(title: $Component$Type, text: $Component$Type): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "getSaturation"(): float
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "getXp"(): integer
 "setSaturation"(saturation: float): void
 "setXp"(xp: integer): void
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setStatusMessage"(message: $Component$Type): void
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "sendInventoryUpdate"(): void
 "getSelectedSlot"(): integer
 "setSelectedSlot"(index: integer): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$Type, ticks: integer): void
 "foodEaten"(is: $ItemStack$Type): void
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "isLiving"(): boolean
 "getEquipment"(slot: $EquipmentSlot$Type): $ItemStack
 "setEquipment"(slot: $EquipmentSlot$Type, item: $ItemStack$Type): void
 "swing"(): void
 "swing"(hand: $InteractionHand$Type): void
 "setOffHandItem"(item: $ItemStack$Type): void
 "getOffHandItem"(): $ItemStack
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(hand: $InteractionHand$Type, item: $ItemStack$Type): void
 "getHeldItem"(hand: $InteractionHand$Type): $ItemStack
 "rayTrace"(): $RayTraceResultJS
 "getHeadArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getDefaultMovementSpeed"(): double
 "getReachDistance"(): double
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setMovementSpeedAddition"(speed: double): void
 "isHoldingInAnyHand"(i: $Ingredient$Type): boolean
 "setLegsArmorItem"(item: $ItemStack$Type): void
 "setFeetArmorItem"(item: $ItemStack$Type): void
 "setHeadArmorItem"(item: $ItemStack$Type): void
 "getMainHandItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "removeAttribute"(attribute: $Attribute$Type, identifier: string): void
 "setDefaultMovementSpeed"(speed: double): void
 "damageEquipment"(slot: $EquipmentSlot$Type): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "getAttributeBaseValue"(attribute: $Attribute$Type): double
 "setChestArmorItem"(item: $ItemStack$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getAttributeTotalValue"(attribute: $Attribute$Type): double
 "modifyAttribute"(attribute: $Attribute$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): void
 "setMainHandItem"(item: $ItemStack$Type): void
 "getChestArmorItem"(): $ItemStack
 "canEntityBeSeen"(entity: $LivingEntity$Type): boolean
 "setAttributeBaseValue"(attribute: $Attribute$Type, value: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: string, data: $CompoundTag$Type): void
 "sendData"(channel: string): void
 "getData"(): $AttachedData<($Player)>
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getItem"(): $ItemStack
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag

(): $InventoryKJS
}

export namespace $PlayerKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerKJS$Type = ($PlayerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerKJS_ = $PlayerKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityCallback" {
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"

export interface $BlockEntityCallback {

 "accept"(arg0: $BlockEntityJS$Type): void

(arg0: $BlockEntityJS$Type): void
}

export namespace $BlockEntityCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityCallback$Type = ($BlockEntityCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityCallback_ = $BlockEntityCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$PainterObject" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$SpecialEquality, $SpecialEquality$Type} from "packages/dev/latvian/mods/rhino/util/$SpecialEquality"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $PainterObject implements $SpecialEquality {
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor()

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "update"(tag: $CompoundTag$Type): void
public "id"(i: string): $PainterObject
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PainterObject$Type = ($PainterObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PainterObject_ = $PainterObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$SlabBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $SlabBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlabBlockBuilder$Type = ($SlabBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlabBlockBuilder_ = $SlabBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ClassWrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $ClassWrapper<T> extends $Record implements $CustomJavaToJsWrapper {

constructor(wrappedClass: $Class$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "convertJavaToJs"(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>): $Scriptable
public "wrappedClass"(): $Class<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWrapper$Type<T> = ($ClassWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassWrapper_<T> = $ClassWrapper$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$ParticleTypeBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ParticleTypeBuilder extends $BuilderBase<($ParticleType<(any)>)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "deserializer"(d: $ParticleOptions$Deserializer$Type<(any)>): $ParticleTypeBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
public "overrideLimiter"(o: boolean): $ParticleTypeBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParticleTypeBuilder$Type = ($ParticleTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParticleTypeBuilder_ = $ParticleTypeBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$KubeJSCreate" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSCreate {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCreate$Type = ($KubeJSCreate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCreate_ = $KubeJSCreate$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Evaluator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Script, $Script$Type} from "packages/dev/latvian/mods/rhino/$Script"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export interface $Evaluator {

 "compile"(arg0: $CompilerEnvirons$Type, arg1: $ScriptNode$Type, arg2: boolean, arg3: $Context$Type): any
 "createFunctionObject"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: any, arg3: any): $Function
 "getScriptStack"(arg0: $RhinoException$Type): $List<(string)>
 "captureStackInfo"(arg0: $Context$Type, arg1: $RhinoException$Type): void
 "getPatchedStack"(arg0: $RhinoException$Type, arg1: string): string
 "getSourcePositionFromStack"(arg0: $Context$Type, arg1: (integer)[]): string
 "createScriptObject"(arg0: any, arg1: any): $Script
 "setEvalScriptFlag"(arg0: $Script$Type): void
}

export namespace $Evaluator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Evaluator$Type = ($Evaluator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Evaluator_ = $Evaluator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$BlockLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "build"(blocks: $BlockStatePredicate$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
public "modifyBlock"(blocks: $BlockStatePredicate$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
public "addBlock"(blocks: $BlockStatePredicate$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
public "getDirectory"(): string
public "addSimpleBlock"(blocks: $BlockStatePredicate$Type, item: $ItemStack$Type): void
public "addSimpleBlock"(blocks: $BlockStatePredicate$Type): void
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLootEventJS$Type = ($BlockLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLootEventJS_ = $BlockLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$GeneratedServerResourcePack" {
import {$GeneratedResourcePack, $GeneratedResourcePack$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedResourcePack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GeneratedServerResourcePack extends $GeneratedResourcePack {

constructor()

public "generate"(map: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedServerResourcePack$Type = ($GeneratedServerResourcePack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedServerResourcePack_ = $GeneratedServerResourcePack$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$FloatRange" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$NumberComponent$IntRange, $NumberComponent$IntRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$IntRange"
import {$NumberComponent$LongRange, $NumberComponent$LongRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$LongRange"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$NumberComponent, $NumberComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$NumberComponent$DoubleRange, $NumberComponent$DoubleRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$DoubleRange"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NumberComponent$FloatRange extends $Record implements $NumberComponent<(float)> {

constructor(min: float, max: float)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): float
public "min"(min: float): $NumberComponent$FloatRange
public "max"(): float
public "max"(max: float): $NumberComponent$FloatRange
public "write"(recipe: $RecipeJS$Type, value: float): $JsonPrimitive
public "componentClass"(): $Class<(any)>
public "componentType"(): string
public static "doubleRange"(min: double, max: double): $NumberComponent$DoubleRange
public static "floatRange"(min: float, max: float): $NumberComponent$FloatRange
public static "intRange"(min: integer, max: integer): $NumberComponent$IntRange
public static "longRange"(min: long, max: long): $NumberComponent$LongRange
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(float)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(float)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(float), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(float), (O)>
public "asArray"(): $ArrayRecipeComponent<(float)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (float)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(float)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(float)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(float)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(float)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(float)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: float, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: float, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(float)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(float)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (float)>)>
public "checkEmpty"(key: $RecipeKey$Type<(float)>, value: float): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: float, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): float
public "replaceInput"(recipe: $RecipeJS$Type, original: float, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): float
public "checkValueHasChanged"(oldValue: float, newValue: float): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(float)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberComponent$FloatRange$Type = ($NumberComponent$FloatRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberComponent$FloatRange_ = $NumberComponent$FloatRange$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$LtOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $LtOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LtOpUnit$Type = ($LtOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LtOpUnit_ = $LtOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$TypeFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TypeFilter implements $RecipeFilter {

constructor(t: $ResourceLocation$Type)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeFilter$Type = ($TypeFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeFilter_ = $TypeFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/wrapper/$AABBWrapper" {
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export interface $AABBWrapper {

}

export namespace $AABBWrapper {
const EMPTY: $AABB
const CUBE: $AABB
function wrap(o: any): $AABB
function of(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): $AABB
function ofBlocks(pos1: $BlockPos$Type, pos2: $BlockPos$Type): $AABB
function ofBlock(pos: $BlockPos$Type): $AABB
function ofSize(vec3: $Vec3$Type, x: double, y: double, z: double): $AABB
function ofSize(x: double, y: double, z: double): $AABB
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AABBWrapper$Type = ($AABBWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AABBWrapper_ = $AABBWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/$Generics" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Generics extends $Annotation {

 "base"(): $Class<(any)>
 "value"(): ($Class<(any)>)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Generics {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Generics$Type = ($Generics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Generics_ = $Generics$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$EcmaError" {
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export class $EcmaError extends $RhinoException {


public "getName"(): string
public "getErrorMessage"(): string
public "details"(): string
get "name"(): string
get "errorMessage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EcmaError$Type = ($EcmaError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EcmaError_ = $EcmaError$Type;
}}
declare module "packages/dev/latvian/mods/unit/$VariableUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $VariableUnit extends $Unit {
readonly "name": string
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public static "of"(name: string): $VariableUnit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableUnit$Type = ($VariableUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableUnit_ = $VariableUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$SymbolKey" {
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $SymbolKey implements $Symbol {
static readonly "ITERATOR": $SymbolKey
static readonly "TO_STRING_TAG": $SymbolKey
static readonly "SPECIES": $SymbolKey
static readonly "HAS_INSTANCE": $SymbolKey
static readonly "IS_CONCAT_SPREADABLE": $SymbolKey
static readonly "IS_REGEXP": $SymbolKey
static readonly "TO_PRIMITIVE": $SymbolKey
static readonly "MATCH": $SymbolKey
static readonly "REPLACE": $SymbolKey
static readonly "SEARCH": $SymbolKey
static readonly "SPLIT": $SymbolKey
static readonly "UNSCOPABLES": $SymbolKey

constructor(name: string)

public "getName"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymbolKey$Type = ($SymbolKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SymbolKey_ = $SymbolKey$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$NBTIOWrapper" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"

export interface $NBTIOWrapper {

}

export namespace $NBTIOWrapper {
function write(path: $Path$Type, nbt: $CompoundTag$Type): void
function read(path: $Path$Type): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTIOWrapper$Type = ($NBTIOWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTIOWrapper_ = $NBTIOWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$ForgeEventWrapper" {
import {$IEventBus, $IEventBus$Type} from "packages/net/minecraftforge/eventbus/api/$IEventBus"
import {$GenericForgeEventConsumer, $GenericForgeEventConsumer$Type} from "packages/dev/latvian/mods/kubejs/forge/$GenericForgeEventConsumer"
import {$ForgeEventConsumer, $ForgeEventConsumer$Type} from "packages/dev/latvian/mods/kubejs/forge/$ForgeEventConsumer"
import {$Event, $Event$Type} from "packages/net/minecraftforge/eventbus/api/$Event"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$GenericEvent, $GenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$GenericEvent"

export class $ForgeEventWrapper extends $Record {

constructor(name: string, eventBus: $IEventBus$Type)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "onEvent"<T extends typeof $Event<(unknown)>>(eventClass: T, consumer: (event: InstanceType<(T)>) => void): any
public "eventBus"(): $IEventBus
public "onGenericEvent"<T extends typeof $GenericEvent<(unknown)>>(eventClass: T, genericClass: any, consumer: (event: InstanceType<(T)>) => void): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeEventWrapper$Type = ($ForgeEventWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeEventWrapper_ = $ForgeEventWrapper$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$MaxFuncUnit" {
import {$Func2Unit, $Func2Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func2Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MaxFuncUnit extends $Func2Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MaxFuncUnit$Type = ($MaxFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MaxFuncUnit_ = $MaxFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$RoundedTimeUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $RoundedTimeUnit extends $FuncUnit {
static readonly "FACTORY": $FunctionFactory
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public static "time"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RoundedTimeUnit$Type = ($RoundedTimeUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RoundedTimeUnit_ = $RoundedTimeUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentBuilderMap, $RecipeComponentBuilderMap$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilderMap"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeComponentBuilder implements $RecipeComponent<($RecipeComponentBuilderMap)> {
readonly "keys": $List<($RecipeKey<(any)>)>
 "hasPriority": $Predicate<($Set<(string)>)>
 "role": $ComponentRole

constructor(init: integer)

public "add"(key: $RecipeKey$Type<(any)>): $RecipeComponentBuilder
public "toString"(): string
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: $RecipeComponentBuilderMap$Type): $JsonElement
public "read"(recipe: $RecipeJS$Type, from: any): $RecipeComponentBuilderMap
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: $RecipeComponentBuilderMap$Type, match: $ReplacementMatch$Type): boolean
public "hasPriority"(hasPriority: $Predicate$Type<($Set$Type<(string)>)>): $RecipeComponentBuilder
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $RecipeComponentBuilderMap$Type, match: $ReplacementMatch$Type): boolean
public "createCopy"(): $RecipeComponentBuilder
public "replaceOutput"(recipe: $RecipeJS$Type, original: $RecipeComponentBuilderMap$Type, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $RecipeComponentBuilderMap
public "replaceInput"(recipe: $RecipeJS$Type, original: $RecipeComponentBuilderMap$Type, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $RecipeComponentBuilderMap
public "inputRole"(): $RecipeComponentBuilder
public "outputRole"(): $RecipeComponentBuilder
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: $RecipeComponentBuilderMap$Type, newValue: $RecipeComponentBuilderMap$Type): boolean
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($RecipeComponentBuilderMap)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($RecipeComponentBuilderMap)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($RecipeComponentBuilderMap), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($RecipeComponentBuilderMap), (O)>
public "asArray"(): $ArrayRecipeComponent<($RecipeComponentBuilderMap)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($RecipeComponentBuilderMap)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($RecipeComponentBuilderMap)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($RecipeComponentBuilderMap)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeComponentBuilderMap$Type)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeComponentBuilderMap$Type)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeComponentBuilderMap$Type)>, map: $Map$Type<(any), (any)>): void
public "orSelf"(): $RecipeComponent<($RecipeComponentBuilderMap)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($RecipeComponentBuilderMap)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($RecipeComponentBuilderMap)>)>
public "checkEmpty"(key: $RecipeKey$Type<($RecipeComponentBuilderMap$Type)>, value: $RecipeComponentBuilderMap$Type): string
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($RecipeComponentBuilderMap)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilder$Type = ($RecipeComponentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentBuilder_ = $RecipeComponentBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder$ShapeBuilder" {
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$List, $List$Type} from "packages/java/util/$List"

export class $CropBlockBuilder$ShapeBuilder {

constructor(age: integer)

/**
 * Describe the shape of the crop at a specific age.
 * 
 * min/max coordinates are double values between 0 and 16.
 */
public "shape"(age: integer, minX: double, minY: double, minZ: double, maxX: double, maxY: double, maxZ: double): $CropBlockBuilder$ShapeBuilder
public "getShapes"(): $List<($VoxelShape)>
get "shapes"(): $List<($VoxelShape)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$ShapeBuilder$Type = ($CropBlockBuilder$ShapeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder$ShapeBuilder_ = $CropBlockBuilder$ShapeBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$AdvancementJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

export class $AdvancementJS {
readonly "advancement": $Advancement

constructor(a: $Advancement$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "id"(): $ResourceLocation
public "getParent"(): $AdvancementJS
public "getId"(): $ResourceLocation
public "getChildren"(): $Set<($AdvancementJS)>
public "getDescription"(): $Component
public "hasDisplay"(): boolean
public "addChild"(a: $AdvancementJS$Type): void
public "getTitle"(): $Component
public "getDisplayText"(): $Component
get "parent"(): $AdvancementJS
get "children"(): $Set<($AdvancementJS)>
get "description"(): $Component
get "title"(): $Component
get "displayText"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdvancementJS$Type = ($AdvancementJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdvancementJS_ = $AdvancementJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$KubeJSCommon" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ConsoleLine, $ConsoleLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ExportablePackResources, $ExportablePackResources$Type} from "packages/dev/latvian/mods/kubejs/script/data/$ExportablePackResources"

export class $KubeJSCommon {

constructor()

public "init"(): void
public "export"(packs: $List$Type<($ExportablePackResources$Type)>): void
public "reloadConfig"(): void
public "reloadLang"(): void
public "generateTypings"(source: $CommandSourceStack$Type): void
public "openErrors"(type: $ScriptType$Type, errors: $List$Type<($ConsoleLine$Type)>, warnings: $List$Type<($ConsoleLine$Type)>): void
public "openErrors"(type: $ScriptType$Type): void
public "reloadTextures"(): void
public "clientSetup"(): void
public "getClientPlayer"(): $Player
public "reloadStartupScripts"(dedicated: boolean): void
public "handleDataFromServerPacket"(channel: string, data: $CompoundTag$Type): void
public "reloadClientInternal"(): void
public "paint"(tag: $CompoundTag$Type): void
get "clientPlayer"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCommon$Type = ($KubeJSCommon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCommon_ = $KubeJSCommon$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$PropertyGet" {
import {$Name, $Name$Type} from "packages/dev/latvian/mods/rhino/ast/$Name"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$InfixExpression, $InfixExpression$Type} from "packages/dev/latvian/mods/rhino/ast/$InfixExpression"

export class $PropertyGet extends $InfixExpression {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(target: $AstNode$Type, property: $Name$Type, dotPosition: integer)

public "getProperty"(): $Name
public "setProperty"(property: $Name$Type): void
public "getTarget"(): $AstNode
public "setTarget"(target: $AstNode$Type): void
get "property"(): $Name
set "property"(value: $Name$Type)
get "target"(): $AstNode
set "target"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertyGet$Type = ($PropertyGet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertyGet_ = $PropertyGet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/$InventoryKJSSlot" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $InventoryKJSSlot extends $Slot {
readonly "inventory": $InventoryKJS
readonly "invIndex": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(inventory: $InventoryKJS$Type, invIndex: integer, xPosition: integer, yPosition: integer)

public "remove"(amount: integer): $ItemStack
public "getItem"(): $ItemStack
public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "mayPlace"(stack: $ItemStack$Type): boolean
public "mayPickup"(playerIn: $Player$Type): boolean
public "onQuickCraft"(oldStackIn: $ItemStack$Type, newStackIn: $ItemStack$Type): void
public "setChanged"(): void
public "set"(stack: $ItemStack$Type): void
public "getMaxStackSize"(): integer
get "item"(): $ItemStack
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJSSlot$Type = ($InventoryKJSSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryKJSSlot_ = $InventoryKJSSlot$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$RhinoException" {
import {$ScriptStackElement, $ScriptStackElement$Type} from "packages/dev/latvian/mods/rhino/$ScriptStackElement"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$PrintWriter, $PrintWriter$Type} from "packages/java/io/$PrintWriter"
import {$PrintStream, $PrintStream$Type} from "packages/java/io/$PrintStream"

export class $RhinoException extends $RuntimeException {


public "printStackTrace"(s: $PrintWriter$Type): void
public "printStackTrace"(s: $PrintStream$Type): void
public "lineNumber"(): integer
public "getMessage"(): string
public "getScriptStackTrace"(limit: integer, functionName: string): string
public "getScriptStackTrace"(): string
public "lineSource"(): string
public "getScriptStack"(limit: integer, hideFunction: string): ($ScriptStackElement)[]
public "getScriptStack"(): ($ScriptStackElement)[]
public "sourceName"(): string
public "initSourceName"(sourceName: string): void
public "initLineNumber"(lineNumber: integer): void
public "details"(): string
public "initLineSource"(lineSource: string): void
public "initColumnNumber"(columnNumber: integer): void
public "columnNumber"(): integer
get "message"(): string
get "scriptStackTrace"(): string
get "scriptStack"(): ($ScriptStackElement)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RhinoException$Type = ($RhinoException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RhinoException_ = $RhinoException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$AddStageMessage" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $AddStageMessage extends $BaseS2CMessage {

constructor(p: $UUID$Type, s: string)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddStageMessage$Type = ($AddStageMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddStageMessage_ = $AddStageMessage$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeDate" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeDate extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getDefaultValue"(cx: $Context$Type, typeHint: $Class$Type<(any)>): any
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeDate$Type = ($NativeDate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeDate_ = $NativeDate$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeComponentFactory extends $CustomJavaToJsWrapper {

 "create"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Map$Type<(string), (any)>): $RecipeComponent<(any)>
 "convertJavaToJs"(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>): $Scriptable

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Map$Type<(string), (any)>): $RecipeComponent<(any)>
}

export namespace $RecipeComponentFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentFactory$Type = ($RecipeComponentFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentFactory_ = $RecipeComponentFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$StartupEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $StartupEvents {

}

export namespace $StartupEvents {
const GROUP: $EventGroup
const INIT: $EventHandler
const POST_INIT: $EventHandler
const REGISTRY: $EventHandler
const RECIPE_SCHEMA_REGISTRY: $EventHandler
const MODIFY_CREATIVE_TAB: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StartupEvents$Type = ($StartupEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StartupEvents_ = $StartupEvents$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory$Simple" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"

export interface $TypeWrapperFactory$Simple<T> extends $TypeWrapperFactory<(T)> {

 "wrap"(cx: $Context$Type, o: any): T
 "wrapSimple"(arg0: any): T

(cx: $Context$Type, o: any): T
}

export namespace $TypeWrapperFactory$Simple {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapperFactory$Simple$Type<T> = ($TypeWrapperFactory$Simple<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapperFactory$Simple_<T> = $TypeWrapperFactory$Simple$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$MissingComponentException" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$RecipeExceptionJS, $RecipeExceptionJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeExceptionJS"

export class $MissingComponentException extends $RecipeExceptionJS {
readonly "key": $RecipeKey<(any)>
readonly "valid": $Collection<($RecipeKey<(any)>)>
 "error": boolean

constructor(keyName: string, key: $RecipeKey$Type<(any)>, valid: $Collection$Type<($RecipeKey$Type<(any)>)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MissingComponentException$Type = ($MissingComponentException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MissingComponentException_ = $MissingComponentException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$KubeJSClientEventHandler" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ItemTooltipEventJS$StaticTooltipHandler, $ItemTooltipEventJS$StaticTooltipHandler$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS$StaticTooltipHandler"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $KubeJSClientEventHandler {
static "staticItemTooltips": $Map<($Item), ($List<($ItemTooltipEventJS$StaticTooltipHandler)>)>

constructor()

public "init"(): void
public static "setScreen"(screen: $Screen$Type): $Screen
set "screen"(value: $Screen$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSClientEventHandler$Type = ($KubeJSClientEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSClientEventHandler_ = $KubeJSClientEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeArray" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$DataObject, $DataObject$Type} from "packages/dev/latvian/mods/rhino/util/$DataObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $NativeArray extends $IdScriptableObject implements $List<(any)>, $DataObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type, lengthArg: long)
constructor(cx: $Context$Type, array: (any)[])

public "add"(index: integer, element: any): void
public "add"(o: any): boolean
public "remove"(index: integer): any
public "remove"(o: any): boolean
public "get"(index: integer): any
public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "get"(index: long, cx: $Context$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, id: string, start: $Scriptable$Type, value: any): void
public "toString"(): string
public "getLength"(): long
public "indexOf"(o: any): integer
public "clear"(): void
public "lastIndexOf"(o: any): integer
public "isEmpty"(): boolean
public "size"(): integer
public "subList"(fromIndex: integer, toIndex: integer): $List<(any)>
public "toArray"(a: (any)[]): (any)[]
public "toArray"(): (any)[]
public "iterator"(): $Iterator<(any)>
public "contains"(o: any): boolean
public "addAll"(index: integer, c: $Collection$Type<(any)>): boolean
public "addAll"(c: $Collection$Type<(any)>): boolean
public "set"(index: integer, element: any): any
public "delete"(cx: $Context$Type, index: integer): void
public "getAttributes"(cx: $Context$Type, index: integer): integer
public "removeAll"(c: $Collection$Type<(any)>): boolean
public "retainAll"(c: $Collection$Type<(any)>): boolean
public "listIterator"(): $ListIterator<(any)>
public "listIterator"(start: integer): $ListIterator<(any)>
public "containsAll"(c: $Collection$Type<(any)>): boolean
public "getClassName"(): string
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "createDataObject"<T>(instanceFactory: $Supplier$Type<(T)>, cx: $Context$Type): T
public "isDataObjectList"(): boolean
public "getIds"(cx: $Context$Type, nonEnumerable: boolean, getSymbols: boolean): (any)[]
public "createDataObjectList"<T>(instanceFactory: $Supplier$Type<(T)>, cx: $Context$Type): $List<(T)>
public "getIndexIds"(cx: $Context$Type): $List<(integer)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(any)>
public "replaceAll"(arg0: $UnaryOperator$Type<(any)>): void
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any): $List<(any)>
public static "of"<E>(arg0: any): $List<(any)>
public static "of"<E>(): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $List<(any)>
public static "of"<E>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any): $List<(any)>
public static "of"<E>(...arg0: (any)[]): $List<(any)>
public "spliterator"(): $Spliterator<(any)>
public "sort"(arg0: $Comparator$Type<(any)>): void
public "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
public "stream"(): $Stream<(any)>
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "parallelStream"(): $Stream<(any)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<any>;
[index: number]: any
get "length"(): long
get "empty"(): boolean
get "className"(): string
get "dataObjectList"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeArray$Type = ($NativeArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeArray_ = $NativeArray$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeConstructor$Factory" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$ComponentValueMap, $ComponentValueMap$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentValueMap"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$RecipeSchemaType, $RecipeSchemaType$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $RecipeConstructor$Factory {

 "create"(type: $RecipeTypeFunction$Type, schemaType: $RecipeSchemaType$Type, keys: ($RecipeKey$Type<(any)>)[], from: $ComponentValueMap$Type): $RecipeJS
 "setValues"(arg0: $RecipeJS$Type, arg1: $RecipeSchemaType$Type, arg2: ($RecipeKey$Type<(any)>)[], arg3: $ComponentValueMap$Type): void

(type: $RecipeTypeFunction$Type, schemaType: $RecipeSchemaType$Type, keys: ($RecipeKey$Type<(any)>)[], from: $ComponentValueMap$Type): $RecipeJS
}

export namespace $RecipeConstructor$Factory {
const DEFAULT: $RecipeConstructor$Factory
function defaultWith(valueSupplier: $BiFunction$Type<($RecipeJS$Type), ($RecipeKey$Type<(any)>), (any)>): $RecipeConstructor$Factory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$Factory$Type = ($RecipeConstructor$Factory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeConstructor$Factory_ = $RecipeConstructor$Factory$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ExternalArrayData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ExternalArrayData {

 "getArrayElement"(arg0: integer): any
 "getArrayLength"(): integer
 "setArrayElement"(arg0: integer, arg1: any): void
}

export namespace $ExternalArrayData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExternalArrayData$Type = ($ExternalArrayData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExternalArrayData_ = $ExternalArrayData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$DamageProtectionFunction" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"

export interface $EnchantmentBuilder$DamageProtectionFunction {

 "getDamageProtection"(arg0: integer, arg1: $DamageSource$Type): integer

(arg0: integer, arg1: $DamageSource$Type): integer
}

export namespace $EnchantmentBuilder$DamageProtectionFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentBuilder$DamageProtectionFunction$Type = ($EnchantmentBuilder$DamageProtectionFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentBuilder$DamageProtectionFunction_ = $EnchantmentBuilder$DamageProtectionFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$CustomFunction$Func" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"

export interface $CustomFunction$Func {

 "call"(arg0: $Context$Type, arg1: (any)[]): any

(arg0: $Context$Type, arg1: (any)[]): any
}

export namespace $CustomFunction$Func {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomFunction$Func$Type = ($CustomFunction$Func);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomFunction$Func_ = $CustomFunction$Func$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$NumberComponent$IntRange, $NumberComponent$IntRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$IntRange"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$NumberComponent$LongRange, $NumberComponent$LongRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$LongRange"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$NumberComponent$FloatRange, $NumberComponent$FloatRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$FloatRange"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$NumberComponent$DoubleRange, $NumberComponent$DoubleRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$DoubleRange"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $NumberComponent<T extends number> extends $RecipeComponent<(T)> {

 "componentType"(): string
 "componentClass"(): $Class<(any)>
 "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
 "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
 "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
 "write"(arg0: $RecipeJS$Type, arg1: T): $JsonElement
 "key"(name: string): $RecipeKey<(T)>
 "read"(arg0: $RecipeJS$Type, arg1: any): T
 "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
 "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
 "asArray"(): $ArrayRecipeComponent<(T)>
 "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
 "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
 "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
 "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
 "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "orSelf"(): $RecipeComponent<(T)>
 "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
 "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
 "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
 "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
 "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
 "role"(): $ComponentRole
}

export namespace $NumberComponent {
const INT: $NumberComponent$IntRange
const LONG: $NumberComponent$LongRange
const FLOAT: $NumberComponent$FloatRange
const DOUBLE: $NumberComponent$DoubleRange
const ANY_INT: $NumberComponent$IntRange
const ANY_LONG: $NumberComponent$LongRange
const ANY_FLOAT: $NumberComponent$FloatRange
const ANY_DOUBLE: $NumberComponent$DoubleRange
const DYNAMIC_INT: $DynamicRecipeComponent
const DYNAMIC_LONG: $DynamicRecipeComponent
const DYNAMIC_FLOAT: $DynamicRecipeComponent
const DYNAMIC_DOUBLE: $DynamicRecipeComponent
function doubleRange(min: double, max: double): $NumberComponent$DoubleRange
function floatRange(min: float, max: float): $NumberComponent$FloatRange
function intRange(min: integer, max: integer): $NumberComponent$IntRange
function longRange(min: long, max: long): $NumberComponent$LongRange
function builder(): $RecipeComponentBuilder
function builder(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberComponent$Type<T> = ($NumberComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberComponent_<T> = $NumberComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder" {
import {$ItemTintFunction, $ItemTintFunction$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemTintFunction"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CapabilityBuilder, $CapabilityBuilder$Type} from "packages/com/prunoideae/powerfuljs/$CapabilityBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$FoodBuilder, $FoodBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$FoodBuilder"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ItemBuilder$ReleaseUsingCallback, $ItemBuilder$ReleaseUsingCallback$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$ReleaseUsingCallback"
import {$DataJsonGenerator, $DataJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$DataJsonGenerator"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$ItemBuilder$NameCallback, $ItemBuilder$NameCallback$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$NameCallback"
import {$ItemBuilder$UseCallback, $ItemBuilder$UseCallback$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$UseCallback"
import {$ItemBuilder$HurtEnemyContext, $ItemBuilder$HurtEnemyContext$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$HurtEnemyContext"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ItemBuilder$FinishUsingCallback, $ItemBuilder$FinishUsingCallback$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$FinishUsingCallback"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$UseAnim, $UseAnim$Type} from "packages/net/minecraft/world/item/$UseAnim"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ItemBuilder extends $BuilderBase<($Item)> {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

/**
 * Sets the item's name dynamically.
 */
public "name"(name: $ItemBuilder$NameCallback$Type): $ItemBuilder
/**
 * 
 * @deprecated
 */
public "group"(g: string): $ItemBuilder
/**
 * Colorizes item's texture of the given index. Index is used when you have multiple layers, e.g. a crushed ore (of rock + ore).
 */
public "color"(index: integer, color: $ItemTintFunction$Type): $ItemBuilder
/**
 * Colorizes item's texture of the given index. Useful for coloring items, like GT ores ore dusts.
 */
public "color"(callback: $ItemTintFunction$Type): $ItemBuilder
/**
 * Sets the item's max stack size. Default is 64.
 */
public "maxStackSize"(v: integer): $ItemBuilder
/**
 * Determines if player will start using the item.
 * 
 * For example, when eating food, returning true will make the player start eating the food.
 */
public "use"(use: $ItemBuilder$UseCallback$Type): $ItemBuilder
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "generateDataJsons"(generator: $DataJsonGenerator$Type): void
/**
 * Sets the item's burn time. Default is 0 (Not a fuel).
 */
public "burnTime"(v: integer): $ItemBuilder
/**
 * Sets the item's container item, e.g. a bucket for a milk bucket.
 */
public "containerItem"(id: $ResourceLocation$Type): $ItemBuilder
/**
 * Adds subtypes to the item. The function should return a collection of item stacks, each with a different subtype.
 * 
 * Each subtype will appear as a separate item in JEI and the creative inventory.
 */
public "subtypes"(fn: $Function$Type<($ItemStack$Type), ($Collection$Type<($ItemStack$Type)>)>): $ItemBuilder
/**
 * Directlys set the item's texture json.
 */
public "textureJson"(json: $JsonObject$Type): $ItemBuilder
/**
 * Adds an attribute modifier to the item.
 * 
 * An attribute modifier is something like a damage boost or a speed boost.
 * On tools, they're applied when the item is held, on armor, they're
 * applied when the item is worn.
 * 
 * @param attribute - The resource location of the attribute, e.g. 'generic.attack_damage'
 * @param identifier - A unique identifier for the modifier. Modifiers are considered the same if they have the same identifier.
 * @param d - The amount of the modifier.
 * @param operation - The operation to apply the modifier with. Can be ADDITION, MULTIPLY_BASE, or MULTIPLY_TOTAL.
 */
public "modifyAttribute"(attribute: $ResourceLocation$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): $ItemBuilder
/**
 * Determines the animation of the item when used, e.g. eating food.
 */
public "useAnimation"(animation: $UseAnim$Type): $ItemBuilder
/**
 * Set the food properties of the item.
 */
public "food"(b: $Consumer$Type<($FoodBuilder$Type)>): $ItemBuilder
public "transformObject"(obj: $Item$Type): $Item
/**
 * Directly set the item's model json.
 */
public "modelJson"(json: $JsonObject$Type): $ItemBuilder
/**
 * Sets the item's model (parent).
 */
public "parentModel"(m: string): $ItemBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
/**
 * Sets the item's texture (layer0).
 */
public "texture"(tex: string): $ItemBuilder
/**
 * Sets the item's texture by given key.
 */
public "texture"(key: string, tex: string): $ItemBuilder
public "attachCapability"(builder: $CapabilityBuilder$Type<(any), (any), (any)>): $ItemBuilder
/**
 * Determines the color of the item's durability bar. Defaulted to vanilla behavior.
 */
public "barColor"(barColor: $Function$Type<($ItemStack$Type), ($Color$Type)>): $ItemBuilder
/**
 * When players finish using the item.
 * 
 * This is called only when `useDuration` ticks have passed.
 * 
 * For example, when eating food, this is called when the player has finished eating the food, so hunger is restored.
 */
public "finishUsing"(finishUsing: $ItemBuilder$FinishUsingCallback$Type): $ItemBuilder
/**
 * Makes the item glow like enchanted, even if it's not enchanted.
 */
public "glow"(v: boolean): $ItemBuilder
/**
 * Determines the width of the item's durability bar. Defaulted to vanilla behavior.
 * 
 * The function should return a value between 0 and 13 (max width of the bar).
 */
public "barWidth"(barWidth: $ToIntFunction$Type<($ItemStack$Type)>): $ItemBuilder
/**
 * The duration when the item is used.
 * 
 * For example, when eating food, this is the time it takes to eat the food.
 * This can change the eating speed, or be used for other things (like making a custom bow).
 */
public "useDuration"(useDuration: $ToIntFunction$Type<($ItemStack$Type)>): $ItemBuilder
/**
 * Sets the item's max damage. Default is 0 (No durability).
 */
public "maxDamage"(v: integer): $ItemBuilder
/**
 * Gets called when the item is used to hurt an entity.
 * 
 * For example, when using a sword to hit a mob, this is called.
 */
public "hurtEnemy"(context: $Predicate$Type<($ItemBuilder$HurtEnemyContext$Type)>): $ItemBuilder
/**
 * Sets the item's rarity.
 */
public "rarity"(v: $Rarity$Type): $ItemBuilder
/**
 * When players did not finish using the item but released the right mouse button halfway through.
 * 
 * An example is the bow, where the arrow is shot when the player releases the right mouse button.
 * 
 * To ensure the bow won't finish using, Minecraft sets the `useDuration` to a very high number (1h).
 */
public "releaseUsing"(releaseUsing: $ItemBuilder$ReleaseUsingCallback$Type): $ItemBuilder
/**
 * Adds a tooltip to the item.
 */
public "tooltip"(text: $Component$Type): $ItemBuilder
/**
 * Makes the item not stackable, equivalent to setting the item's max stack size to 1.
 */
public "unstackable"(): $ItemBuilder
/**
 * Makes the item fire resistant like netherite tools (or not).
 */
public "fireResistant"(isFireResistant: boolean): $ItemBuilder
/**
 * Makes the item fire resistant like netherite tools.
 */
public "fireResistant"(): $ItemBuilder
public static "toArmorMaterial"(o: any): $ArmorMaterial
public static "toToolTier"(o: any): $Tier
public "createItemProperties"(): $Item$Properties
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$Type = ($ItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder_ = $ItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/forge/$RhinoPropertiesImpl" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $RhinoPropertiesImpl {

constructor()

public static "isDev"(): boolean
public static "getGameDir"(): $Path
public static "openResource"(path: string): $InputStream
get "dev"(): boolean
get "gameDir"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RhinoPropertiesImpl$Type = ($RhinoPropertiesImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RhinoPropertiesImpl_ = $RhinoPropertiesImpl$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$TextObject" {
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $TextObject extends $BoxObject {
 "text": ($FormattedCharSequence)[]
 "shadow": $Unit
 "scale": $Unit
 "color": $Unit
 "centered": $Unit
 "lineSpacing": $Unit
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public "preDraw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextObject$Type = ($TextObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextObject_ = $TextObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ErrorNode" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ErrorNode extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getMessage"(): string
public "setMessage"(message: string): void
get "message"(): string
set "message"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorNode$Type = ($ErrorNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErrorNode_ = $ErrorNode$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ES6Generator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$NativeFunction, $NativeFunction$Type} from "packages/dev/latvian/mods/rhino/$NativeFunction"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $ES6Generator extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(scope: $Scriptable$Type, arg1: $NativeFunction$Type, savedState: any, cx: $Context$Type)

public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ES6Generator$Type = ($ES6Generator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ES6Generator_ = $ES6Generator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$TagEventJS" {
import {$TagWrapper, $TagWrapper$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagWrapper"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EventExceptionHandler, $EventExceptionHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventExceptionHandler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TagEventJS extends $EventJS {
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
static readonly "SOURCE": string
readonly "registry": $RegistryInfo<(any)>
readonly "vanillaRegistry": $Registry<(any)>
readonly "tags": $Map<($ResourceLocation), ($TagWrapper)>
 "totalAdded": integer
 "totalRemoved": integer

constructor(ri: $RegistryInfo$Type<(any)>, vr: $Registry$Type<(any)>)

public "add"(tag: $ResourceLocation$Type, ...filters: (any)[]): $TagWrapper
public "remove"(tag: $ResourceLocation$Type, ...filters: (any)[]): $TagWrapper
public "get"(id: $ResourceLocation$Type): $TagWrapper
public "getType"(): $ResourceLocation
public "removeAll"(tag: $ResourceLocation$Type): $TagWrapper
public "removeAllTagsFrom"(...ids: (any)[]): void
public "getElementIds"(): $Set<($ResourceLocation)>
get "type"(): $ResourceLocation
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagEventJS$Type = ($TagEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagEventJS_ = $TagEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$MultipartBlockStateGenerator" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MultipartBlockStateGenerator$Part, $MultipartBlockStateGenerator$Part$Type} from "packages/dev/latvian/mods/kubejs/client/$MultipartBlockStateGenerator$Part"

export class $MultipartBlockStateGenerator {

constructor()

public "part"(when: string, model: string): void
public "part"(when: string, consumer: $Consumer$Type<($MultipartBlockStateGenerator$Part$Type)>): void
public "toJson"(): $JsonObject
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartBlockStateGenerator$Type = ($MultipartBlockStateGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartBlockStateGenerator_ = $MultipartBlockStateGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator$Variant" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$VariantBlockStateGenerator$Model, $VariantBlockStateGenerator$Model$Type} from "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator$Model"

export class $VariantBlockStateGenerator$Variant {

constructor()

public "toJson"(): $JsonElement
public "model"(s: string): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Variant$Type = ($VariantBlockStateGenerator$Variant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator$Variant_ = $VariantBlockStateGenerator$Variant$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$OpUnit" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $OpUnit extends $Unit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(symbol: $UnitSymbol$Type, left: $Unit$Type, right: $Unit$Type)

public "toString"(builder: $StringBuilder$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OpUnit$Type = ($OpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OpUnit_ = $OpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Undefined" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $Undefined implements $Serializable {
static readonly "instance": any
static readonly "SCRIPTABLE_UNDEFINED": $Scriptable


public "equals"(obj: any): boolean
public "hashCode"(): integer
public "readResolve"(): any
public static "isUndefined"(obj: any): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Undefined$Type = ($Undefined);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Undefined_ = $Undefined$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerAdvancementEventJS" {
import {$AdvancementJS, $AdvancementJS$Type} from "packages/dev/latvian/mods/kubejs/player/$AdvancementJS"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Advancement, $Advancement$Type} from "packages/net/minecraft/advancements/$Advancement"

/**
 * Invoked when a player gets an advancement.
 */
export class $PlayerAdvancementEventJS extends $PlayerEventJS {

constructor(player: $ServerPlayer$Type, advancement: $Advancement$Type)

/**
 * Returns the advancement that was obtained.
 */
public "getAdvancement"(): $AdvancementJS
get "advancement"(): $AdvancementJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerAdvancementEventJS$Type = ($PlayerAdvancementEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerAdvancementEventJS_ = $PlayerAdvancementEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapper" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"

export class $TypeWrapper<T> {
static readonly "ALWAYS_VALID": $Predicate<(any)>
readonly "target": $Class<(T)>
readonly "validator": $Predicate<(any)>
readonly "factory": $TypeWrapperFactory<(T)>


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapper$Type<T> = ($TypeWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapper_<T> = $TypeWrapper$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/$WrappedException" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"

export class $WrappedException extends $EvaluatorException {

constructor(cx: $Context$Type, exception: $Throwable$Type)

public "getWrappedException"(): $Throwable
get "wrappedException"(): $Throwable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedException$Type = ($WrappedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedException_ = $WrappedException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$PlatformWrapper" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$PlatformWrapper$ModInfo, $PlatformWrapper$ModInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$PlatformWrapper$ModInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper {

constructor()

public static "getName"(): string
public static "isLoaded"(modId: string): boolean
public static "getInfo"(modID: string): $PlatformWrapper$ModInfo
public static "getList"(): $Set<(string)>
public static "isDevelopmentEnvironment"(): boolean
public static "isFabric"(): boolean
public static "getMods"(): $Map<(string), ($PlatformWrapper$ModInfo)>
public static "getModVersion"(): string
public static "getMinecraftVersion"(): integer
public static "isGeneratingData"(): boolean
public static "breakpoint"(...args: (any)[]): void
public static "getMcVersion"(): string
public static "isClientEnvironment"(): boolean
public static "getMinecraftVersionString"(): string
public static "isForge"(): boolean
public static "setModName"(modId: string, name: string): void
get "name"(): string
get "list"(): $Set<(string)>
get "developmentEnvironment"(): boolean
get "fabric"(): boolean
get "mods"(): $Map<(string), ($PlatformWrapper$ModInfo)>
get "modVersion"(): string
get "minecraftVersion"(): integer
get "generatingData"(): boolean
get "mcVersion"(): string
get "clientEnvironment"(): boolean
get "minecraftVersionString"(): string
get "forge"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$Type = ($PlatformWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformWrapper_ = $PlatformWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/generator/$ResourceGenerator" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ResourceGenerator {

constructor(c: $ConsoleJS$Type, m: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>)

public "add"(id: $ResourceLocation$Type, data: $Supplier$Type<((byte)[])>): void
public "add"(id: $ResourceLocation$Type, data: $Supplier$Type<((byte)[])>, alwaysForget: boolean): void
public "json"(id: $ResourceLocation$Type, json: $JsonElement$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResourceGenerator$Type = ($ResourceGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResourceGenerator_ = $ResourceGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$SimplePlayerEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

export class $SimplePlayerEventJS extends $PlayerEventJS {

constructor(p: $Player$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimplePlayerEventJS$Type = ($SimplePlayerEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimplePlayerEventJS_ = $SimplePlayerEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$KubeJSCreativeTabs" {
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/dev/architectury/registry/registries/$DeferredRegister"

export class $KubeJSCreativeTabs {
static readonly "REGISTER": $DeferredRegister<($CreativeModeTab)>

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCreativeTabs$Type = ($KubeJSCreativeTabs);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCreativeTabs_ = $KubeJSCreativeTabs$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnitInterpretException" {
import {$IllegalStateException, $IllegalStateException$Type} from "packages/java/lang/$IllegalStateException"

export class $UnitInterpretException extends $IllegalStateException {

constructor(s: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitInterpretException$Type = ($UnitInterpretException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitInterpretException_ = $UnitInterpretException$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$JavaSetWrapper" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/java/util/$AbstractList"

export class $JavaSetWrapper<T> extends $AbstractList<(T)> {
readonly "set": $Set<(T)>

constructor(set: $Set$Type<(T)>)

public "add"(index: integer, element: T): void
public "add"(t: T): boolean
public "remove"(o: any): boolean
public "remove"(index: integer): T
public "get"(index: integer): T
public "clear"(): void
public "size"(): integer
public "addAll"(c: $Collection$Type<(any)>): boolean
public "addAll"(index: integer, c: $Collection$Type<(any)>): boolean
public "set"(index: integer, element: T): T
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaSetWrapper$Type<T> = ($JavaSetWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaSetWrapper_<T> = $JavaSetWrapper$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$FireworkRocketEntityKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FireworkRocketEntityKJS {

 "setLifetimeKJS"(arg0: integer): void

(arg0: integer): void
}

export namespace $FireworkRocketEntityKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworkRocketEntityKJS$Type = ($FireworkRocketEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworkRocketEntityKJS_ = $FireworkRocketEntityKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder$Chestplate" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorItemBuilder$Chestplate extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "armorTier": $MutableArmorTier
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Chestplate$Type = ($ArmorItemBuilder$Chestplate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Chestplate_ = $ArmorItemBuilder$Chestplate$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/rei/$InformationREIEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$REIEntryWrappers, $REIEntryWrappers$Type} from "packages/dev/latvian/mods/kubejs/integration/rei/$REIEntryWrappers"

export class $InformationREIEventJS extends $EventJS {

constructor(entryWrappers: $REIEntryWrappers$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InformationREIEventJS$Type = ($InformationREIEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InformationREIEventJS_ = $InformationREIEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/forge/$LivingEntityDropsEventJS" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntityEventJS, $LivingEntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS"
import {$LivingDropsEvent, $LivingDropsEvent$Type} from "packages/net/minecraftforge/event/entity/living/$LivingDropsEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

export class $LivingEntityDropsEventJS extends $LivingEntityEventJS {
 "eventDrops": $List<($ItemEntity)>

constructor(e: $LivingDropsEvent$Type)

public "getSource"(): $DamageSource
public "addDrop"(stack: $ItemStack$Type, chance: float): $ItemEntity
public "addDrop"(stack: $ItemStack$Type): $ItemEntity
public "isRecentlyHit"(): boolean
public "getDrops"(): $List<($ItemEntity)>
public "getLootingLevel"(): integer
get "source"(): $DamageSource
get "recentlyHit"(): boolean
get "drops"(): $List<($ItemEntity)>
get "lootingLevel"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDropsEventJS$Type = ($LivingEntityDropsEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityDropsEventJS_ = $LivingEntityDropsEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$MultipartShapedBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $MultipartShapedBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type, ...suffixes: (string)[])

public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultipartShapedBlockBuilder$Type = ($MultipartShapedBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultipartShapedBlockBuilder_ = $MultipartShapedBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$JavaMembers$FieldInfo" {
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"

export class $JavaMembers$FieldInfo {
readonly "field": $Field
 "name": string

constructor(f: $Field$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaMembers$FieldInfo$Type = ($JavaMembers$FieldInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaMembers$FieldInfo_ = $JavaMembers$FieldInfo$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$RemappingHelper$Callback" {
import {$RemappingHelper$MappingContext, $RemappingHelper$MappingContext$Type} from "packages/dev/latvian/mods/rhino/mod/util/$RemappingHelper$MappingContext"

export interface $RemappingHelper$Callback {

 "generateMappings"(arg0: $RemappingHelper$MappingContext$Type): void

(arg0: $RemappingHelper$MappingContext$Type): void
}

export namespace $RemappingHelper$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappingHelper$Callback$Type = ($RemappingHelper$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappingHelper$Callback_ = $RemappingHelper$Callback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$PostFunction" {
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $EnchantmentBuilder$PostFunction {

 "apply"(arg0: $LivingEntity$Type, arg1: $Entity$Type, arg2: integer): void

(arg0: $LivingEntity$Type, arg1: $Entity$Type, arg2: integer): void
}

export namespace $EnchantmentBuilder$PostFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentBuilder$PostFunction$Type = ($EnchantmentBuilder$PostFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentBuilder$PostFunction_ = $EnchantmentBuilder$PostFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$PreTagWrapper" {
import {$PreTagEventJS, $PreTagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$PreTagEventJS"
import {$TagWrapper, $TagWrapper$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagWrapper"
import {$TagEventJS, $TagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagEventJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$Type} from "packages/net/minecraft/tags/$TagLoader$EntryWithSource"

export class $PreTagWrapper extends $TagWrapper {
readonly "preEvent": $PreTagEventJS
readonly "id": $ResourceLocation
readonly "event": $TagEventJS
readonly "entries": $List<($TagLoader$EntryWithSource)>

constructor(e: $PreTagEventJS$Type, i: $ResourceLocation$Type)

public "add"(...filters: (any)[]): $TagWrapper
public "remove"(...filters: (any)[]): $TagWrapper
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagWrapper$Type = ($PreTagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PreTagWrapper_ = $PreTagWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$KubeJSBackgroundThread" {
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"

export class $KubeJSBackgroundThread extends $Thread {
static "running": boolean
static readonly "MIN_PRIORITY": integer
static readonly "NORM_PRIORITY": integer
static readonly "MAX_PRIORITY": integer

constructor()

public "run"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSBackgroundThread$Type = ($KubeJSBackgroundThread);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSBackgroundThread_ = $KubeJSBackgroundThread$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Ref" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $Ref {

constructor()

public "get"(arg0: $Context$Type): any
public "set"(cx: $Context$Type, scope: $Scriptable$Type, value: any): any
/**
 * 
 * @deprecated
 */
public "set"(arg0: $Context$Type, arg1: any): any
public "delete"(cx: $Context$Type): boolean
public "has"(cx: $Context$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Ref$Type = ($Ref);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Ref_ = $Ref$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$BlockComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockComponent extends $Record implements $RecipeComponent<($Block)> {
static readonly "INPUT": $RecipeComponent<($Block)>
static readonly "OUTPUT": $RecipeComponent<($Block)>
static readonly "BLOCK": $RecipeComponent<($Block)>

constructor(crole: $ComponentRole$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: $Block$Type): $JsonPrimitive
public "read"(recipe: $RecipeJS$Type, from: any): $Block
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: $Block$Type, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $Block$Type, match: $ReplacementMatch$Type): boolean
public "checkEmpty"(key: $RecipeKey$Type<($Block$Type)>, value: $Block$Type): string
public "crole"(): $ComponentRole
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Block)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($Block)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($Block), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($Block), (O)>
public "asArray"(): $ArrayRecipeComponent<($Block)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Block)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($Block)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($Block)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Block$Type)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Block$Type)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Block$Type)>, map: $Map$Type<(any), (any)>): void
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "orSelf"(): $RecipeComponent<($Block)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($Block)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Block)>)>
public "replaceOutput"(recipe: $RecipeJS$Type, original: $Block$Type, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $Block
public "replaceInput"(recipe: $RecipeJS$Type, original: $Block$Type, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $Block
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: $Block$Type, newValue: $Block$Type): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Block)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockComponent$Type = ($BlockComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockComponent_ = $BlockComponent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ContextAction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"

export interface $ContextAction<T> {

 "run"(arg0: $Context$Type): T

(arg0: $Context$Type): T
}

export namespace $ContextAction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContextAction$Type<T> = ($ContextAction<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContextAction_<T> = $ContextAction$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/unit/function/$RandomUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $RandomUnit extends $FuncUnit {
static readonly "RANDOM": $Random
static readonly "FACTORY": $FunctionFactory
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomUnit$Type = ($RandomUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RandomUnit_ = $RandomUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$ExplosionEventJS$Before" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$ExplosionEventJS, $ExplosionEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionEventJS"

/**
 * Invoked right before an explosion happens.
 */
export class $ExplosionEventJS$Before extends $ExplosionEventJS {

constructor(level: $Level$Type, explosion: $Explosion$Type)

/**
 * Returns the size of the explosion.
 */
public "getSize"(): float
/**
 * Sets the size of the explosion.
 */
public "setSize"(s: float): void
get "size"(): float
set "size"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEventJS$Before$Type = ($ExplosionEventJS$Before);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEventJS$Before_ = $ExplosionEventJS$Before$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$GenericDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export class $GenericDescJS extends $Record implements $TypeDescJS {

constructor(type: $TypeDescJS$Type, ...types: ($TypeDescJS$Type)[])

public "type"(): $TypeDescJS
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "types"(): ($TypeDescJS)[]
public "build"(builder: $StringBuilder$Type): void
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "build"(): string
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericDescJS$Type = ($GenericDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericDescJS_ = $GenericDescJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$LogFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $LogFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogFuncUnit$Type = ($LogFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogFuncUnit_ = $LogFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$PowOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $PowOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PowOpUnit$Type = ($PowOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PowOpUnit_ = $PowOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MemberDef" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$MojangMappings$TypeDef, $MojangMappings$TypeDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$TypeDef"
import {$MojangMappings$NamedSignature, $MojangMappings$NamedSignature$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$NamedSignature"
import {$MutableObject, $MutableObject$Type} from "packages/org/apache/commons/lang3/mutable/$MutableObject"
import {$MojangMappings$ClassDef, $MojangMappings$ClassDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$ClassDef"

export class $MojangMappings$MemberDef extends $Record {

constructor(parent: $MojangMappings$ClassDef$Type, rawName: $MojangMappings$NamedSignature$Type, mmName: string, type: $MojangMappings$TypeDef$Type, unmappedName: $MutableObject$Type<(string)>)

public "parent"(): $MojangMappings$ClassDef
public "type"(): $MojangMappings$TypeDef
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "cleanup"(): boolean
public "unmappedName"(): $MutableObject<(string)>
public "rawName"(): $MojangMappings$NamedSignature
public "mmName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$MemberDef$Type = ($MojangMappings$MemberDef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings$MemberDef_ = $MojangMappings$MemberDef$Type;
}}
declare module "packages/dev/latvian/mods/unit/$EmptyVariableSet" {
import {$MutableNumberUnit, $MutableNumberUnit$Type} from "packages/dev/latvian/mods/unit/$MutableNumberUnit"
import {$VariableSet, $VariableSet$Type} from "packages/dev/latvian/mods/unit/$VariableSet"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $EmptyVariableSet extends $VariableSet {
static readonly "INSTANCE": $EmptyVariableSet


public "get"(entry: string): $Unit
public "set"(name: string, value: double): $VariableSet
public "set"(name: string, value: $Unit$Type): $VariableSet
public "createSubset"(): $VariableSet
public "setMutable"(name: string, initialValue: double): $MutableNumberUnit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyVariableSet$Type = ($EmptyVariableSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyVariableSet_ = $EmptyVariableSet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$KubeJSBlockProperties" {
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$NoteBlockInstrument, $NoteBlockInstrument$Type} from "packages/net/minecraft/world/level/block/state/properties/$NoteBlockInstrument"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$FeatureFlagSet, $FeatureFlagSet$Type} from "packages/net/minecraft/world/flag/$FeatureFlagSet"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PushReaction, $PushReaction$Type} from "packages/net/minecraft/world/level/material/$PushReaction"
import {$BlockBehaviour$OffsetFunction, $BlockBehaviour$OffsetFunction$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$OffsetFunction"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$BlockBehaviour$StatePredicate, $BlockBehaviour$StatePredicate$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$StatePredicate"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$BlockBehaviour$StateArgumentPredicate, $BlockBehaviour$StateArgumentPredicate$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$StateArgumentPredicate"

export class $KubeJSBlockProperties extends $BlockBehaviour$Properties {
readonly "blockBuilder": $BlockBuilder
 "mapColor": $Function<($BlockState), ($MapColor)>
 "hasCollision": boolean
 "soundType": $SoundType
 "lightEmission": $ToIntFunction<($BlockState)>
 "explosionResistance": float
 "destroyTime": float
 "requiresCorrectToolForDrops": boolean
 "isRandomlyTicking": boolean
 "friction": float
 "speedFactor": float
 "jumpFactor": float
 "drops": $ResourceLocation
 "canOcclude": boolean
 "isAir": boolean
 "ignitedByLava": boolean
/**
 * 
 * @deprecated
 */
 "liquid": boolean
/**
 * 
 * @deprecated
 */
 "forceSolidOff": boolean
 "forceSolidOn": boolean
 "pushReaction": $PushReaction
 "spawnParticlesOnBreak": boolean
 "instrument": $NoteBlockInstrument
 "replaceable": boolean
 "lootTableSupplier": $Supplier<($ResourceLocation)>
 "isValidSpawn": $BlockBehaviour$StateArgumentPredicate<($EntityType<(any)>)>
 "isRedstoneConductor": $BlockBehaviour$StatePredicate
 "isSuffocating": $BlockBehaviour$StatePredicate
 "isViewBlocking": $BlockBehaviour$StatePredicate
 "hasPostProcess": $BlockBehaviour$StatePredicate
 "emissiveRendering": $BlockBehaviour$StatePredicate
 "dynamicShape": boolean
 "requiredFeatures": $FeatureFlagSet
 "offsetFunction": $Optional<($BlockBehaviour$OffsetFunction)>

constructor(blockBuilder: $BlockBuilder$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSBlockProperties$Type = ($KubeJSBlockProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSBlockProperties_ = $KubeJSBlockProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$FenceBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$MultipartShapedBlockBuilder, $MultipartShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$MultipartShapedBlockBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export class $FenceBlockBuilder extends $MultipartShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FenceBlockBuilder$Type = ($FenceBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FenceBlockBuilder_ = $FenceBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ErrorCollector" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IdeErrorReporter, $IdeErrorReporter$Type} from "packages/dev/latvian/mods/rhino/ast/$IdeErrorReporter"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"
import {$ParseProblem, $ParseProblem$Type} from "packages/dev/latvian/mods/rhino/ast/$ParseProblem"

export class $ErrorCollector implements $IdeErrorReporter {

constructor()

public "toString"(): string
public "error"(message: string, sourceName: string, fileOffset: integer, length: integer): void
public "error"(cx: $Context$Type, message: string, sourceName: string, line: integer, lineSource: string, lineOffset: integer): void
public "warning"(message: string, sourceName: string, offset: integer, length: integer): void
public "warning"(message: string, sourceName: string, line: integer, lineSource: string, lineOffset: integer): void
public "runtimeError"(cx: $Context$Type, message: string, sourceName: string, line: integer, lineSource: string, lineOffset: integer): $EvaluatorException
public "getErrors"(): $List<($ParseProblem)>
get "errors"(): $List<($ParseProblem)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorCollector$Type = ($ErrorCollector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErrorCollector_ = $ErrorCollector$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$TokenStream" {
import {$Token$CommentType, $Token$CommentType$Type} from "packages/dev/latvian/mods/rhino/$Token$CommentType"

export class $TokenStream {


public "getCursor"(): integer
public "getTokenLength"(): integer
public "getTokenBeg"(): integer
public "getTokenEnd"(): integer
public "getCommentType"(): $Token$CommentType
get "cursor"(): integer
get "tokenLength"(): integer
get "tokenBeg"(): integer
get "tokenEnd"(): integer
get "commentType"(): $Token$CommentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TokenStream$Type = ($TokenStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TokenStream_ = $TokenStream$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$FastDtoaBuilder" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $FastDtoaBuilder {

constructor()

public "toString"(): string
public "format"(): string
public "reset"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FastDtoaBuilder$Type = ($FastDtoaBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FastDtoaBuilder_ = $FastDtoaBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$NativeRegExp" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeRegExp extends $IdScriptableObject implements $Function {
static readonly "JSREG_GLOB": integer
static readonly "JSREG_FOLD": integer
static readonly "JSREG_MULTILINE": integer
static readonly "TEST": integer
static readonly "MATCH": integer
static readonly "PREFIX": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "toString"(): string
public static "init"(cx: $Context$Type, scope: $Scriptable$Type, sealed: boolean): void
public "getClassName"(): string
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getTypeOf"(): $MemberType
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "hasInstance"(arg0: $Context$Type, arg1: $Scriptable$Type): boolean
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "className"(): string
get "typeOf"(): $MemberType
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeRegExp$Type = ($NativeRegExp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeRegExp_ = $NativeRegExp$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$RecordItemJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$RecordItemJS$Builder, $RecordItemJS$Builder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$RecordItemJS$Builder"
import {$Item$Properties, $Item$Properties$Type} from "packages/net/minecraft/world/item/$Item$Properties"
import {$RecordItem, $RecordItem$Type} from "packages/net/minecraft/world/item/$RecordItem"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecordItemJS extends $RecordItem {
/**
 * 
 * @deprecated
 */
static readonly "BY_NAME": $Map<($SoundEvent), ($RecordItem)>
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(b: $RecordItemJS$Builder$Type, analogOutput: integer, song: $SoundEvent$Type, properties: $Item$Properties$Type)

public "getLengthInTicks"(): integer
public "getSound"(): $SoundEvent
get "lengthInTicks"(): integer
get "sound"(): $SoundEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordItemJS$Type = ($RecordItemJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordItemJS_ = $RecordItemJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$InputFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $InputFilter implements $RecipeFilter {

constructor(match: $ReplacementMatch$Type)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputFilter$Type = ($InputFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputFilter_ = $InputFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$NotFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $NotFilter extends $Record implements $MobFilter {

constructor(original: $MobFilter$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "original"(): $MobFilter
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotFilter$Type = ($NotFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotFilter_ = $NotFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$HoeItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HandheldItemBuilder, $HandheldItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HoeItemBuilder extends $HandheldItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoeItemBuilder$Type = ($HoeItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoeItemBuilder_ = $HoeItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$DataSenderKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"

export interface $DataSenderKJS {

 "sendData"(channel: string, data: $CompoundTag$Type): void
 "sendData"(channel: string): void
}

export namespace $DataSenderKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataSenderKJS$Type = ($DataSenderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataSenderKJS_ = $DataSenderKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventGroupWrapper" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $EventGroupWrapper extends $HashMap<(string), ($BaseFunction)> {

constructor(scriptType: $ScriptType$Type, group: $EventGroup$Type)

public "containsKey"(key: any): boolean
public "keySet"(): $Set<(string)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroupWrapper$Type = ($EventGroupWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventGroupWrapper_ = $EventGroupWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$WorldgenEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $WorldgenEvents {

}

export namespace $WorldgenEvents {
const GROUP: $EventGroup
const ADD: $EventHandler
const REMOVE: $EventHandler
function post(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldgenEvents$Type = ($WorldgenEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldgenEvents_ = $WorldgenEvents$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$NbtType" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $NbtType {
static readonly "END": integer
static readonly "BYTE": integer
static readonly "SHORT": integer
static readonly "INT": integer
static readonly "LONG": integer
static readonly "FLOAT": integer
static readonly "DOUBLE": integer
static readonly "BYTE_ARRAY": integer
static readonly "STRING": integer
static readonly "LIST": integer
static readonly "COMPOUND": integer
static readonly "INT_ARRAY": integer
static readonly "LONG_ARRAY": integer
static readonly "NUMBER": integer


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NbtType$Type = ($NbtType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NbtType_ = $NbtType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$Stages" {
import {$StageChangeEvent, $StageChangeEvent$Type} from "packages/dev/latvian/mods/kubejs/stages/$StageChangeEvent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$StageCreationEvent, $StageCreationEvent$Type} from "packages/dev/latvian/mods/kubejs/stages/$StageCreationEvent"

export class $Stages {
readonly "player": $Player

constructor(p: $Player$Type)

public "add"(stage: string): boolean
public "remove"(stage: string): boolean
public static "get"(player: $Player$Type): $Stages
public "clear"(): boolean
public "replace"(stages: $Collection$Type<(string)>): void
public "set"(stage: string, enabled: boolean): boolean
public static "create"(player: $Player$Type): $Stages
public static "added"(event: $Consumer$Type<($StageChangeEvent$Type)>): void
public static "removed"(event: $Consumer$Type<($StageChangeEvent$Type)>): void
public "sync"(): void
public "getAll"(): $Collection<(string)>
public "has"(stage: string): boolean
public static "invokeRemoved"(stages: $Stages$Type, stage: string): void
public static "overrideCreation"(event: $Consumer$Type<($StageCreationEvent$Type)>): void
public "addNoUpdate"(arg0: string): boolean
public "removeNoUpdate"(arg0: string): boolean
public static "invokeAdded"(stages: $Stages$Type, stage: string): void
public "toggle"(stage: string): boolean
get "all"(): $Collection<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stages$Type = ($Stages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Stages_ = $Stages$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$InputFluid" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$FluidLike, $FluidLike$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidLike"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $InputFluid extends $FluidLike, $InputReplacement {

 "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
 "matches"(other: $FluidLike$Type): boolean
 "copy"(amount: long): $FluidLike
 "getAmount"(): long
 "isEmpty"(): boolean
 "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement

(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
}

export namespace $InputFluid {
function of(o: any): $InputReplacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputFluid$Type = ($InputFluid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputFluid_ = $InputFluid$Type;
}}
declare module "packages/dev/latvian/mods/rhino/annotations/$JSFunction" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JSFunction extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JSFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSFunction$Type = ($JSFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSFunction_ = $JSFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$NBTUtils" {
import {$ValueUnwrapper, $ValueUnwrapper$Type} from "packages/dev/latvian/mods/rhino/util/$ValueUnwrapper"
import {$TagType, $TagType$Type} from "packages/net/minecraft/nbt/$TagType"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$CollectionTag, $CollectionTag$Type} from "packages/net/minecraft/nbt/$CollectionTag"
import {$ListTag, $ListTag$Type} from "packages/net/minecraft/nbt/$ListTag"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$OrderedCompoundTag, $OrderedCompoundTag$Type} from "packages/dev/latvian/mods/rhino/mod/util/$OrderedCompoundTag"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $NBTUtils {

}

export namespace $NBTUtils {
const VALUE_UNWRAPPER: $ValueUnwrapper
const COMPOUND_TYPE: $TagType<($OrderedCompoundTag)>
const LIST_TYPE: $TagType<($ListTag)>
function i(v: integer): $Tag
function b(v: byte): $Tag
function ba(v: (byte)[]): $Tag
function s(v: short): $Tag
function f(v: float): $Tag
function l(v: long): $Tag
function d(v: double): $Tag
function read(buf: $FriendlyByteBuf$Type): $OrderedCompoundTag
function convertType(tagType: $TagType$Type<(any)>): $TagType<(any)>
function ia(v: (integer)[]): $Tag
function stringTag(v: string): $Tag
function longArrayTag(v: (long)[]): $Tag
function shortTag(v: short): $Tag
function intArrayTag(v: (integer)[]): $Tag
function byteArrayTag(v: (byte)[]): $Tag
function byteTag(v: byte): $Tag
function floatTag(v: float): $Tag
function longTag(v: long): $Tag
function doubleTag(v: double): $Tag
function accessTagMap(tag: $CompoundTag$Type): $Map<(string), ($Tag)>
function intTag(v: integer): $Tag
function toJson(t: $Tag$Type): $JsonElement
function fromTag(t: $Tag$Type): any
function toTag(v: any): $Tag
function compoundTag(map: $Map$Type<(any), (any)>): $Tag
function compoundTag(): $Tag
function la(v: (long)[]): $Tag
function toTagCompound(v: any): $CompoundTag
function toTagCollection(c: $Collection$Type<(any)>): $CollectionTag<(any)>
function toTagCollection(v: any): $CollectionTag<(any)>
function toTagList(list: any): $ListTag
function isTagCollection(o: any): boolean
function isTagCompound(o: any): boolean
function quoteAndEscapeForJS(stringBuilder: $StringBuilder$Type, string: string): void
function listTag(list: $List$Type<(any)>): $Tag
function listTag(): $Tag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTUtils$Type = ($NBTUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTUtils_ = $NBTUtils$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$BasicParticleType" {
import {$SimpleParticleType, $SimpleParticleType$Type} from "packages/net/minecraft/core/particles/$SimpleParticleType"

export class $BasicParticleType extends $SimpleParticleType {

constructor(bl: boolean)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicParticleType$Type = ($BasicParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicParticleType_ = $BasicParticleType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"

export class $MutableArmorTier implements $ArmorMaterial {
readonly "parent": $ArmorMaterial

constructor(id: string, p: $ArmorMaterial$Type)

public "setName"(name: string): void
public "setEquipSound"(e: $SoundEvent$Type): void
public "setSlotProtections"(p: (integer)[]): void
public "setToughness"(f: float): void
public "getDefenseForType"(equipmentSlot: $ArmorItem$Type$Type): integer
public "getEnchantmentValue"(): integer
public "getName"(): string
public "getToughness"(): float
public "getKnockbackResistance"(): float
public "getEquipSound"(): $SoundEvent
public "getVanillaRepairIngredient"(): $Ingredient
public "getDurabilityForType"(equipmentSlot: $ArmorItem$Type$Type): integer
public "setRepairIngredient"(arg0: $Ingredient$Type): void
public "setEnchantmentValue"(i: integer): void
public "setDurabilityMultiplier"(m: integer): void
public "setKnockbackResistance"(f: float): void
set "name"(value: string)
set "equipSound"(value: $SoundEvent$Type)
set "slotProtections"(value: (integer)[])
set "toughness"(value: float)
get "enchantmentValue"(): integer
get "name"(): string
get "toughness"(): float
get "knockbackResistance"(): float
get "equipSound"(): $SoundEvent
get "vanillaRepairIngredient"(): $Ingredient
set "repairIngredient"(value: $Ingredient$Type)
set "enchantmentValue"(value: integer)
set "durabilityMultiplier"(value: integer)
set "knockbackResistance"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableArmorTier$Type = ($MutableArmorTier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableArmorTier_ = $MutableArmorTier$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptsLoadedEvent" {
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptsLoadedEvent {
static readonly "EVENT": $Event<($Runnable)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptsLoadedEvent$Type = ($ScriptsLoadedEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptsLoadedEvent_ = $ScriptsLoadedEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemStackSet" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $ItemStackSet implements $Iterable<($ItemStack)> {

constructor(...items: ($ItemStack$Type)[])
constructor()
constructor(initialSize: integer)

public "add"(stack: $ItemStack$Type): void
public "remove"(stack: $ItemStack$Type): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): ($ItemStack)[]
public "iterator"(): $Iterator<($ItemStack)>
public "toList"(): $List<($ItemStack)>
public "contains"(stack: $ItemStack$Type): boolean
public "forEach"(action: $Consumer$Type<(any)>): void
public "getFirst"(): $ItemStack
public "addItem"(item: $Item$Type): void
public "spliterator"(): $Spliterator<($ItemStack)>
[Symbol.iterator](): IterableIterator<$ItemStack>;
get "empty"(): boolean
get "first"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackSet$Type = ($ItemStackSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackSet_ = $ItemStackSet$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$GeneratorState" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GeneratorState {
static readonly "GENERATOR_SEND": integer
static readonly "GENERATOR_THROW": integer
static readonly "GENERATOR_CLOSE": integer


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratorState$Type = ($GeneratorState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratorState_ = $GeneratorState$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$MissingRecipeFunctionException" {
import {$RecipeExceptionJS, $RecipeExceptionJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeExceptionJS"

export class $MissingRecipeFunctionException extends $RecipeExceptionJS {
 "error": boolean

constructor(message: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MissingRecipeFunctionException$Type = ($MissingRecipeFunctionException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MissingRecipeFunctionException_ = $MissingRecipeFunctionException$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$UnaryOpUnit" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $UnaryOpUnit extends $Unit {
readonly "symbol": $UnitSymbol
 "unit": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(symbol: $UnitSymbol$Type, unit: $Unit$Type)

public "toString"(builder: $StringBuilder$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnaryOpUnit$Type = ($UnaryOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnaryOpUnit_ = $UnaryOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$KubeJSErrorScreen" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConsoleLine, $ConsoleLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"

export class $KubeJSErrorScreen extends $Screen {
readonly "lastScreen": $Screen
readonly "scriptType": $ScriptType
readonly "logFile": $Path
readonly "errors": $List<($ConsoleLine)>
readonly "warnings": $List<($ConsoleLine)>
 "viewing": $List<($ConsoleLine)>
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(lastScreen: $Screen$Type, scriptType: $ScriptType$Type, logFile: $Path$Type, errors: $List$Type<($ConsoleLine$Type)>, warnings: $List$Type<($ConsoleLine$Type)>)
constructor(lastScreen: $Screen$Type, console: $ConsoleJS$Type)

public "getNarrationMessage"(): $Component
public "shouldCloseOnEsc"(): boolean
public "onClose"(): void
public "render"(guiGraphics: $GuiGraphics$Type, mx: integer, my: integer, delta: float): void
get "narrationMessage"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSErrorScreen$Type = ($KubeJSErrorScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSErrorScreen_ = $KubeJSErrorScreen$Type;
}}
declare module "packages/dev/latvian/mods/unit/$VariableSet" {
import {$MutableNumberUnit, $MutableNumberUnit$Type} from "packages/dev/latvian/mods/unit/$MutableNumberUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $VariableSet implements $UnitVariables {

constructor()

public "get"(entry: string): $Unit
public "set"(name: string, value: $Unit$Type): $VariableSet
public "set"(name: string, value: double): $VariableSet
public "createSubset"(): $VariableSet
public "getVariables"(): $VariableSet
public "setMutable"(name: string, initialValue: double): $MutableNumberUnit
get "variables"(): $VariableSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableSet$Type = ($VariableSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableSet_ = $VariableSet$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$BitOrOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $BitOrOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BitOrOpUnit$Type = ($BitOrOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BitOrOpUnit_ = $BitOrOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$AstSymbol" {
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"

export class $AstSymbol {

constructor(declType: integer, name: string)

public "getName"(): string
public "toString"(): string
public "setName"(name: string): void
public "getIndex"(): integer
public "setIndex"(index: integer): void
public "getDeclType"(): integer
public "setContainingTable"(containingTable: $Scope$Type): void
public "getContainingTable"(): $Scope
public "setDeclType"(declType: integer): void
public "getDeclTypeName"(): string
get "name"(): string
set "name"(value: string)
get "index"(): integer
set "index"(value: integer)
get "declType"(): integer
set "containingTable"(value: $Scope$Type)
get "containingTable"(): $Scope
set "declType"(value: integer)
get "declTypeName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AstSymbol$Type = ($AstSymbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AstSymbol_ = $AstSymbol$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptRuntimeES6" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"

export class $ScriptRuntimeES6 {

constructor()

public static "requireObjectCoercible"(cx: $Context$Type, val: any, idFuncObj: $IdFunctionObject$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptRuntimeES6$Type = ($ScriptRuntimeES6);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptRuntimeES6_ = $ScriptRuntimeES6$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$DoubleHelper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DoubleHelper {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleHelper$Type = ($DoubleHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleHelper_ = $DoubleHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$CanBeReplacedCallbackJS" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $CanBeReplacedCallbackJS {

constructor(blockPlaceContext: $BlockPlaceContext$Type, state: $BlockState$Type)

public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "getRotation"(): float
public "canBeReplaced"(): boolean
public "getClickLocation"(): $Vec3
public "getClickedFace"(): $Direction
public "isClickedPosIn"(fluid: $Fluid$Type): boolean
public "getClickedPos"(): $BlockPos
public "getClickedBlock"(): $BlockContainerJS
public "getHand"(): $InteractionHand
public "getPlayer"(): $Player
public "isInside"(): boolean
public "getNearestLookingDirections"(): ($Direction)[]
public "getNearestLookingDirection"(): $Direction
public "getNearestLookingVerticalDirection"(): $Direction
public "isSecondaryUseActive"(): boolean
public "getFluidStateAtClickedPos"(): $FluidState
public "getHorizontalDirection"(): $Direction
get "level"(): $Level
get "item"(): $ItemStack
get "rotation"(): float
get "clickLocation"(): $Vec3
get "clickedFace"(): $Direction
get "clickedPos"(): $BlockPos
get "clickedBlock"(): $BlockContainerJS
get "hand"(): $InteractionHand
get "player"(): $Player
get "inside"(): boolean
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "nearestLookingVerticalDirection"(): $Direction
get "secondaryUseActive"(): boolean
get "fluidStateAtClickedPos"(): $FluidState
get "horizontalDirection"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanBeReplacedCallbackJS$Type = ($CanBeReplacedCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CanBeReplacedCallbackJS_ = $CanBeReplacedCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$RgbFuncUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $RgbFuncUnit extends $FuncUnit {
static readonly "FACTORY": $FunctionFactory
 "r": $Unit
 "g": $Unit
 "b": $Unit
 "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RgbFuncUnit$Type = ($RgbFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RgbFuncUnit_ = $RgbFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/wrapper/$UUIDWrapper" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export interface $UUIDWrapper {

}

export namespace $UUIDWrapper {
function toString(id: $UUID$Type): string
function digits(sb: $StringBuilder$Type, val: long, digits: integer): void
function fromString(o: any): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UUIDWrapper$Type = ($UUIDWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UUIDWrapper_ = $UUIDWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NodeTransformer" {
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"

export class $NodeTransformer {

constructor()

public "transform"(tree: $ScriptNode$Type, env: $CompilerEnvirons$Type): void
public "transform"(tree: $ScriptNode$Type, inStrictMode: boolean, env: $CompilerEnvirons$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NodeTransformer$Type = ($NodeTransformer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NodeTransformer_ = $NodeTransformer$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$ClassDef" {
import {$MojangMappings, $MojangMappings$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings"
import {$MojangMappings$TypeDef, $MojangMappings$TypeDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$TypeDef"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$MojangMappings$NamedSignature, $MojangMappings$NamedSignature$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$NamedSignature"
import {$MojangMappings$MemberDef, $MojangMappings$MemberDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MemberDef"
import {$MutableObject, $MutableObject$Type} from "packages/org/apache/commons/lang3/mutable/$MutableObject"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MojangMappings$ClassDef {
readonly "mappings": $MojangMappings
readonly "rawName": string
readonly "mmName": string
readonly "displayName": string
readonly "members": $Map<($MojangMappings$NamedSignature), ($MojangMappings$MemberDef)>
readonly "ignoredMembers": $Set<($MojangMappings$NamedSignature)>
 "mapped": boolean
 "noArrayType": $MojangMappings$TypeDef
 "rawDescriptor": string

constructor(mappings: $MojangMappings$Type, rawName: string, mmName: string, members: $Map$Type<($MojangMappings$NamedSignature$Type), ($MojangMappings$MemberDef$Type)>, ignoredMembers: $Set$Type<($MojangMappings$NamedSignature$Type)>)
constructor(mappings: $MojangMappings$Type, name: string)

public "getRawDescriptor"(): string
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "descriptor"(s: string): $MojangMappings$ClassDef
public "cleanup"(): boolean
public "unmappedName"(): $MutableObject<(string)>
get "rawDescriptor"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$ClassDef$Type = ($MojangMappings$ClassDef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings$ClassDef_ = $MojangMappings$ClassDef$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ClassFileWriter" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ClassFileWriter$MHandle, $ClassFileWriter$MHandle$Type} from "packages/dev/latvian/mods/rhino/classfile/$ClassFileWriter$MHandle"

export class $ClassFileWriter {
static readonly "ACC_PUBLIC": short
static readonly "ACC_PRIVATE": short
static readonly "ACC_PROTECTED": short
static readonly "ACC_STATIC": short
static readonly "ACC_FINAL": short
static readonly "ACC_SUPER": short
static readonly "ACC_SYNCHRONIZED": short
static readonly "ACC_VOLATILE": short
static readonly "ACC_TRANSIENT": short
static readonly "ACC_NATIVE": short
static readonly "ACC_ABSTRACT": short

constructor(className: string, superClassName: string, sourceFileName: string)

public "add"(theOpCode: integer, theOperand1: integer, theOperand2: integer): void
public "add"(theOpCode: integer): void
public "add"(theOpCode: integer, theOperand: integer): void
public "add"(theOpCode: integer, className: string, fieldName: string, fieldType: string): void
public "add"(theOpCode: integer, className: string): void
public "write"(oStream: $OutputStream$Type): void
public "toByteArray"(): (byte)[]
public "getClassName"(): string
public "setFlags"(flags: short): void
public "stopMethod"(maxLocals: short): void
public "startMethod"(methodName: string, type: string, flags: short): void
public "addInvoke"(theOpCode: integer, className: string, methodName: string, methodType: string): void
public "addALoad"(local: integer): void
public "addLoadConstant"(k: string): void
public "addLoadConstant"(k: integer): void
public "addLoadConstant"(k: long): void
public "addLoadConstant"(k: float): void
public "addLoadConstant"(k: double): void
public "addDLoad"(local: integer): void
public "addPush"(k: string): void
public "addPush"(k: double): void
public "addPush"(k: long): void
public "addPush"(k: integer): void
public "addPush"(k: boolean): void
public "addLLoad"(local: integer): void
public "addFLoad"(local: integer): void
public "addILoad"(local: integer): void
public "addExceptionHandler"(startLabel: integer, endLabel: integer, handlerLabel: integer, catchClassName: string): void
public "addInterface"(interfaceName: string): void
public static "classNameToSignature"(name: string): string
public "addVariableDescriptor"(name: string, type: string, startPC: integer, register: integer): void
public "markTableSwitchDefault"(switchStart: integer): void
public "getCurrentCodeOffset"(): integer
public "markTableSwitchCase"(switchStart: integer, caseIndex: integer, stackTop: integer): void
public "markTableSwitchCase"(switchStart: integer, caseIndex: integer): void
public "isUnderStringSizeLimit"(k: string): boolean
public "addLineNumberEntry"(lineNumber: short): void
public "getLabelPC"(label: integer): integer
public "addLoadThis"(): void
public "addTableSwitch"(low: integer, high: integer): integer
public "addAStore"(local: integer): void
public "addInvokeDynamic"(methodName: string, methodType: string, bsm: $ClassFileWriter$MHandle$Type, ...bsmArgs: (any)[]): void
public "addLStore"(local: integer): void
public "setTableSwitchJump"(switchStart: integer, caseIndex: integer, jumpTarget: integer): void
public "addFStore"(local: integer): void
public "addDStore"(local: integer): void
public "addIStore"(local: integer): void
public "markLabel"(label: integer, stackTop: short): void
public "markLabel"(label: integer): void
public "markHandler"(theLabel: integer): void
public "acquireLabel"(): integer
public "getStackTop"(): short
public "adjustStackTop"(delta: integer): void
public "setStackTop"(n: short): void
public "addField"(fieldName: string, type: string, flags: short, value: long): void
public "addField"(fieldName: string, type: string, flags: short, value: integer): void
public "addField"(fieldName: string, type: string, flags: short): void
public "addField"(fieldName: string, type: string, flags: short, value: double): void
get "className"(): string
set "flags"(value: short)
get "currentCodeOffset"(): integer
get "stackTop"(): short
set "stackTop"(value: short)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFileWriter$Type = ($ClassFileWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFileWriter_ = $ClassFileWriter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AlwaysFalseRuleTest" {
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $AlwaysFalseRuleTest extends $RuleTest {
static readonly "INSTANCE": $AlwaysFalseRuleTest
static readonly "CODEC": $Codec<($AlwaysFalseRuleTest)>


public "test"(blockState: $BlockState$Type, random: $RandomSource$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlwaysFalseRuleTest$Type = ($AlwaysFalseRuleTest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlwaysFalseRuleTest_ = $AlwaysFalseRuleTest$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$Deletable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Deletable {

 "onDeletedByJS"(): void

(): void
}

export namespace $Deletable {
function deleteObject(o: any): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Deletable$Type = ($Deletable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Deletable_ = $Deletable$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$RemappedEnumConstant" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $RemappedEnumConstant {

 "getRemappedEnumConstantName"(): string

(): string
}

export namespace $RemappedEnumConstant {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappedEnumConstant$Type = ($RemappedEnumConstant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappedEnumConstant_ = $RemappedEnumConstant$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$MemberType" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MemberType extends $Enum<($MemberType)> {
static readonly "UNDEFINED": $MemberType
static readonly "OBJECT": $MemberType
static readonly "FUNCTION": $MemberType
static readonly "SYMBOL": $MemberType
static readonly "STRING": $MemberType
static readonly "NUMBER": $MemberType
static readonly "BOOLEAN": $MemberType


public static "get"(value: any, cx: $Context$Type): $MemberType
public "toString"(): string
public static "values"(): ($MemberType)[]
public static "valueOf"(name: string): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MemberType$Type = (("symbol") | ("number") | ("boolean") | ("string") | ("function") | ("undefined") | ("object")) | ($MemberType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MemberType_ = $MemberType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$BindingsEvent" {
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $BindingsEvent {
readonly "manager": $ScriptManager
readonly "scope": $Scriptable

constructor(m: $ScriptManager$Type, s: $Scriptable$Type)

public "add"(name: string, value: any): void
public "getType"(): $ScriptType
get "type"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BindingsEvent$Type = ($BindingsEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BindingsEvent_ = $BindingsEvent$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$NeqOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $NeqOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NeqOpUnit$Type = ($NeqOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NeqOpUnit_ = $NeqOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeWeakSet" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeWeakSet extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()

public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeWeakSet$Type = ($NativeWeakSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeWeakSet_ = $NativeWeakSet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$AxeItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HandheldItemBuilder, $HandheldItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AxeItemBuilder extends $HandheldItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AxeItemBuilder$Type = ($AxeItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AxeItemBuilder_ = $AxeItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$LivingEntityKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EntityKJS, $EntityKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$EntityKJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityPotionEffectsJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"

export interface $LivingEntityKJS extends $EntityKJS {

 "foodEaten"(is: $ItemStack$Type): void
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "isLiving"(): boolean
 "getEquipment"(slot: $EquipmentSlot$Type): $ItemStack
 "setEquipment"(slot: $EquipmentSlot$Type, item: $ItemStack$Type): void
 "swing"(): void
 "swing"(hand: $InteractionHand$Type): void
 "setOffHandItem"(item: $ItemStack$Type): void
 "getOffHandItem"(): $ItemStack
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(hand: $InteractionHand$Type, item: $ItemStack$Type): void
 "getHeldItem"(hand: $InteractionHand$Type): $ItemStack
 "rayTrace"(): $RayTraceResultJS
 "getHeadArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getDefaultMovementSpeed"(): double
 "getReachDistance"(): double
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setMovementSpeedAddition"(speed: double): void
 "isHoldingInAnyHand"(i: $Ingredient$Type): boolean
 "setLegsArmorItem"(item: $ItemStack$Type): void
 "setFeetArmorItem"(item: $ItemStack$Type): void
 "setHeadArmorItem"(item: $ItemStack$Type): void
 "getMainHandItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "removeAttribute"(attribute: $Attribute$Type, identifier: string): void
 "setDefaultMovementSpeed"(speed: double): void
 "damageEquipment"(slot: $EquipmentSlot$Type): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "getAttributeBaseValue"(attribute: $Attribute$Type): double
 "setChestArmorItem"(item: $ItemStack$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getAttributeTotalValue"(attribute: $Attribute$Type): double
 "modifyAttribute"(attribute: $Attribute$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): void
 "setMainHandItem"(item: $ItemStack$Type): void
 "getChestArmorItem"(): $ItemStack
 "canEntityBeSeen"(entity: $LivingEntity$Type): boolean
 "setAttributeBaseValue"(attribute: $Attribute$Type, value: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "getProfile"(): $GameProfile
 "spawn"(): void
 "isPlayer"(): boolean
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getItem"(): $ItemStack
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$Type): void
}

export namespace $LivingEntityKJS {
const KJS_PLAYER_CUSTOM_SPEED: $UUID
const KJS_PLAYER_CUSTOM_SPEED_NAME: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityKJS$Type = ($LivingEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityKJS_ = $LivingEntityKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/generator/$DataJsonGenerator" {
import {$ResourceGenerator, $ResourceGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$ResourceGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DataJsonGenerator extends $ResourceGenerator {

constructor(m: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataJsonGenerator$Type = ($DataJsonGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataJsonGenerator_ = $DataJsonGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$TextWrapper" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ClickEvent, $ClickEvent$Type} from "packages/net/minecraft/network/chat/$ClickEvent"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

/**
 * The hub for all things text components. Format text to your hearts content!
 */
export class $TextWrapper {

constructor()

/**
 * Checks if the passed in component, and all its children are empty
 */
public static "isEmpty"(component: $Component$Type): boolean
/**
 * Joins all components
 */
public static "join"(...texts: ($Component$Type)[]): $MutableComponent
/**
 * Joins all components in the list with the separator component
 */
public static "join"(separator: $MutableComponent$Type, texts: $Iterable$Type<(any)>): $MutableComponent
/**
 * Returns a Component of the input
 */
public static "of"(o: $MutableComponent$Type): $MutableComponent
/**
 * Returns an empty component
 */
public static "empty"(): $MutableComponent
/**
 * Returns a component of the input, colored red
 */
public static "red"(text: any): $MutableComponent
/**
 * Returns a plain component of the passed in string, even if empty
 */
public static "string"(text: string): $MutableComponent
/**
 * Returns a plain component of the input
 */
public static "literal"(text: string): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector, with a custom separator
 */
public static "selector"(selector: string, separator: $Component$Type): $MutableComponent
/**
 * Returns a component displaying all entities matching the input selector
 */
public static "selector"(selector: string): $MutableComponent
/**
 * Returns a colorful representation of the input nbt. Useful for displaying NBT to the player
 */
public static "prettyPrintNbt"(tag: $Tag$Type): $Component
/**
 * Returns a component of the input, colored dark aqua
 */
public static "darkAqua"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored dark purple
 */
public static "darkPurple"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored dark blue
 */
public static "darkBlue"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored light purple
 */
public static "lightPurple"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored aqua
 */
public static "aqua"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored dark red
 */
public static "darkRed"(text: any): $MutableComponent
/**
 * Returns a keybinding component of the input keybinding descriptor
 */
public static "keybind"(keybind: string): $MutableComponent
/**
 * Returns a plain component of the string, or empty if it is an empty string
 */
public static "ofString"(s: string): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
public static "translatable"(key: string): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
public static "translatable"(key: string, ...objects: (any)[]): $MutableComponent
/**
 * Returns a score component of the input objective, for the provided selector
 */
public static "score"(selector: string, objective: string): $MutableComponent
/**
 * Returns a component of the input, colored black
 */
public static "black"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored blue
 */
public static "blue"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored green
 */
public static "green"(text: any): $MutableComponent
/**
 * Returns a translatable component of the input key, with args of the objects
 */
public static "translate"(key: string, ...objects: (any)[]): $MutableComponent
/**
 * Returns a translatable component of the input key
 */
public static "translate"(key: string): $MutableComponent
/**
 * Returns a component of the input, colored white
 */
public static "white"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored yellow
 */
public static "yellow"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored gold
 */
public static "gold"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored gray
 */
public static "gray"(text: any): $MutableComponent
/**
 * Returns a component of the input, colored dark gray
 */
public static "darkGray"(text: any): $MutableComponent
/**
 * Returns a ClickEvent of the input
 */
public static "clickEventOf"(o: any): $ClickEvent
/**
 * Returns a component of the input, colored dark green
 */
public static "darkGreen"(text: any): $MutableComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextWrapper$Type = ($TextWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextWrapper_ = $TextWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptableObject$SlotAccess" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ScriptableObject$SlotAccess extends $Enum<($ScriptableObject$SlotAccess)> {
static readonly "QUERY": $ScriptableObject$SlotAccess
static readonly "MODIFY": $ScriptableObject$SlotAccess
static readonly "MODIFY_CONST": $ScriptableObject$SlotAccess
static readonly "MODIFY_GETTER_SETTER": $ScriptableObject$SlotAccess
static readonly "CONVERT_ACCESSOR_TO_DATA": $ScriptableObject$SlotAccess


public static "values"(): ($ScriptableObject$SlotAccess)[]
public static "valueOf"(name: string): $ScriptableObject$SlotAccess
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptableObject$SlotAccess$Type = (("modify") | ("modify_const") | ("convert_accessor_to_data") | ("query") | ("modify_getter_setter")) | ($ScriptableObject$SlotAccess);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptableObject$SlotAccess_ = $ScriptableObject$SlotAccess$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/$LevelForgeHelper" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LevelPlatformHelper, $LevelPlatformHelper$Type} from "packages/dev/latvian/mods/kubejs/platform/$LevelPlatformHelper"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export class $LevelForgeHelper implements $LevelPlatformHelper {

constructor()

public "getReachDistance"(livingEntity: $LivingEntity$Type): double
public "getInventoryFromBlockEntity"(tileEntity: $BlockEntity$Type, facing: $Direction$Type): $InventoryKJS
public "areCapsCompatible"(a: $ItemStack$Type, b: $ItemStack$Type): boolean
public "createBlockEntity"(pos: $BlockPos$Type, state: $BlockState$Type, info: $BlockEntityInfo$Type): $BlockEntityJS
public static "get"(): $LevelPlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelForgeHelper$Type = ($LevelForgeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelForgeHelper_ = $LevelForgeHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/$MiscPlatformHelper" {
import {$KubeJSMenu, $KubeJSMenu$Type} from "packages/dev/latvian/mods/kubejs/gui/$KubeJSMenu"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeModeTab$DisplayItemsGenerator, $CreativeModeTab$DisplayItemsGenerator$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$DisplayItemsGenerator"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$PlatformWrapper$ModInfo, $PlatformWrapper$ModInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$PlatformWrapper$ModInfo"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"

export interface $MiscPlatformHelper {

 "isDataGen"(): boolean
 "creativeModeTab"(arg0: $Component$Type, arg1: $Supplier$Type<($ItemStack$Type)>, arg2: $CreativeModeTab$DisplayItemsGenerator$Type): $CreativeModeTab
 "ingotFluidAmount"(): long
 "bottleFluidAmount"(): long
 "setModName"(arg0: $PlatformWrapper$ModInfo$Type, arg1: string): void
 "createMenuType"(): $MenuType<($KubeJSMenu)>
 "getMobCategory"(arg0: string): $MobCategory
}

export namespace $MiscPlatformHelper {
const INSTANCE: $Lazy<($MiscPlatformHelper)>
function get(): $MiscPlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiscPlatformHelper$Type = ($MiscPlatformHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiscPlatformHelper_ = $MiscPlatformHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ServerLevelKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FireworksJS, $FireworksJS$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$WithPersistentData, $WithPersistentData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithPersistentData"
import {$ExplosionJS, $ExplosionJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$LevelKJS, $LevelKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$LevelKJS"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $ServerLevelKJS extends $LevelKJS, $WithPersistentData {

 "spawnLightning"(x: double, y: double, z: double, effectOnly: boolean): void
 "spawnLightning"(x: double, y: double, z: double, effectOnly: boolean, player: $ServerPlayer$Type): void
 "setTime"(time: long): void
 "getSide"(): $ScriptType
 "getEntities"(): $EntityArrayList
 "spawnParticles"(options: $ParticleOptions$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getBlock"(x: integer, y: integer, z: integer): $BlockContainerJS
 "getBlock"(pos: $BlockPos$Type): $BlockContainerJS
 "getBlock"(blockEntity: $BlockEntity$Type): $BlockContainerJS
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "createExplosion"(x: double, y: double, z: double): $ExplosionJS
 "getEntitiesWithin"(aabb: $AABB$Type): $EntityArrayList
 "createEntityList"(entities: $Collection$Type<(any)>): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "isOverworld"(): boolean
 "getDimension"(): $ResourceLocation
 "createEntity"(type: $EntityType$Type<(any)>): $Entity
 "spawnFireworks"(x: double, y: double, z: double, f: $FireworksJS$Type): void
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getPersistentData"(): $CompoundTag
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(x: double, y: double, z: double, effectOnly: boolean): void
}

export namespace $ServerLevelKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerLevelKJS$Type = ($ServerLevelKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerLevelKJS_ = $ServerLevelKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$CompilerEnvirons" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"

export class $CompilerEnvirons {

constructor()

public "setErrorReporter"(errorReporter: $ErrorReporter$Type): void
public "initFromContext"(cx: $Context$Type): void
public "isStrictMode"(): boolean
public "getErrorReporter"(): $ErrorReporter
set "errorReporter"(value: $ErrorReporter$Type)
get "strictMode"(): boolean
get "errorReporter"(): $ErrorReporter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompilerEnvirons$Type = ($CompilerEnvirons);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompilerEnvirons_ = $CompilerEnvirons$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$ValueUnwrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $ValueUnwrapper {

 "unwrap"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: any): any

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: any): any
}

export namespace $ValueUnwrapper {
const DEFAULT: $ValueUnwrapper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValueUnwrapper$Type = ($ValueUnwrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ValueUnwrapper_ = $ValueUnwrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$CatchClause" {
import {$Name, $Name$Type} from "packages/dev/latvian/mods/rhino/ast/$Name"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Block, $Block$Type} from "packages/dev/latvian/mods/rhino/ast/$Block"

export class $CatchClause extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getBody"(): $Block
public "setParens"(lp: integer, rp: integer): void
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "setVarName"(varName: $Name$Type): void
public "setCatchCondition"(catchCondition: $AstNode$Type): void
public "setIfPosition"(ifPosition: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "getIfPosition"(): integer
public "getCatchCondition"(): $AstNode
public "getVarName"(): $Name
public "setBody"(body: $Block$Type): void
get "body"(): $Block
set "lp"(value: integer)
set "rp"(value: integer)
set "varName"(value: $Name$Type)
set "catchCondition"(value: $AstNode$Type)
set "ifPosition"(value: integer)
get "lp"(): integer
get "rp"(): integer
get "ifPosition"(): integer
get "catchCondition"(): $AstNode
get "varName"(): $Name
set "body"(value: $Block$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CatchClause$Type = ($CatchClause);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CatchClause_ = $CatchClause$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$JSObjectType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $JSObjectType extends $Enum<($JSObjectType)> {
static readonly "ANY": $JSObjectType
static readonly "MAP": $JSObjectType
static readonly "LIST": $JSObjectType


public static "values"(): ($JSObjectType)[]
public static "valueOf"(name: string): $JSObjectType
public "checkList"(): boolean
public "checkMap"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSObjectType$Type = (("list") | ("any") | ("map")) | ($JSObjectType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSObjectType_ = $JSObjectType$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"

export interface $TypeWrapperFactory<T> {

 "wrap"(arg0: $Context$Type, arg1: any): T

(arg0: $Context$Type, arg1: any): T
}

export namespace $TypeWrapperFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeWrapperFactory$Type<T> = ($TypeWrapperFactory<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeWrapperFactory_<T> = $TypeWrapperFactory$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$BlockTintFunctionWrapper" {
import {$BlockTintFunction, $BlockTintFunction$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction"
import {$BlockColor, $BlockColor$Type} from "packages/net/minecraft/client/color/block/$BlockColor"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $BlockTintFunctionWrapper extends $Record implements $BlockColor {

constructor(arg0: $BlockTintFunction$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "function"(): $BlockTintFunction
public "getColor"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, index: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunctionWrapper$Type = ($BlockTintFunctionWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTintFunctionWrapper_ = $BlockTintFunctionWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export interface $BiomeFilter extends $Predicate<($BiomeModifications$BiomeContext)> {

 "test"(arg0: $BiomeModifications$BiomeContext$Type): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
 "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>

(arg0: $BiomeModifications$BiomeContext$Type): boolean
}

export namespace $BiomeFilter {
const ALWAYS_TRUE: $BiomeFilter
const ALWAYS_FALSE: $BiomeFilter
function of(cx: $Context$Type, o: any): $BiomeFilter
function idFilter(cx: $Context$Type, s: string): $BiomeFilter
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
function isEqual<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BiomeFilter$Type = ($BiomeFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BiomeFilter_ = $BiomeFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemPickedUpEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

/**
 * Invoked when a player picks up an item. Cancelling (in `ItemEvents.canPickUp`) will prevent the item from being picked up.
 */
export class $ItemPickedUpEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, entity: $ItemEntity$Type, stack: $ItemStack$Type)

/**
 * The item that was picked up.
 */
public "getItem"(): $ItemStack
/**
 * The item entity that was picked up.
 */
public "getItemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "itemEntity"(): $ItemEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemPickedUpEventJS$Type = ($ItemPickedUpEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemPickedUpEventJS_ = $ItemPickedUpEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ForLoop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Loop, $Loop$Type} from "packages/dev/latvian/mods/rhino/ast/$Loop"

export class $ForLoop extends $Loop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setCondition"(condition: $AstNode$Type): void
public "getIncrement"(): $AstNode
public "setIncrement"(increment: $AstNode$Type): void
public "setInitializer"(initializer: $AstNode$Type): void
public "getInitializer"(): $AstNode
public "getCondition"(): $AstNode
set "condition"(value: $AstNode$Type)
get "increment"(): $AstNode
set "increment"(value: $AstNode$Type)
set "initializer"(value: $AstNode$Type)
get "initializer"(): $AstNode
get "condition"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForLoop$Type = ($ForLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForLoop_ = $ForLoop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$MutableToolTier, $MutableToolTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableToolTier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $HandheldItemBuilder extends $ItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type, d: float, s: float)

/**
 * Sets the base attack speed of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of -2.4, while an axe has a baseline of -3.1.
 * 
 * The actual speed is the sum of the baseline and the speed from tier + 4 (bare hand).
 */
public "speedBaseline"(f: float): $HandheldItemBuilder
/**
 * Modifies the tool tier.
 */
public "modifyTier"(callback: $Consumer$Type<($MutableToolTier$Type)>): $HandheldItemBuilder
/**
 * Sets the attack damage bonus of the tool.
 */
public "attackDamageBonus"(f: float): $HandheldItemBuilder
/**
 * Sets the attack speed of the tool.
 */
public "speed"(f: float): $HandheldItemBuilder
public "tier"(t: $Tier$Type): $HandheldItemBuilder
/**
 * Sets the base attack damage of the tool. Different tools have different baselines.
 * 
 * For example, a sword has a baseline of 3, while an axe has a baseline of 6.
 * 
 * The actual damage is the sum of the baseline and the attackDamageBonus from tier.
 */
public "attackDamageBaseline"(f: float): $HandheldItemBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandheldItemBuilder$Type = ($HandheldItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandheldItemBuilder_ = $HandheldItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$CategoryFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $CategoryFilter extends $Record implements $MobFilter {

constructor(category: $MobCategory$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "category"(): $MobCategory
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CategoryFilter$Type = ($CategoryFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CategoryFilter_ = $CategoryFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$FireworksJS$Explosion" {
import {$FireworksJS$Shape, $FireworksJS$Shape$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS$Shape"
import {$IntOpenHashSet, $IntOpenHashSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntOpenHashSet"

export class $FireworksJS$Explosion {
 "shape": $FireworksJS$Shape
 "flicker": boolean
 "trail": boolean
readonly "colors": $IntOpenHashSet
readonly "fadeColors": $IntOpenHashSet

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworksJS$Explosion$Type = ($FireworksJS$Explosion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworksJS$Explosion_ = $FireworksJS$Explosion$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$IEventHandler" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"

export interface $IEventHandler {

 "onEvent"(arg0: $EventJS$Type): any

(arg0: $EventJS$Type): any
}

export namespace $IEventHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IEventHandler$Type = ($IEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IEventHandler_ = $IEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ListJS" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"

export interface $ListJS {

}

export namespace $ListJS {
function of(array: (short)[]): $List<(short)>
function of(array: (integer)[]): $List<(integer)>
function of(array: (long)[]): $List<(long)>
function of(array: (float)[]): $List<(float)>
function of(array: (double)[]): $List<(double)>
function of(array: (character)[]): $List<(character)>
function of(o: any): $List<(any)>
function of(array: (byte)[]): $List<(byte)>
function ofArray(array: any): $List<(any)>
function json(array: any): $JsonArray
function orSelf(o: any): $List<(any)>
function orEmpty(o: any): $List<(any)>
function ofSet(o: any): $Set<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListJS$Type = ($ListJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListJS_ = $ListJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$NotFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $NotFilter extends $Record implements $RecipeFilter {

constructor(original: $RecipeFilter$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(r: $RecipeKJS$Type): boolean
public "original"(): $RecipeFilter
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotFilter$Type = ($NotFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotFilter_ = $NotFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeError" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export class $NativeError extends $IdScriptableObject {
static readonly "DEFAULT_STACK_LIMIT": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type)

public "toString"(): string
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "setStackProvider"(re: $RhinoException$Type, cx: $Context$Type): void
public "setStackDelegated"(cx: $Context$Type, target: $Scriptable$Type, value: any): any
public "getStackDelegated"(cx: $Context$Type, target: $Scriptable$Type): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeError$Type = ($NativeError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeError_ = $NativeError$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$HideJEIEventJS" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"

export class $HideJEIEventJS<T> extends $EventJS {

constructor(r: $IJeiRuntime$Type, t: $IIngredientType$Type<(T)>, f: $Function$Type<(any), ($Predicate$Type<(T)>)>, i: $Predicate$Type<(T)>)

public "hideAll"(): void
public "hide"(o: any): void
public "getAllIngredients"(): $Collection<(T)>
get "allIngredients"(): $Collection<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HideJEIEventJS$Type<T> = ($HideJEIEventJS<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HideJEIEventJS_<T> = $HideJEIEventJS$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$JsonUtils" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"

export interface $JsonUtils {

}

export namespace $JsonUtils {
const GSON: $Gson
function toString(json: $JsonElement$Type): string
function of(o: any): $JsonElement
function copy(element: $JsonElement$Type): $JsonElement
function fromString(string: string): $JsonElement
function toPrettyString(json: $JsonElement$Type): string
function toPrimitive(element: $JsonElement$Type): any
function toObject(json: $JsonElement$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonUtils$Type = ($JsonUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonUtils_ = $JsonUtils$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$DynamicMap" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $DynamicMap<V> extends $HashMap<(string), (V)> {

constructor(f: $Function$Type<(string), (any)>)

public "get"(key: any): V
public "containsKey"(name: any): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicMap$Type<V> = ($DynamicMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicMap_<V> = $DynamicMap$Type<(V)>;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$DamageSourceWrapper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DamageSourceWrapper {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DamageSourceWrapper$Type = ($DamageSourceWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DamageSourceWrapper_ = $DamageSourceWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$EmptyItemError" {
import {$IllegalArgumentException, $IllegalArgumentException$Type} from "packages/java/lang/$IllegalArgumentException"

export class $EmptyItemError extends $IllegalArgumentException {
readonly "from": any

constructor(message: string, from: any)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyItemError$Type = ($EmptyItemError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyItemError_ = $EmptyItemError$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$PrimitiveDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export class $PrimitiveDescJS extends $Record implements $TypeDescJS {

constructor(type: string)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "build"(builder: $StringBuilder$Type): void
public "build"(): string
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimitiveDescJS$Type = ($PrimitiveDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PrimitiveDescJS_ = $PrimitiveDescJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$LevelEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export class $LevelEventJS extends $EventJS {

constructor()

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
get "level"(): $Level
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEventJS$Type = ($LevelEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEventJS_ = $LevelEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$TickDuration" {
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$TemporalUnit, $TemporalUnit$Type} from "packages/java/time/temporal/$TemporalUnit"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Temporal, $Temporal$Type} from "packages/java/time/temporal/$Temporal"

export class $TickDuration extends $Record implements $TemporalAmount {
static readonly "ZERO": $TickDuration

constructor(ticks: long)

public "get"(unit: $TemporalUnit$Type): long
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getUnits"(): $List<($TemporalUnit)>
public "addTo"(temporal: $Temporal$Type): $Temporal
public "subtractFrom"(temporal: $Temporal$Type): $Temporal
public "ticks"(): long
get "units"(): $List<($TemporalUnit)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickDuration$Type = ($TickDuration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickDuration_ = $TickDuration$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$UnaryOperatorFactory" {
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $UnaryOperatorFactory {

 "create"(arg0: $Unit$Type): $Unit

(arg0: $Unit$Type): $Unit
}

export namespace $UnaryOperatorFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnaryOperatorFactory$Type = ($UnaryOperatorFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnaryOperatorFactory_ = $UnaryOperatorFactory$Type;
}}
declare module "packages/dev/latvian/mods/rhino/annotations/$JSConstructor" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JSConstructor extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JSConstructor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSConstructor$Type = ($JSConstructor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSConstructor_ = $JSConstructor$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BlockEntityBuilder extends $BuilderBase<($BlockEntityType<(any)>)> {
 "info": $BlockEntityInfo
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type, info: $BlockEntityInfo$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityBuilder$Type = ($BlockEntityBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityBuilder_ = $BlockEntityBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$BlockItemBuilder, $BlockItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockItemBuilder"
import {$FluidBuilder, $FluidBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export class $FluidBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(b: $FluidBuilder$Type)

public "item"(i: $Consumer$Type<($BlockItemBuilder$Type)>): $BlockBuilder
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBlockBuilder$Type = ($FluidBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBlockBuilder_ = $FluidBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$CustomCommandEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $CustomCommandEventJS extends $EntityEventJS {

constructor(l: $Level$Type, e: $Entity$Type, p: $BlockPos$Type, i: string)

public "getId"(): string
public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getEntity"(): $Entity
get "id"(): string
get "level"(): $Level
get "block"(): $BlockContainerJS
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomCommandEventJS$Type = ($CustomCommandEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomCommandEventJS_ = $CustomCommandEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ClientInitEventJS" {
import {$EntityRendererProvider, $EntityRendererProvider$Type} from "packages/net/minecraft/client/renderer/entity/$EntityRendererProvider"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$MenuRegistry$ScreenFactory, $MenuRegistry$ScreenFactory$Type} from "packages/dev/architectury/registry/menu/$MenuRegistry$ScreenFactory"
import {$BlockEntityRendererProvider, $BlockEntityRendererProvider$Type} from "packages/net/minecraft/client/renderer/blockentity/$BlockEntityRendererProvider"
import {$ClientEventJS, $ClientEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$ClientEventJS"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"

export class $ClientInitEventJS extends $ClientEventJS {

constructor()

public "registerMenuScreen"(type: $MenuType$Type<(any)>, screenFactory: $MenuRegistry$ScreenFactory$Type<(any), (any)>): void
public "registerEntityRenderer"(type: $EntityType$Type<(any)>, renderer: $EntityRendererProvider$Type<(any)>): void
public "registerBlockEntityRenderer"(type: $BlockEntityType$Type<(any)>, renderer: $BlockEntityRendererProvider$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientInitEventJS$Type = ($ClientInitEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientInitEventJS_ = $ClientInitEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Hashtable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Hashtable$Entry, $Hashtable$Entry$Type} from "packages/dev/latvian/mods/rhino/$Hashtable$Entry"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $Hashtable implements $Iterable<($Hashtable$Entry)> {

constructor(cx: $Context$Type)

public "get"(cx: $Context$Type, key: any): any
public "put"(cx: $Context$Type, key: any, value: any): void
public "clear"(cx: $Context$Type): void
public "size"(): integer
public "iterator"(): $Iterator<($Hashtable$Entry)>
public "delete"(cx: $Context$Type, key: any): any
public "has"(cx: $Context$Type, key: any): boolean
public "spliterator"(): $Spliterator<($Hashtable$Entry)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Hashtable$Entry>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hashtable$Type = ($Hashtable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hashtable_ = $Hashtable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ScheduledClientEvent" {
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export class $ScheduledClientEvent extends $ScheduledEvents$ScheduledEvent {
readonly "client": $Minecraft
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "ofTicks": boolean
 "repeating": boolean
 "timer": long
 "endTime": long

constructor(client: $Minecraft$Type)

public static "make"(client: $Minecraft$Type): $ScheduledEvents
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledClientEvent$Type = ($ScheduledClientEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledClientEvent_ = $ScheduledClientEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder$SurviveCallback" {
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export interface $CropBlockBuilder$SurviveCallback {

 "survive"(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean

(arg0: $BlockState$Type, arg1: $LevelReader$Type, arg2: $BlockPos$Type): boolean
}

export namespace $CropBlockBuilder$SurviveCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$SurviveCallback$Type = ($CropBlockBuilder$SurviveCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder$SurviveCallback_ = $CropBlockBuilder$SurviveCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$CarpetBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $CarpetBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "texture"(texture: string): $CarpetBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CarpetBlockBuilder$Type = ($CarpetBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CarpetBlockBuilder_ = $CarpetBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$FoodBuilder" {
import {$FoodEatenEventJS, $FoodEatenEventJS$Type} from "packages/dev/latvian/mods/kubejs/item/$FoodEatenEventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $FoodBuilder {
 "eaten": $Consumer<($FoodEatenEventJS)>

constructor()
constructor(properties: $FoodProperties$Type)

public "build"(): $FoodProperties
/**
 * Sets whether the food is always edible.
 */
public "alwaysEdible"(flag: boolean): $FoodBuilder
/**
 * Sets the food is always edible.
 */
public "alwaysEdible"(): $FoodBuilder
/**
 * Sets a callback that is called when the food is eaten.
 * 
 * Note: This is currently not having effect in `ItemEvents.modification`,
 * as firing this callback requires an `ItemBuilder` instance in the `Item`.
 */
public "eaten"(e: $Consumer$Type<($FoodEatenEventJS$Type)>): $FoodBuilder
/**
 * Sets the saturation modifier. Note that the saturation restored is hunger * saturation.
 */
public "saturation"(s: float): $FoodBuilder
/**
 * Sets the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(): $FoodBuilder
/**
 * Sets whether the food is fast to eat (having half of the eating time).
 */
public "fastToEat"(flag: boolean): $FoodBuilder
/**
 * Removes an effect from the food.
 */
public "removeEffect"(mobEffect: $MobEffect$Type): $FoodBuilder
/**
 * Sets the food is meat.
 */
public "meat"(): $FoodBuilder
/**
 * Sets whether the food is meat.
 */
public "meat"(flag: boolean): $FoodBuilder
/**
 * Adds an effect to the food. Note that the effect duration is in ticks (20 ticks = 1 second).
 * 
 * @param mobEffectId - The id of the effect. Can be either a string or a ResourceLocation.
 * @param duration - The duration of the effect in ticks.
 * @param amplifier - The amplifier of the effect. 0 means level 1, 1 means level 2, etc.
 * @param probability - The probability of the effect being applied. 1 = 100%.
 */
public "effect"(mobEffectId: $ResourceLocation$Type, duration: integer, amplifier: integer, probability: float): $FoodBuilder
/**
 * Sets the hunger restored.
 */
public "hunger"(h: integer): $FoodBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodBuilder$Type = ($FoodBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FoodBuilder_ = $FoodBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$DynamicFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$DynamicFunction$Callback, $DynamicFunction$Callback$Type} from "packages/dev/latvian/mods/rhino/util/$DynamicFunction$Callback"

export class $DynamicFunction extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(f: $DynamicFunction$Callback$Type)

public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicFunction$Type = ($DynamicFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicFunction_ = $DynamicFunction$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$OperatorFactory" {
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $OperatorFactory {

 "create"(arg0: $Unit$Type, arg1: $Unit$Type): $Unit

(arg0: $Unit$Type, arg1: $Unit$Type): $Unit
}

export namespace $OperatorFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OperatorFactory$Type = ($OperatorFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OperatorFactory_ = $OperatorFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent" {
import {$DynamicRecipeComponent$Factory, $DynamicRecipeComponent$Factory$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent$Factory"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"

export class $DynamicRecipeComponent extends $Record {

constructor(desc: $TypeDescJS$Type, factory: $DynamicRecipeComponent$Factory$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $DynamicRecipeComponent$Factory
public "desc"(): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicRecipeComponent$Type = ($DynamicRecipeComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicRecipeComponent_ = $DynamicRecipeComponent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$OrFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $OrFilter implements $RecipeFilter {
readonly "list": $List<($RecipeFilter)>

constructor()

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrFilter$Type = ($OrFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrFilter_ = $OrFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$ItemTooltipEventJS$StaticTooltipHandler, $ItemTooltipEventJS$StaticTooltipHandler$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS$StaticTooltipHandler"
import {$ItemTooltipEventJS$StaticTooltipHandlerFromJS, $ItemTooltipEventJS$StaticTooltipHandlerFromJS$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS$StaticTooltipHandlerFromJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * Invoked when registering handlers for item tooltips.
 * 
 * `text` can be a component or a list of components.
 */
export class $ItemTooltipEventJS extends $EventJS {

constructor(m: $Map$Type<($Item$Type), ($List$Type<($ItemTooltipEventJS$StaticTooltipHandler$Type)>)>)

/**
 * Adds text to all items matching the ingredient.
 */
public "add"(item: $Ingredient$Type, text: any): void
/**
 * Adds a dynamic tooltip handler to all items matching the ingredient.
 */
public "addAdvanced"(item: $Ingredient$Type, handler: $ItemTooltipEventJS$StaticTooltipHandlerFromJS$Type): void
/**
 * Adds a dynamic tooltip handler to all items.
 */
public "addAdvancedToAll"(handler: $ItemTooltipEventJS$StaticTooltipHandlerFromJS$Type): void
/**
 * Adds text to all items.
 */
public "addToAll"(text: any): void
/**
 * Is shift key pressed.
 */
public "isShift"(): boolean
/**
 * Is alt key pressed.
 */
public "isAlt"(): boolean
/**
 * Is control key pressed.
 */
public "isCtrl"(): boolean
get "shift"(): boolean
get "alt"(): boolean
get "ctrl"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipEventJS$Type = ($ItemTooltipEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTooltipEventJS_ = $ItemTooltipEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickHandler" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ChestMenuClickEvent, $ChestMenuClickEvent$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ChestMenuClickEvent$Callback, $ChestMenuClickEvent$Callback$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent$Callback"

export class $ChestMenuClickHandler extends $Record {

constructor(type: $ClickType$Type, button: integer, callback: $ChestMenuClickEvent$Callback$Type, autoHandle: boolean)

public "type"(): $ClickType
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(event: $ChestMenuClickEvent$Type): boolean
public "callback"(): $ChestMenuClickEvent$Callback
public "button"(): integer
public "autoHandle"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickHandler$Type = ($ChestMenuClickHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickHandler_ = $ChestMenuClickHandler$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$RshOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $RshOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RshOpUnit$Type = ($RshOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RshOpUnit_ = $RshOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$UnaryExpression" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $UnaryExpression extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(operator: integer, operatorPosition: integer, operand: $AstNode$Type, postFix: boolean)
constructor(operator: integer, operatorPosition: integer, operand: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getOperator"(): integer
public "setOperator"(operator: integer): void
public "setOperand"(operand: $AstNode$Type): void
public "setIsPostfix"(isPostfix: boolean): void
public "isPrefix"(): boolean
public "getOperand"(): $AstNode
public "isPostfix"(): boolean
get "operator"(): integer
set "operator"(value: integer)
set "operand"(value: $AstNode$Type)
get "prefix"(): boolean
get "operand"(): $AstNode
get "postfix"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnaryExpression$Type = ($UnaryExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnaryExpression_ = $UnaryExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$BuilderType" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$BuilderFactory, $BuilderFactory$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderFactory"

export class $BuilderType<T> extends $Record {

constructor(type: string, builderClass: $Class$Type<(any)>, factory: $BuilderFactory$Type)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $BuilderFactory
public "builderClass"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderType$Type<T> = ($BuilderType<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderType_<T> = $BuilderType$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/color/$SimpleColor" {
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export class $SimpleColor implements $Color {
static readonly "BLACK": $SimpleColor
static readonly "WHITE": $SimpleColor

constructor(v: integer)

public "toString"(): string
public "createTextColorJS"(): $TextColor
public "getArgbJS"(): integer
public "getHexJS"(): string
public "getRgbJS"(): integer
public "getSerializeJS"(): string
public "getFireworkColorJS"(): integer
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
get "argbJS"(): integer
get "hexJS"(): string
get "rgbJS"(): integer
get "serializeJS"(): string
get "fireworkColorJS"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleColor$Type = ($SimpleColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleColor_ = $SimpleColor$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Jump" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $Jump extends $AstNode {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(type: integer, child: $Node$Type, lineno: integer)
constructor(type: integer, child: $Node$Type)
constructor(type: integer, lineno: integer)
constructor(nodeType: integer)
constructor()

public "getDefault"(): $Node
public "setDefault"(defaultTarget: $Node$Type): void
public "setLoop"(loop: $Jump$Type): void
public "getLoop"(): $Jump
public "getContinue"(): $Node
public "setJumpStatement"(jumpStatement: $Jump$Type): void
public "getJumpStatement"(): $Jump
public "getFinally"(): $Node
public "setContinue"(continueTarget: $Node$Type): void
public "setFinally"(finallyTarget: $Node$Type): void
get "default"(): $Node
set "default"(value: $Node$Type)
set "loop"(value: $Jump$Type)
get "loop"(): $Jump
get "continue"(): $Node
set "jumpStatement"(value: $Jump$Type)
get "jumpStatement"(): $Jump
get "finally"(): $Node
set "continue"(value: $Node$Type)
set "finally"(value: $Node$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Jump$Type = ($Jump);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Jump_ = $Jump$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$UniqueTag" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UniqueTag {
static readonly "NOT_FOUND": $UniqueTag
static readonly "NULL_VALUE": $UniqueTag
static readonly "DOUBLE_MARK": $UniqueTag


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UniqueTag$Type = ($UniqueTag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UniqueTag_ = $UniqueTag$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$IngredientWrapper" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$CustomIngredientActionCallback, $CustomIngredientActionCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$CustomIngredientActionCallback"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

/**
 * Various Ingredient related helper methods
 */
export interface $IngredientWrapper {

}

export namespace $IngredientWrapper {
const none: $Ingredient
const all: $Ingredient
function of(ingredient: $Ingredient$Type): $Ingredient
function of(ingredient: $Ingredient$Type, count: integer): $InputItem
function registerCustomIngredientAction(id: string, callback: $CustomIngredientActionCallback$Type): void
function isIngredient(o: any): boolean
function custom(parent: $Ingredient$Type, predicate: $Predicate$Type<($ItemStack$Type)>): $Ingredient
function custom(predicate: $Predicate$Type<($ItemStack$Type)>): $Ingredient
function customNBT(arg0: $Ingredient$Type, predicate: $Predicate$Type<($CompoundTag$Type)>): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWrapper$Type = ($IngredientWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientWrapper_ = $IngredientWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeWeakMap" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeWeakMap extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()

public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeWeakMap$Type = ($NativeWeakMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeWeakMap_ = $NativeWeakMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilterParseEvent" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeFilterParseEvent {

 "parse"(arg0: $Context$Type, arg1: $List$Type<($RecipeFilter$Type)>, arg2: $Map$Type<(any), (any)>): void

(arg0: $Context$Type, arg1: $List$Type<($RecipeFilter$Type)>, arg2: $Map$Type<(any), (any)>): void
}

export namespace $RecipeFilterParseEvent {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilterParseEvent$Type = ($RecipeFilterParseEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFilterParseEvent_ = $RecipeFilterParseEvent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Arguments" {
import {$NativeCall, $NativeCall$Type} from "packages/dev/latvian/mods/rhino/$NativeCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $Arguments extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(activation: $NativeCall$Type, cx: $Context$Type)

public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, index: integer): void
public "getClassName"(): string
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Arguments$Type = ($Arguments);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Arguments_ = $Arguments$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$PotionBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$Potion, $Potion$Type} from "packages/net/minecraft/world/item/alchemy/$Potion"

export class $PotionBuilder extends $BuilderBase<($Potion)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
public "effect"(effect: $MobEffect$Type, duration: integer): $PotionBuilder
public "effect"(effect: $MobEffect$Type, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: $MobEffectInstance$Type): $PotionBuilder
public "effect"(effect: $MobEffect$Type, duration: integer, amplifier: integer, ambient: boolean, visible: boolean, showIcon: boolean): $PotionBuilder
public "effect"(effect: $MobEffect$Type, duration: integer, amplifier: integer, ambient: boolean, visible: boolean): $PotionBuilder
public "effect"(effect: $MobEffect$Type): $PotionBuilder
public "effect"(effect: $MobEffect$Type, duration: integer, amplifier: integer): $PotionBuilder
public "addEffect"(effect: $MobEffectInstance$Type): $PotionBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PotionBuilder$Type = ($PotionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PotionBuilder_ = $PotionBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$VariantBlockStateGenerator, $VariantBlockStateGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator"
import {$MultipartBlockStateGenerator, $MultipartBlockStateGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$MultipartBlockStateGenerator"
import {$ResourceGenerator, $ResourceGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$ResourceGenerator"
import {$ModelGenerator, $ModelGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$ModelGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AssetJsonGenerator extends $ResourceGenerator {

constructor(m: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>)

public "multipartState"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($MultipartBlockStateGenerator$Type)>): void
public "blockModel"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($ModelGenerator$Type)>): void
public "itemModel"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($ModelGenerator$Type)>): void
public "blockState"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($VariantBlockStateGenerator$Type)>): void
public "stencil"(target: $ResourceLocation$Type, stencil: string, colors: $JsonObject$Type): void
public static "asItemModelLocation"(id: $ResourceLocation$Type): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AssetJsonGenerator$Type = ($AssetJsonGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AssetJsonGenerator_ = $AssetJsonGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/command/$ArgumentFunction" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"

export interface $ArgumentFunction<U> {

 "getResult"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>, arg1: string): U

(arg0: $CommandContext$Type<($CommandSourceStack$Type)>, arg1: string): U
}

export namespace $ArgumentFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentFunction$Type<U> = ($ArgumentFunction<(U)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArgumentFunction_<U> = $ArgumentFunction$Type<(U)>;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$KubeJSResourcePackFinder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RepositorySource, $RepositorySource$Type} from "packages/net/minecraft/server/packs/repository/$RepositorySource"
import {$Pack, $Pack$Type} from "packages/net/minecraft/server/packs/repository/$Pack"

export class $KubeJSResourcePackFinder implements $RepositorySource {

constructor()

public "loadPacks"(nameToPackMap: $Consumer$Type<($Pack$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSResourcePackFinder$Type = ($KubeJSResourcePackFinder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSResourcePackFinder_ = $KubeJSResourcePackFinder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$BreakStatement" {
import {$Name, $Name$Type} from "packages/dev/latvian/mods/rhino/ast/$Name"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Jump, $Jump$Type} from "packages/dev/latvian/mods/rhino/ast/$Jump"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $BreakStatement extends $Jump {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setBreakLabel"(label: $Name$Type): void
public "setBreakTarget"(target: $Jump$Type): void
public "getBreakTarget"(): $AstNode
public "getBreakLabel"(): $Name
set "breakLabel"(value: $Name$Type)
set "breakTarget"(value: $Jump$Type)
get "breakTarget"(): $AstNode
get "breakLabel"(): $Name
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BreakStatement$Type = ($BreakStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BreakStatement_ = $BreakStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$DetectorBlock$Builder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $DetectorBlock$Builder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "detectorId"(id: string): $DetectorBlock$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Builder$Type = ($DetectorBlock$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DetectorBlock$Builder_ = $DetectorBlock$Builder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$DiyFp" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DiyFp {


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiyFp$Type = ($DiyFp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiyFp_ = $DiyFp$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptTypePredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptTypePredicate extends $Predicate<($ScriptType)> {

 "test"(arg0: $ScriptType$Type): boolean
 "getValidTypes"(): $List<($ScriptType)>
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>
 "negate"(): $Predicate<($ScriptType)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>

(arg0: $ScriptType$Type): boolean
}

export namespace $ScriptTypePredicate {
const ALL: $ScriptTypePredicate
const COMMON: $ScriptTypePredicate
const STARTUP_OR_CLIENT: $ScriptTypePredicate
const STARTUP_OR_SERVER: $ScriptTypePredicate
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>
function isEqual<T>(arg0: any): $Predicate<($ScriptType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptTypePredicate$Type = ($ScriptTypePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptTypePredicate_ = $ScriptTypePredicate$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$PostfixUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $PostfixUnitToken extends $Record implements $UnitToken {

constructor(infix: $List$Type<($UnitToken$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "normalize"(): $UnitToken
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "infix"(): $List<($UnitToken)>
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PostfixUnitToken$Type = ($PostfixUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PostfixUnitToken_ = $PostfixUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockPlacedEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * Invoked when a block is placed.
 */
export class $BlockPlacedEventJS extends $EntityEventJS {

constructor(entity: $Entity$Type, level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type)

/**
 * The level of the block that was placed.
 */
public "getLevel"(): $Level
/**
 * The block that is placed.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The entity that placed the block. Can be `null`, e.g. when a block is placed by a dispenser.
 */
public "getEntity"(): $Entity
get "level"(): $Level
get "block"(): $BlockContainerJS
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPlacedEventJS$Type = ($BlockPlacedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPlacedEventJS_ = $BlockPlacedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$LootTableEntry" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConditionalFunction, $ConditionalFunction$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionalFunction"
import {$ConditionContainer, $ConditionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionContainer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FunctionContainer, $FunctionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$FunctionContainer"
import {$CopyNameFunction$NameSource, $CopyNameFunction$NameSource$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$CopyNameFunction$NameSource"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LootTableEntry implements $FunctionContainer, $ConditionContainer {
readonly "json": $JsonObject

constructor(o: $JsonObject$Type)

public "addCondition"(o: $JsonObject$Type): $LootTableEntry
public "addFunction"(o: $JsonObject$Type): $LootTableEntry
public "quality"(quality: integer): $LootTableEntry
public "weight"(weight: integer): $LootTableEntry
public "name"(name: $Component$Type): $FunctionContainer
public "name"(name: $Component$Type, entity: $LootContext$EntityTarget$Type): $FunctionContainer
public "count"(count: $NumberProvider$Type): $FunctionContainer
public "damage"(damage: $NumberProvider$Type): $FunctionContainer
public "nbt"(tag: $CompoundTag$Type): $FunctionContainer
public "addConditionalFunction"(func: $Consumer$Type<($ConditionalFunction$Type)>): $FunctionContainer
public "furnaceSmelt"(): $FunctionContainer
public "copyName"(source: $CopyNameFunction$NameSource$Type): $FunctionContainer
public "lootingEnchant"(count: $NumberProvider$Type, limit: integer): $FunctionContainer
public "enchantWithLevels"(levels: $NumberProvider$Type, treasure: boolean): $FunctionContainer
public "enchantRandomly"(enchantments: ($ResourceLocation$Type)[]): $FunctionContainer
public "lootTable"(table: $ResourceLocation$Type, seed: long): $FunctionContainer
public "survivesExplosion"(): $ConditionContainer
public "randomChance"(chance: double): $ConditionContainer
public "randomChanceWithLooting"(chance: double, multiplier: double): $ConditionContainer
public "entityScores"(entity: $LootContext$EntityTarget$Type, scores: $Map$Type<(string), (any)>): $ConditionContainer
public "entityProperties"(entity: $LootContext$EntityTarget$Type, properties: $JsonObject$Type): $ConditionContainer
public "killedByPlayer"(): $ConditionContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTableEntry$Type = ($LootTableEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTableEntry_ = $LootTableEntry$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS$StaticTooltipHandlerFromJS" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ItemTooltipEventJS$StaticTooltipHandlerFromJS {

 "accept"(arg0: $ItemStack$Type, arg1: boolean, arg2: $List$Type<(any)>): void

(arg0: $ItemStack$Type, arg1: boolean, arg2: $List$Type<(any)>): void
}

export namespace $ItemTooltipEventJS$StaticTooltipHandlerFromJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipEventJS$StaticTooltipHandlerFromJS$Type = ($ItemTooltipEventJS$StaticTooltipHandlerFromJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTooltipEventJS$StaticTooltipHandlerFromJS_ = $ItemTooltipEventJS$StaticTooltipHandlerFromJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export interface $TypeDescJS {

 "build"(): string
 "build"(arg0: $StringBuilder$Type): void
 "or"(type: $TypeDescJS$Type): $TypeDescJS
 "asArray"(): $TypeDescJS
 "asMap"(): $TypeDescJS
 "asMap"(key: $TypeDescJS$Type): $TypeDescJS
 "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS

(init: integer): $ObjectDescJS
}

export namespace $TypeDescJS {
const ANY: $TypeDescJS
const NULL: $TypeDescJS
const STRING: $TypeDescJS
const NUMBER: $TypeDescJS
const BOOLEAN: $TypeDescJS
const MAP: $TypeDescJS
const ANY_MAP: $TypeDescJS
function object(init: integer): $ObjectDescJS
function object(): $ObjectDescJS
function any(...types: ($TypeDescJS$Type)[]): $TypeDescJS
function fixedArray(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeDescJS$Type = ($TypeDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeDescJS_ = $TypeDescJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$EntityKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$MessageSenderKJS, $MessageSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptTypeHolder, $ScriptTypeHolder$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypeHolder"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$WithPersistentData, $WithPersistentData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithPersistentData"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"

export interface $EntityKJS extends $WithPersistentData, $MessageSenderKJS, $ScriptTypeHolder {

 "self"(): $Entity
 "getProfile"(): $GameProfile
 "spawn"(): void
 "isPlayer"(): boolean
 "isLiving"(): boolean
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getItem"(): $ItemStack
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$Type): void
}

export namespace $EntityKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityKJS$Type = ($EntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityKJS_ = $EntityKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$EnumTypeWrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EnumTypeWrapper<T> implements $TypeWrapperFactory<(T)> {
readonly "enumType": $Class<(T)>
readonly "indexValues": (T)[]
readonly "nameValues": $Map<(string), (T)>
readonly "valueNames": $Map<(T), (string)>


public static "getName"(enumType: $Class$Type<(any)>, e: $Enum$Type<(any)>, cache: boolean): string
public static "get"<T>(enumType: $Class$Type<(T)>): $EnumTypeWrapper<(T)>
public "wrap"(cx: $Context$Type, o: any): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumTypeWrapper$Type<T> = ($EnumTypeWrapper<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumTypeWrapper_<T> = $EnumTypeWrapper$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo" {
import {$BlockEntityEventCallback, $BlockEntityEventCallback$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityEventCallback"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$CapabilityBuilder, $CapabilityBuilder$Type} from "packages/com/prunoideae/powerfuljs/$CapabilityBuilder"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BlockEntityCallback, $BlockEntityCallback$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityCallback"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockEntityInfo {

constructor(blockBuilder: $BlockBuilder$Type)

public "toString"(): string
public "eventHandler"(eventId: integer, callback: $BlockEntityEventCallback$Type): void
public "attach"(type: string, args: $Map$Type<(string), (any)>): void
public "tick"(frequency: integer, offset: integer, callback: $BlockEntityCallback$Type): void
public "tick"(callback: $BlockEntityCallback$Type): void
public "inventory"(width: integer, height: integer): void
public "inventory"(width: integer, height: integer, inputFilter: $Ingredient$Type): void
public "clientTick"(frequency: integer, offset: integer, callback: $BlockEntityCallback$Type): void
public "clientTick"(callback: $BlockEntityCallback$Type): void
public "attachCapability"(builder: $CapabilityBuilder$Type<(any), (any), (any)>): $BlockEntityInfo
public "initialData"(data: $CompoundTag$Type): void
public "serverTick"(callback: $BlockEntityCallback$Type): void
public "serverTick"(frequency: integer, offset: integer, callback: $BlockEntityCallback$Type): void
public "rightClickOpensInventory"(): void
public "enableSync"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityInfo$Type = ($BlockEntityInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityInfo_ = $BlockEntityInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS" {
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"

export class $RandomTickCallbackJS {
 "block": $BlockContainerJS
 "random": $RandomSource

constructor(containerJS: $BlockContainerJS$Type, random: $RandomSource$Type)

public "getLevel"(): $Level
public "getServer"(): $MinecraftServer
get "level"(): $Level
get "server"(): $MinecraftServer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RandomTickCallbackJS$Type = ($RandomTickCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RandomTickCallbackJS_ = $RandomTickCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$StringLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $StringLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "toString"(): string
public "getValue"(): string
public "getValue"(includeQuotes: boolean): string
public "setValue"(value: string): void
public "setQuoteCharacter"(c: character): void
public "getQuoteCharacter"(): character
get "value"(): string
set "value"(value: string)
set "quoteCharacter"(value: character)
get "quoteCharacter"(): character
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringLiteral$Type = ($StringLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringLiteral_ = $StringLiteral$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$SpecialSpoutHandlerEvent" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$SpecialSpoutHandlerEvent$SpoutHandler, $SpecialSpoutHandlerEvent$SpoutHandler$Type} from "packages/dev/latvian/mods/kubejs/create/events/$SpecialSpoutHandlerEvent$SpoutHandler"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $SpecialSpoutHandlerEvent extends $EventJS {

constructor()

public "add"(path: $ResourceLocation$Type, block: $BlockStatePredicate$Type, handler: $SpecialSpoutHandlerEvent$SpoutHandler$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialSpoutHandlerEvent$Type = ($SpecialSpoutHandlerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialSpoutHandlerEvent_ = $SpecialSpoutHandlerEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent$Factory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $DynamicRecipeComponent$Factory {

 "create"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Map$Type<(string), (any)>): $RecipeComponent<(any)>

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Map$Type<(string), (any)>): $RecipeComponent<(any)>
}

export namespace $DynamicRecipeComponent$Factory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicRecipeComponent$Factory$Type = ($DynamicRecipeComponent$Factory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicRecipeComponent$Factory_ = $DynamicRecipeComponent$Factory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ItemTintFunctionWrapper" {
import {$ItemTintFunction, $ItemTintFunction$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemTintFunction"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemColor, $ItemColor$Type} from "packages/net/minecraft/client/color/item/$ItemColor"

export class $ItemTintFunctionWrapper extends $Record implements $ItemColor {

constructor(arg0: $ItemTintFunction$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "function"(): $ItemTintFunction
public "getColor"(stack: $ItemStack$Type, index: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunctionWrapper$Type = ($ItemTintFunctionWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTintFunctionWrapper_ = $ItemTintFunctionWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$RECharSet" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RECharSet {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RECharSet$Type = ($RECharSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RECharSet_ = $RECharSet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$OrFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $OrFilter extends $Record implements $MobFilter {

constructor(list: $List$Type<($MobFilter$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "list"(): $List<($MobFilter)>
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrFilter$Type = ($OrFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrFilter_ = $OrFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$RefCallable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Ref, $Ref$Type} from "packages/dev/latvian/mods/rhino/$Ref"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $RefCallable extends $Callable {

 "refCall"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: (any)[]): $Ref
 "call"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Scriptable$Type, arg3: (any)[]): any
}

export namespace $RefCallable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RefCallable$Type = ($RefCallable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RefCallable_ = $RefCallable$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$GeneratorExpression" {
import {$GeneratorExpressionLoop, $GeneratorExpressionLoop$Type} from "packages/dev/latvian/mods/rhino/ast/$GeneratorExpressionLoop"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $GeneratorExpression extends $Scope {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setResult"(result: $AstNode$Type): void
public "getFilter"(): $AstNode
public "setFilter"(filter: $AstNode$Type): void
public "getResult"(): $AstNode
public "setIfPosition"(ifPosition: integer): void
public "setFilterRp"(rp: integer): void
public "setLoops"(loops: $List$Type<($GeneratorExpressionLoop$Type)>): void
public "setFilterLp"(lp: integer): void
public "getFilterLp"(): integer
public "getIfPosition"(): integer
public "getFilterRp"(): integer
public "getLoops"(): $List<($GeneratorExpressionLoop)>
public "addLoop"(acl: $GeneratorExpressionLoop$Type): void
set "result"(value: $AstNode$Type)
get "filter"(): $AstNode
set "filter"(value: $AstNode$Type)
get "result"(): $AstNode
set "ifPosition"(value: integer)
set "filterRp"(value: integer)
set "loops"(value: $List$Type<($GeneratorExpressionLoop$Type)>)
set "filterLp"(value: integer)
get "filterLp"(): integer
get "ifPosition"(): integer
get "filterRp"(): integer
get "loops"(): $List<($GeneratorExpressionLoop)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratorExpression$Type = ($GeneratorExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratorExpression_ = $GeneratorExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$AtlasSpriteRegistryEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AtlasSpriteRegistryEventJS extends $EventJS {

constructor(registry: $Consumer$Type<($ResourceLocation$Type)>)

public "register"(id: $ResourceLocation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasSpriteRegistryEventJS$Type = ($AtlasSpriteRegistryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtlasSpriteRegistryEventJS_ = $AtlasSpriteRegistryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptStackElement" {
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export class $ScriptStackElement {
readonly "fileName": string
readonly "functionName": string
readonly "lineNumber": integer

constructor(fileName: string, functionName: string, lineNumber: integer)

public "renderMozillaStyle"(sb: $StringBuilder$Type): void
public "toString"(): string
public "renderJavaStyle"(sb: $StringBuilder$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptStackElement$Type = ($ScriptStackElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptStackElement_ = $ScriptStackElement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$FireworksJS$Shape" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $FireworksJS$Shape extends $Enum<($FireworksJS$Shape)> {
static readonly "SMALL_BALL": $FireworksJS$Shape
static readonly "LARGE_BALL": $FireworksJS$Shape
static readonly "STAR": $FireworksJS$Shape
static readonly "CREEPER": $FireworksJS$Shape
static readonly "BURST": $FireworksJS$Shape
static readonly "VALUES": ($FireworksJS$Shape)[]
readonly "type": integer


public static "get"(name: string): $FireworksJS$Shape
public static "values"(): ($FireworksJS$Shape)[]
public static "valueOf"(name: string): $FireworksJS$Shape
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworksJS$Shape$Type = (("large_ball") | ("star") | ("burst") | ("creeper") | ("small_ball")) | ($FireworksJS$Shape);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworksJS$Shape_ = $FireworksJS$Shape$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidWrapper" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export class $FluidWrapper {
static readonly "WATER_ID": $ResourceLocation
static readonly "LAVA_ID": $ResourceLocation

constructor()

public static "of"(o: $FluidStackJS$Type): $FluidStackJS
public static "of"(o: $FluidStackJS$Type, amount: integer, nbt: $CompoundTag$Type): $FluidStackJS
public static "of"(o: $FluidStackJS$Type, nbt: $CompoundTag$Type): $FluidStackJS
public static "of"(o: $FluidStackJS$Type, amount: integer): $FluidStackJS
public static "getId"(fluid: $Fluid$Type): $ResourceLocation
public static "getType"(id: $ResourceLocation$Type): $Fluid
public static "exists"(id: $ResourceLocation$Type): boolean
public static "water"(): $FluidStackJS
public static "water"(amount: integer): $FluidStackJS
public static "getEmpty"(): $FluidStackJS
public static "getTypes"(): $List<(string)>
public static "lava"(amount: integer): $FluidStackJS
public static "lava"(): $FluidStackJS
get "empty"(): $FluidStackJS
get "types"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidWrapper$Type = ($FluidWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidWrapper_ = $FluidWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/ingredient/$IngredientJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export interface $IngredientJS {

}

export namespace $IngredientJS {
function of(o: any): $Ingredient
function parse(s: string): $Ingredient
function ofNetwork(buf: $FriendlyByteBuf$Type): $Ingredient
function ofJson(json: $JsonElement$Type): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientJS$Type = ($IngredientJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientJS_ = $IngredientJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$RegexIDFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $RegexIDFilter extends $Record implements $MobFilter {

constructor(pattern: $Pattern$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "pattern"(): $Pattern
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexIDFilter$Type = ($RegexIDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexIDFilter_ = $RegexIDFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeArrayIterator$ArrayIteratorType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $NativeArrayIterator$ArrayIteratorType extends $Enum<($NativeArrayIterator$ArrayIteratorType)> {
static readonly "ENTRIES": $NativeArrayIterator$ArrayIteratorType
static readonly "KEYS": $NativeArrayIterator$ArrayIteratorType
static readonly "VALUES": $NativeArrayIterator$ArrayIteratorType


public static "values"(): ($NativeArrayIterator$ArrayIteratorType)[]
public static "valueOf"(name: string): $NativeArrayIterator$ArrayIteratorType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeArrayIterator$ArrayIteratorType$Type = (("entries") | ("keys") | ("values")) | ($NativeArrayIterator$ArrayIteratorType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeArrayIterator$ArrayIteratorType_ = $NativeArrayIterator$ArrayIteratorType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventGroup" {
import {$ScriptTypePredicate, $ScriptTypePredicate$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypePredicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EventGroup {
readonly "name": string


public "add"(name: string, scriptType: $ScriptTypePredicate$Type, eventType: $Supplier$Type<($Class$Type<(any)>)>): $EventHandler
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(name: string): $EventGroup
public "register"(): void
public "common"(name: string, eventType: $Supplier$Type<($Class$Type<(any)>)>): $EventHandler
public "getHandlers"(): $Map<(string), ($EventHandler)>
public "client"(name: string, eventType: $Supplier$Type<($Class$Type<(any)>)>): $EventHandler
public "server"(name: string, eventType: $Supplier$Type<($Class$Type<(any)>)>): $EventHandler
public "startup"(name: string, eventType: $Supplier$Type<($Class$Type<(any)>)>): $EventHandler
public static "getGroups"(): $Map<(string), ($EventGroup)>
get "handlers"(): $Map<(string), ($EventHandler)>
get "groups"(): $Map<(string), ($EventGroup)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventGroup$Type = ($EventGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventGroup_ = $EventGroup$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidBuilder" {
import {$FluidBlockBuilder, $FluidBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidBlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FlowingFluid, $FlowingFluid$Type} from "packages/net/minecraft/world/level/material/$FlowingFluid"
import {$ArchitecturyFluidAttributes, $ArchitecturyFluidAttributes$Type} from "packages/dev/architectury/core/fluid/$ArchitecturyFluidAttributes"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$FlowingFluidBuilder, $FlowingFluidBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FlowingFluidBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$FluidBucketItemBuilder, $FluidBucketItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidBucketItemBuilder"

export class $FluidBuilder extends $BuilderBase<($FlowingFluid)> {
 "attributes": $ArchitecturyFluidAttributes
 "flowingFluid": $FlowingFluidBuilder
 "block": $FluidBlockBuilder
 "bucketItem": $FluidBucketItemBuilder
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "color"(c: $Color$Type): $FluidBuilder
public "displayName"(name: $Component$Type): $BuilderBase<($FlowingFluid)>
public "tag"(tag: $ResourceLocation$Type): $BuilderBase<($FlowingFluid)>
public "createObject"(): $FlowingFluid
public "flowingTexture"(id: $ResourceLocation$Type): $FluidBuilder
public "stillTexture"(id: $ResourceLocation$Type): $FluidBuilder
public "bucketColor"(c: $Color$Type): $FluidBuilder
public "builtinTextures"(): $FluidBuilder
public "thickTexture"(color: $Color$Type): $FluidBuilder
public "thinTexture"(color: $Color$Type): $FluidBuilder
public "createAdditionalObjects"(): void
public "renderType"(l: string): $FluidBuilder
public "createAttributes"(): $ArchitecturyFluidAttributes
public "viscosity"(viscosity: integer): $FluidBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
public "noBlock"(): $FluidBuilder
public "noBucket"(): $FluidBuilder
public "rarity"(rarity: $Rarity$Type): $FluidBuilder
public "translucent"(): $FluidBuilder
public "density"(density: integer): $FluidBuilder
public "luminosity"(luminosity: integer): $FluidBuilder
public "temperature"(temperature: integer): $FluidBuilder
public "gaseous"(): $FluidBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidBuilder$Type = ($FluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidBuilder_ = $FluidBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$EntityLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EntityLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "addEntity"(type: $EntityType$Type<(any)>, b: $Consumer$Type<($LootBuilder$Type)>): void
public "modifyEntity"(type: $EntityType$Type<(any)>, b: $Consumer$Type<($LootBuilder$Type)>): void
public "getDirectory"(): string
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityLootEventJS$Type = ($EntityLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityLootEventJS_ = $EntityLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$CheckLivingEntitySpawnEventJS" {
import {$MobSpawnType, $MobSpawnType$Type} from "packages/net/minecraft/world/entity/$MobSpawnType"
import {$BaseSpawner, $BaseSpawner$Type} from "packages/net/minecraft/world/level/$BaseSpawner"
import {$LivingEntityEventJS, $LivingEntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

/**
 * Invoked before an entity is spawned into the world.
 * 
 * Only entities from a `BaseSpawner` or world generation will trigger this event.
 */
export class $CheckLivingEntitySpawnEventJS extends $LivingEntityEventJS {
readonly "x": double
readonly "y": double
readonly "z": double
readonly "type": $MobSpawnType
readonly "spawner": $BaseSpawner

constructor(entity: $LivingEntity$Type, level: $Level$Type, x: double, y: double, z: double, type: $MobSpawnType$Type, spawner: $BaseSpawner$Type)

/**
 * The type of spawn.
 */
public "getType"(): $MobSpawnType
/**
 * The level the entity is being spawned into.
 */
public "getLevel"(): $Level
/**
 * The block the entity is being spawned on.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The entity being spawned.
 */
public "getEntity"(): $LivingEntity
/**
 * The spawner that spawned the entity. Can be null if the entity was spawned by worldgen.
 */
public "getSpawner"(): $BaseSpawner
get "type"(): $MobSpawnType
get "level"(): $Level
get "block"(): $BlockContainerJS
get "entity"(): $LivingEntity
get "spawner"(): $BaseSpawner
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckLivingEntitySpawnEventJS$Type = ($CheckLivingEntitySpawnEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CheckLivingEntitySpawnEventJS_ = $CheckLivingEntitySpawnEventJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/$MutableNumberUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MutableNumberUnit extends $Unit {
 "value": double
static "EMPTY_ARRAY": ($Unit)[]

constructor(value: double)

public "get"(variables: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public "set"(value: double): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableNumberUnit$Type = ($MutableNumberUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableNumberUnit_ = $MutableNumberUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$BlockWrapper" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPredicate, $BlockPredicate$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockPredicate"
import {$BlockIDPredicate, $BlockIDPredicate$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockIDPredicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockEntityPredicate, $BlockEntityPredicate$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockEntityPredicate"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * Various block related helper functions
 */
export class $BlockWrapper {

constructor()

public static "id"(id: $ResourceLocation$Type, properties: $Map$Type<(string), (any)>): $BlockIDPredicate
public static "id"(id: $ResourceLocation$Type): $BlockIDPredicate
/**
 * Gets a blocks id from the Block
 */
public static "getId"(block: $Block$Type): $ResourceLocation
/**
 * Gets a Block from a block id
 */
public static "getBlock"(id: $ResourceLocation$Type): $Block
public static "custom"(predicate: $BlockPredicate$Type): $BlockPredicate
/**
 * Get a map of direction name to Direction. Functionally identical to Direction.ALL
 */
public static "getFacing"(): $Map<(string), ($Direction)>
public static "entity"(id: $ResourceLocation$Type): $BlockEntityPredicate
/**
 * Gets a list of all blocks with tags
 */
public static "getTaggedIds"(tag: $ResourceLocation$Type): $List<($ResourceLocation)>
/**
 * Gets a list of the classname of all registered blocks
 */
public static "getTypeList"(): $List<(string)>
get "facing"(): $Map<(string), ($Direction)>
get "typeList"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockWrapper$Type = ($BlockWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockWrapper_ = $BlockWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$ItemMatch" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $ItemMatch extends $ReplacementMatch {

 "contains"(itemLike: $ItemLike$Type): boolean
/**
 * 
 * @deprecated
 */
 "contains"(block: $Block$Type): boolean
 "contains"(arg0: $Ingredient$Type): boolean
 "contains"(arg0: $ItemStack$Type): boolean
 "containsAny"(itemLikes: $Iterable$Type<($ItemLike$Type)>): boolean
 "containsAny"(...itemLikes: ($ItemLike$Type)[]): boolean
}

export namespace $ItemMatch {
function of(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemMatch$Type = ($ItemMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemMatch_ = $ItemMatch$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$AtlasTextureObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$TextureAtlas, $TextureAtlas$Type} from "packages/net/minecraft/client/renderer/texture/$TextureAtlas"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AtlasTextureObject extends $BoxObject {
 "color": $Unit
 "atlas": $ResourceLocation
 "texture": $ResourceLocation
 "textureAtlas": $TextureAtlas
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtlasTextureObject$Type = ($AtlasTextureObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtlasTextureObject_ = $AtlasTextureObject$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$CharStream" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CharStream {
readonly "chars": (character)[]
 "position": integer
 "skipWhitespace": boolean

constructor(c: (character)[])

public "next"(): character
public "peek"(ahead: integer): character
public "peek"(): character
public "nextIf"(match: character): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CharStream$Type = ($CharStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CharStream_ = $CharStream$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$TagInstance" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$LinkedHashSet, $LinkedHashSet$Type} from "packages/java/util/$LinkedHashSet"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $TagInstance {
readonly "tag": $ResourceLocation
readonly "registries": $LinkedHashSet<($ResourceKey<(any)>)>

constructor(tag: $ResourceLocation$Type)

public "toText"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagInstance$Type = ($TagInstance);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagInstance_ = $TagInstance$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$OrFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $OrFilter extends $Record implements $BiomeFilter {

constructor(list: $List$Type<($BiomeFilter$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "list"(): $List<($BiomeFilter)>
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrFilter$Type = ($OrFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrFilter_ = $OrFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AnyMatchRuleTest" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $AnyMatchRuleTest extends $RuleTest {
static readonly "CODEC": $Codec<($AnyMatchRuleTest)>
readonly "rules": $List<($RuleTest)>

constructor()
constructor(rules: $List$Type<($RuleTest$Type)>)

public "test"(blockState: $BlockState$Type, random: $RandomSource$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyMatchRuleTest$Type = ($AnyMatchRuleTest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnyMatchRuleTest_ = $AnyMatchRuleTest$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$DivOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $DivOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DivOpUnit$Type = ($DivOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DivOpUnit_ = $DivOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ErrorReporter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"

export interface $ErrorReporter {

 "error"(arg0: $Context$Type, arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): void
 "warning"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: integer): void
 "runtimeError"(arg0: $Context$Type, arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): $EvaluatorException
}

export namespace $ErrorReporter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErrorReporter$Type = ($ErrorReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErrorReporter_ = $ErrorReporter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$GradientObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GradientObject extends $BoxObject {
 "colorTL": $Unit
 "colorTR": $Unit
 "colorBL": $Unit
 "colorBR": $Unit
 "texture": $ResourceLocation
 "u0": $Unit
 "v0": $Unit
 "u1": $Unit
 "v1": $Unit
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GradientObject$Type = ($GradientObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GradientObject_ = $GradientObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$GeneratorExpressionLoop" {
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$ForInLoop, $ForInLoop$Type} from "packages/dev/latvian/mods/rhino/ast/$ForInLoop"

export class $GeneratorExpressionLoop extends $ForInLoop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setIsForEach"(isForEach: boolean): void
public "isForEach"(): boolean
get "forEach"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratorExpressionLoop$Type = ($GeneratorExpressionLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratorExpressionLoop_ = $GeneratorExpressionLoop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeConstructor" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeConstructor$Factory, $RecipeConstructor$Factory$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeConstructor$Factory"

export class $RecipeConstructor extends $Record {

constructor(schema: $RecipeSchema$Type, keys: ($RecipeKey$Type<(any)>)[], factory: $RecipeConstructor$Factory$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $RecipeConstructor$Factory
public "keys"(): ($RecipeKey<(any)>)[]
public "schema"(): $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeConstructor$Type = ($RecipeConstructor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeConstructor_ = $RecipeConstructor$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaList" {
import {$ValueUnwrapper, $ValueUnwrapper$Type} from "packages/dev/latvian/mods/rhino/util/$ValueUnwrapper"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NativeJavaObject, $NativeJavaObject$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $NativeJavaList extends $NativeJavaObject {

constructor(cx: $Context$Type, scope: $Scriptable$Type, jo: any, list: $List$Type<(any)>, listType: $Class$Type<(any)>, valueUnwrapper: $ValueUnwrapper$Type)
constructor(cx: $Context$Type, scope: $Scriptable$Type, jo: any, list: $List$Type<(any)>)

public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, index: integer): void
public "getClassName"(): string
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "getIds"(cx: $Context$Type): (any)[]
public static "unwrapped"(o: any): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaList$Type = ($NativeJavaList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaList_ = $NativeJavaList$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$NewExpression" {
import {$FunctionCall, $FunctionCall$Type} from "packages/dev/latvian/mods/rhino/ast/$FunctionCall"
import {$ObjectLiteral, $ObjectLiteral$Type} from "packages/dev/latvian/mods/rhino/ast/$ObjectLiteral"

export class $NewExpression extends $FunctionCall {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setInitializer"(initializer: $ObjectLiteral$Type): void
public "getInitializer"(): $ObjectLiteral
set "initializer"(value: $ObjectLiteral$Type)
get "initializer"(): $ObjectLiteral
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NewExpression$Type = ($NewExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NewExpression_ = $NewExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$VariantBlockStateGenerator$Variant, $VariantBlockStateGenerator$Variant$Type} from "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator$Variant"

export class $VariantBlockStateGenerator {

constructor()

public "variant"(key: string, consumer: $Consumer$Type<($VariantBlockStateGenerator$Variant$Type)>): void
public "toJson"(): $JsonObject
public "simpleVariant"(key: string, model: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Type = ($VariantBlockStateGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator_ = $VariantBlockStateGenerator$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Function" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $Function extends $Scriptable, $Callable {

 "call"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Scriptable$Type, arg3: (any)[]): any
 "construct"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: (any)[]): $Scriptable
 "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
 "get"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type): any
 "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
 "put"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type, arg3: any): void
 "delete"(arg0: $Context$Type, arg1: string): void
 "delete"(arg0: $Context$Type, arg1: integer): void
 "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
 "getClassName"(): string
 "has"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type): boolean
 "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
 "setParentScope"(arg0: $Scriptable$Type): void
 "getParentScope"(): $Scriptable
 "getAllIds"(cx: $Context$Type): (any)[]
 "getTypeOf"(): $MemberType
 "enumerationIteratorHasNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
 "enumerationIteratorNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
 "getIds"(arg0: $Context$Type): (any)[]
 "hasInstance"(arg0: $Context$Type, arg1: $Scriptable$Type): boolean
 "getPrototype"(arg0: $Context$Type): $Scriptable
 "setPrototype"(arg0: $Scriptable$Type): void
}

export namespace $Function {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$Type = ($Function);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_ = $Function$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Sorting" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"

export class $Sorting {


public static "get"(): $Sorting
public "insertionSort"(a: (any)[], cmp: $Comparator$Type<(any)>): void
public "median"(a: (any)[], start: integer, end: integer, cmp: $Comparator$Type<(any)>): integer
public "hybridSort"(a: (any)[], cmp: $Comparator$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sorting$Type = ($Sorting);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sorting_ = $Sorting$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnitSymbol" {
import {$UnaryOperatorFactory, $UnaryOperatorFactory$Type} from "packages/dev/latvian/mods/unit/operator/$UnaryOperatorFactory"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$CharStream, $CharStream$Type} from "packages/dev/latvian/mods/unit/token/$CharStream"
import {$OperatorFactory, $OperatorFactory$Type} from "packages/dev/latvian/mods/unit/operator/$OperatorFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $UnitSymbol extends $Enum<($UnitSymbol)> implements $UnitToken {
static readonly "COMMA": $UnitSymbol
static readonly "LP": $UnitSymbol
static readonly "RP": $UnitSymbol
static readonly "HASH": $UnitSymbol
static readonly "HOOK": $UnitSymbol
static readonly "COLON": $UnitSymbol
static readonly "SEMICOLON": $UnitSymbol
static readonly "POSITIVE": $UnitSymbol
static readonly "NEGATE": $UnitSymbol
static readonly "ADD": $UnitSymbol
static readonly "SUB": $UnitSymbol
static readonly "MUL": $UnitSymbol
static readonly "DIV": $UnitSymbol
static readonly "MOD": $UnitSymbol
static readonly "POW": $UnitSymbol
static readonly "LSH": $UnitSymbol
static readonly "RSH": $UnitSymbol
static readonly "BIT_AND": $UnitSymbol
static readonly "BIT_OR": $UnitSymbol
static readonly "XOR": $UnitSymbol
static readonly "BIT_NOT": $UnitSymbol
static readonly "EQ": $UnitSymbol
static readonly "NEQ": $UnitSymbol
static readonly "LT": $UnitSymbol
static readonly "GT": $UnitSymbol
static readonly "LTE": $UnitSymbol
static readonly "GTE": $UnitSymbol
static readonly "AND": $UnitSymbol
static readonly "OR": $UnitSymbol
static readonly "BOOL_NOT": $UnitSymbol
static readonly "SET": $UnitSymbol
static readonly "ADD_SET": $UnitSymbol
static readonly "SUB_SET": $UnitSymbol
static readonly "MUL_SET": $UnitSymbol
static readonly "DIV_SET": $UnitSymbol
static readonly "MOD_SET": $UnitSymbol
readonly "symbol": string
readonly "precedence": integer
readonly "op": $OperatorFactory
readonly "unaryOp": $UnaryOperatorFactory


public "toString"(): string
public static "values"(): ($UnitSymbol)[]
public static "valueOf"(name: string): $UnitSymbol
public static "read"(first: character, stream: $CharStream$Type): $UnitSymbol
public "is"(next: $UnitToken$Type): boolean
public "nextUnaryOperator"(): boolean
public "unstack"(stack: $Stack$Type<($UnitToken$Type)>): void
public "hasHigherPrecedenceThan"(operator: $UnitSymbol$Type): boolean
public "getUnarySymbol"(): $UnitSymbol
public "interpret"(stream: $UnitTokenStream$Type): $Unit
get "unarySymbol"(): $UnitSymbol
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitSymbol$Type = (("lsh") | ("sub") | ("mod") | ("lp") | ("mul") | ("rsh") | ("sub_set") | ("lt") | ("add_set") | ("div") | ("hook") | ("and") | ("pow") | ("gte") | ("xor") | ("neq") | ("lte") | ("semicolon") | ("add") | ("or") | ("set") | ("mul_set") | ("positive") | ("eq") | ("bit_or") | ("gt") | ("bool_not") | ("comma") | ("div_set") | ("negate") | ("colon") | ("mod_set") | ("bit_and") | ("rp") | ("hash") | ("bit_not")) | ($UnitSymbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitSymbol_ = $UnitSymbol$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/wrapper/$ColorWrapper" {
import {$DyeColor, $DyeColor$Type} from "packages/net/minecraft/world/item/$DyeColor"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$ChatFormatting, $ChatFormatting$Type} from "packages/net/minecraft/$ChatFormatting"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ColorWrapper {

}

export namespace $ColorWrapper {
const MAP: $Map<(string), ($Color)>
const TEXT: $Map<(string), ($ChatFormatting)>
const DYE: $Map<(string), ($DyeColor)>
const NONE: $Color
const BLACK: $Color
const DARK_BLUE: $Color
const DARK_GREEN: $Color
const DARK_AQUA: $Color
const DARK_RED: $Color
const DARK_PURPLE: $Color
const GOLD: $Color
const GRAY: $Color
const DARK_GRAY: $Color
const BLUE: $Color
const GREEN: $Color
const AQUA: $Color
const RED: $Color
const LIGHT_PURPLE: $Color
const YELLOW: $Color
const WHITE: $Color
const WHITE_DYE: $Color
const ORANGE_DYE: $Color
const MAGENTA_DYE: $Color
const LIGHT_BLUE_DYE: $Color
const YELLOW_DYE: $Color
const LIME_DYE: $Color
const PINK_DYE: $Color
const GRAY_DYE: $Color
const LIGHT_GRAY_DYE: $Color
const CYAN_DYE: $Color
const PURPLE_DYE: $Color
const BLUE_DYE: $Color
const BROWN_DYE: $Color
const GREEN_DYE: $Color
const RED_DYE: $Color
const BLACK_DYE: $Color
function of(o: any): $Color
function createMapped(o: any, ...names: (string)[]): $Color
function rgba(r: integer, g: integer, b: integer, a: integer): $Color
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ColorWrapper$Type = ($ColorWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ColorWrapper_ = $ColorWrapper$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Atan2FuncUnit" {
import {$Func2Unit, $Func2Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func2Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $Atan2FuncUnit extends $Func2Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Atan2FuncUnit$Type = ($Atan2FuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Atan2FuncUnit_ = $Atan2FuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$JEISubtypesEventJS$Interpreter" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $JEISubtypesEventJS$Interpreter extends $Function<($ItemStack), (any)> {

 "apply"(arg0: $ItemStack$Type): any
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (any)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($ItemStack), (V)>

(arg0: $ItemStack$Type): any
}

export namespace $JEISubtypesEventJS$Interpreter {
function identity<T>(): $Function<($ItemStack), ($ItemStack)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEISubtypesEventJS$Interpreter$Type = ($JEISubtypesEventJS$Interpreter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEISubtypesEventJS$Interpreter_ = $JEISubtypesEventJS$Interpreter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$PlayerSelector" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"

export interface $PlayerSelector {

 "or"(fallback: $PlayerSelector$Type): $PlayerSelector
 "getPlayer"(arg0: $MinecraftServer$Type): $ServerPlayer

(name: string): $PlayerSelector
}

export namespace $PlayerSelector {
function name(name: string): $PlayerSelector
function of(o: any): $PlayerSelector
function identity(player: $ServerPlayer$Type): $PlayerSelector
function fuzzyName(name: string): $PlayerSelector
function uuid(uuid: $UUID$Type): $PlayerSelector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerSelector$Type = (string) | ($PlayerSelector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerSelector_ = $PlayerSelector$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuContainerSlot" {
import {$CustomChestMenu, $CustomChestMenu$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$CustomChestMenu"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ChestMenuContainerSlot extends $Slot {
readonly "menu": $CustomChestMenu
readonly "_index": integer
readonly "container": $Container
 "index": integer
 "x": integer
 "y": integer

constructor(menu: $CustomChestMenu$Type, index: integer, xPosition: integer, yPosition: integer)

public "remove"(amount: integer): $ItemStack
public "getItem"(): $ItemStack
public "getMaxStackSize"(stack: $ItemStack$Type): integer
public "mayPlace"(stack: $ItemStack$Type): boolean
public "mayPickup"(playerIn: $Player$Type): boolean
public "onQuickCraft"(oldStackIn: $ItemStack$Type, newStackIn: $ItemStack$Type): void
public "set"(stack: $ItemStack$Type): void
public "getMaxStackSize"(): integer
get "item"(): $ItemStack
get "maxStackSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuContainerSlot$Type = ($ChestMenuContainerSlot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuContainerSlot_ = $ChestMenuContainerSlot$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$EqualObjectGraphs" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EqualObjectGraphs {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EqualObjectGraphs$Type = ($EqualObjectGraphs);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EqualObjectGraphs_ = $EqualObjectGraphs$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$JsonSerializable" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"

export interface $JsonSerializable {

 "toJson"(): $JsonElement

(): $JsonElement
}

export namespace $JsonSerializable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonSerializable$Type = ($JsonSerializable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonSerializable_ = $JsonSerializable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$MobEffectBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$MobEffectBuilder$EffectTickCallback, $MobEffectBuilder$EffectTickCallback$Type} from "packages/dev/latvian/mods/kubejs/misc/$MobEffectBuilder$EffectTickCallback"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MobEffectCategory, $MobEffectCategory$Type} from "packages/net/minecraft/world/effect/$MobEffectCategory"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"

export class $MobEffectBuilder extends $BuilderBase<($MobEffect)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "color"(col: $Color$Type): $MobEffectBuilder
public "category"(c: $MobEffectCategory$Type): $MobEffectBuilder
public "modifyAttribute"(attribute: $ResourceLocation$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): $MobEffectBuilder
public "harmful"(): $MobEffectBuilder
public "beneficial"(): $MobEffectBuilder
public "effectTick"(effectTick: $MobEffectBuilder$EffectTickCallback$Type): $MobEffectBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$Type = ($MobEffectBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectBuilder_ = $MobEffectBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$DamageBonusFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $EnchantmentBuilder$DamageBonusFunction {

 "getDamageBonus"(arg0: integer, arg1: string): float

(arg0: integer, arg1: string): float
}

export namespace $EnchantmentBuilder$DamageBonusFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentBuilder$DamageBonusFunction$Type = ($EnchantmentBuilder$DamageBonusFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentBuilder$DamageBonusFunction_ = $EnchantmentBuilder$DamageBonusFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$NetworkEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $NetworkEvents {

}

export namespace $NetworkEvents {
const GROUP: $EventGroup
const DATA_RECEIVED: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEvents$Type = ($NetworkEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEvents_ = $NetworkEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$VillagerTypeBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$VillagerType, $VillagerType$Type} from "packages/net/minecraft/world/entity/npc/$VillagerType"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $VillagerTypeBuilder extends $BuilderBase<($VillagerType)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerTypeBuilder$Type = ($VillagerTypeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerTypeBuilder_ = $VillagerTypeBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$WrappedJS, $WrappedJS$Type} from "packages/dev/latvian/mods/kubejs/util/$WrappedJS"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $RecipeComponentValue<T> implements $WrappedJS, $Map$Entry<($RecipeKey<(T)>), (T)> {
static readonly "EMPTY_ARRAY": ($RecipeComponentValue<(any)>)[]
readonly "key": $RecipeKey<(T)>
readonly "index": integer
 "value": T
 "write": boolean

constructor(key: $RecipeKey$Type<(T)>, index: integer)

public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): T
public "getKey"(): $RecipeKey<(T)>
public "write"(): void
public "setValue"(newValue: T): T
public "copy"(): $RecipeComponentValue<(T)>
public "getIndex"(): integer
public "isInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type): boolean
public "checkEmpty"(): string
public "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, arg2: $OutputReplacement$Type): boolean
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, arg2: $InputReplacement$Type): boolean
public "shouldWrite"(): boolean
public static "copyOf"<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<($RecipeKey<(T)>), (T)>
public static "comparingByKey"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByKey"<K extends $Comparable<(any)>, V>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V extends $Comparable<(any)>>(): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
public static "comparingByValue"<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<($RecipeKey<(T)>), (T)>)>
get "value"(): T
get "key"(): $RecipeKey<(T)>
set "value"(value: T)
get "index"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentValue$Type<T> = ($RecipeComponentValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentValue_<T> = $RecipeComponentValue$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NestedRecipeComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NestedRecipeComponent implements $RecipeComponent<($RecipeJS)> {
static readonly "RECIPE": $RecipeComponent<($RecipeJS)>
static readonly "RECIPE_ARRAY": $RecipeComponent<(($RecipeJS)[])>

constructor()

public "write"(recipe: $RecipeJS$Type, value: $RecipeJS$Type): $JsonElement
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "componentType"(): string
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($RecipeJS)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($RecipeJS)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($RecipeJS), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($RecipeJS), (O)>
public "asArray"(): $ArrayRecipeComponent<($RecipeJS)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($RecipeJS)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($RecipeJS)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($RecipeJS)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeJS$Type)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeJS$Type)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($RecipeJS$Type)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: $RecipeJS$Type, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $RecipeJS$Type, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<($RecipeJS)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($RecipeJS)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($RecipeJS)>)>
public "checkEmpty"(key: $RecipeKey$Type<($RecipeJS$Type)>, value: $RecipeJS$Type): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: $RecipeJS$Type, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $RecipeJS
public "replaceInput"(recipe: $RecipeJS$Type, original: $RecipeJS$Type, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $RecipeJS
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: $RecipeJS$Type, newValue: $RecipeJS$Type): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($RecipeJS)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NestedRecipeComponent$Type = ($NestedRecipeComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NestedRecipeComponent_ = $NestedRecipeComponent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ItemArmorTierRegistryEventJS" {
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"

/**
 * Invoked when the game is starting up and the armor tier registry is being built.
 */
export class $ItemArmorTierRegistryEventJS extends $StartupEventJS {

constructor()

/**
 * Adds a new armor tier with a parent tier specified by string.
 */
public "add"(id: string, parent: string, tier: $Consumer$Type<($MutableArmorTier$Type)>): void
/**
 * Adds a new armor tier.
 */
public "add"(id: string, tier: $Consumer$Type<($MutableArmorTier$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemArmorTierRegistryEventJS$Type = ($ItemArmorTierRegistryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemArmorTierRegistryEventJS_ = $ItemArmorTierRegistryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$RegExpLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $RegExpLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getValue"(): string
public "setValue"(value: string): void
public "getFlags"(): string
public "setFlags"(flags: string): void
get "value"(): string
set "value"(value: string)
get "flags"(): string
set "flags"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegExpLiteral$Type = ($RegExpLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegExpLiteral_ = $RegExpLiteral$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $EventJS {

constructor()

/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `exit` denotes a `default` outcome.
 */
public "exit"(): any
/**
 * Stops the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(value: any): any
/**
 * Stops the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `success` denotes a `true` outcome.
 */
public "success"(): any
/**
 * Cancels the event with the given exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(value: any): any
/**
 * Cancels the event with default exit value. Execution will be stopped **immediately**.
 * 
 * `cancel` denotes a `false` outcome.
 */
public "cancel"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventJS$Type = ($EventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventJS_ = $EventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/$MiscForgeHelper" {
import {$KubeJSMenu, $KubeJSMenu$Type} from "packages/dev/latvian/mods/kubejs/gui/$KubeJSMenu"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MiscPlatformHelper, $MiscPlatformHelper$Type} from "packages/dev/latvian/mods/kubejs/platform/$MiscPlatformHelper"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeModeTab$DisplayItemsGenerator, $CreativeModeTab$DisplayItemsGenerator$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$DisplayItemsGenerator"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$PlatformWrapper$ModInfo, $PlatformWrapper$ModInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$PlatformWrapper$ModInfo"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $MiscForgeHelper implements $MiscPlatformHelper {

constructor()

public "isDataGen"(): boolean
public "creativeModeTab"(name: $Component$Type, icon: $Supplier$Type<($ItemStack$Type)>, content: $CreativeModeTab$DisplayItemsGenerator$Type): $CreativeModeTab
public "ingotFluidAmount"(): long
public "bottleFluidAmount"(): long
public "setModName"(info: $PlatformWrapper$ModInfo$Type, name: string): void
public "createMenuType"(): $MenuType<($KubeJSMenu)>
public "getMobCategory"(name: string): $MobCategory
public static "get"(): $MiscPlatformHelper
get "dataGen"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MiscForgeHelper$Type = ($MiscForgeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MiscForgeHelper_ = $MiscForgeHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$CustomBuilderObject" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CustomBuilderObject extends $BuilderBase<(any)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type, object: $Supplier$Type<(any)>, registry: $RegistryInfo$Type<(any)>)

public "createObject"(): any
public "getTranslationKeyGroup"(): string
public "getRegistryType"(): $RegistryInfo<(any)>
get "translationKeyGroup"(): string
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomBuilderObject$Type = ($CustomBuilderObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomBuilderObject_ = $CustomBuilderObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ObjToIntMap$Iterator" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ObjToIntMap$Iterator {


public "getValue"(): integer
public "next"(): void
public "start"(): void
public "getKey"(): any
public "setValue"(value: integer): void
public "done"(): boolean
get "value"(): integer
get "key"(): any
set "value"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjToIntMap$Iterator$Type = ($ObjToIntMap$Iterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjToIntMap$Iterator_ = $ObjToIntMap$Iterator$Type;
}}
declare module "packages/dev/latvian/mods/unit/$Unit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"

export class $Unit {
static "EMPTY_ARRAY": ($Unit)[]

constructor()

public "add"(other: $Unit$Type): $Unit
public "add"(value: double): $Unit
public "get"(arg0: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public "toString"(): string
public "abs"(): $Unit
public "sin"(): $Unit
public "cos"(): $Unit
public "tan"(): $Unit
public "atan2"(other: $Unit$Type): $Unit
public "sqrt"(): $Unit
public "log"(): $Unit
public "log10"(): $Unit
public "pow"(other: $Unit$Type): $Unit
public "min"(other: $Unit$Type): $Unit
public "max"(other: $Unit$Type): $Unit
public "floor"(): $Unit
public "ceil"(): $Unit
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public "getFloat"(variables: $UnitVariables$Type): float
public "set"(unit: $Unit$Type): $Unit
public "mod"(other: $Unit$Type): $Unit
public "mod"(value: double): $Unit
public "eq"(other: $Unit$Type): $Unit
public "lt"(other: $Unit$Type): $Unit
public "atan"(): $Unit
public "log1p"(): $Unit
public "or"(other: $Unit$Type): $Unit
public "sub"(value: double): $Unit
public "sub"(other: $Unit$Type): $Unit
public "negate"(): $Unit
public "and"(other: $Unit$Type): $Unit
public "xor"(other: $Unit$Type): $Unit
public "positive"(): $Unit
public "isFixed"(): boolean
public "div"(other: $Unit$Type): $Unit
public "div"(value: double): $Unit
public "subSet"(unit: $Unit$Type): $Unit
public "sq"(): $Unit
public "mul"(value: double): $Unit
public "mul"(other: $Unit$Type): $Unit
public "bool"(): $Unit
public "gt"(other: $Unit$Type): $Unit
public "deg"(): $Unit
public "bitOr"(other: $Unit$Type): $Unit
public "boolNot"(): $Unit
public "rsh"(other: $Unit$Type): $Unit
public "lsh"(other: $Unit$Type): $Unit
public "bitAnd"(other: $Unit$Type): $Unit
public "bitNot"(): $Unit
public "neq"(other: $Unit$Type): $Unit
public "divSet"(unit: $Unit$Type): $Unit
public "modSet"(unit: $Unit$Type): $Unit
public "mulSet"(unit: $Unit$Type): $Unit
public "smoothstep"(): $Unit
public "lte"(other: $Unit$Type): $Unit
public "gte"(other: $Unit$Type): $Unit
public "clamp"(a: $Unit$Type, b: $Unit$Type): $Unit
public "rad"(): $Unit
public "addSet"(unit: $Unit$Type): $Unit
public "withAlpha"(a: $Unit$Type): $Unit
public "lerp"(a: $Unit$Type, b: $Unit$Type): $Unit
get "fixed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Unit$Type = (string) | (number) | ($Unit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Unit_ = $Unit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$EntityArrayList" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MessageSenderKJS, $MessageSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$DataSenderKJS, $DataSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$DataSenderKJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$EntitySelector, $EntitySelector$Type} from "packages/net/minecraft/commands/arguments/selector/$EntitySelector"

export class $EntityArrayList extends $ArrayList<($Entity)> implements $MessageSenderKJS, $DataSenderKJS {
readonly "level": $Level

constructor(l: $Level$Type, size: integer)
constructor(l: $Level$Type, entities: $Iterable$Type<(any)>)

public "filter"(filter: $Predicate$Type<($Entity$Type)>): $EntityArrayList
public "getFirst"(): $Entity
public "sendData"(channel: string, data: $CompoundTag$Type): void
public "addAllIterable"(entities: $Iterable$Type<(any)>): void
public "setStatusMessage"(message: $Component$Type): void
public "runCommandSilent"(command: string): integer
public "filterSelector"(selector: $EntitySelector$Type): $EntityArrayList
public "kill"(): void
public "playSound"(id: $SoundEvent$Type): void
public "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
public "getName"(): $Component
public "runCommand"(command: string): integer
public "tell"(message: $Component$Type): void
public "getDisplayName"(): $Component
public "sendData"(channel: string): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "first"(): $Entity
set "statusMessage"(value: $Component$Type)
get "name"(): $Component
get "displayName"(): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityArrayList$Type = ($EntityArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityArrayList_ = $EntityArrayList$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$OrOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $OrOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrOpUnit$Type = ($OrOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrOpUnit_ = $OrOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ScriptNode" {
import {$FunctionNode, $FunctionNode$Type} from "packages/dev/latvian/mods/rhino/ast/$FunctionNode"
import {$TemplateLiteral, $TemplateLiteral$Type} from "packages/dev/latvian/mods/rhino/ast/$TemplateLiteral"
import {$AstSymbol, $AstSymbol$Type} from "packages/dev/latvian/mods/rhino/ast/$AstSymbol"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$RegExpLiteral, $RegExpLiteral$Type} from "packages/dev/latvian/mods/rhino/ast/$RegExpLiteral"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$TemplateCharacters, $TemplateCharacters$Type} from "packages/dev/latvian/mods/rhino/ast/$TemplateCharacters"

export class $ScriptNode extends $Scope {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer)

public "addFunction"(fnNode: $FunctionNode$Type): integer
public "getIndexForNameNode"(nameNode: $Node$Type): integer
public "getParamAndVarNames"(): (string)[]
public "getParamAndVarConst"(): (boolean)[]
public "getTemplateLiteralCount"(): integer
public "getTemplateLiteralStrings"(index: integer): $List<($TemplateCharacters)>
public "getSourceName"(): string
public "setEndLineno"(lineno: integer): void
public "setSourceName"(sourceName: string): void
public "setInStrictMode"(inStrictMode: boolean): void
public "setBaseLineno"(lineno: integer): void
public "getNextTempName"(): string
public "getBaseLineno"(): integer
public "getFunctionNode"(i: integer): $FunctionNode
public "getFunctionCount"(): integer
public "isInStrictMode"(): boolean
public "getEndLineno"(): integer
public "getRegexpFlags"(index: integer): string
public "getRegexpString"(index: integer): string
public "addTemplateLiteral"(templateLiteral: $TemplateLiteral$Type): void
public "addRegExp"(re: $RegExpLiteral$Type): void
public "getRegexpCount"(): integer
public "setSymbols"(symbols: $List$Type<($AstSymbol$Type)>): void
public "flattenSymbolTable"(flattenAllTables: boolean): void
public "getFunctions"(): $List<($FunctionNode)>
public "getParamCount"(): integer
public "getParamAndVarCount"(): integer
public "getParamOrVarName"(index: integer): string
public "getSymbols"(): $List<($AstSymbol)>
get "paramAndVarNames"(): (string)[]
get "paramAndVarConst"(): (boolean)[]
get "templateLiteralCount"(): integer
get "sourceName"(): string
set "endLineno"(value: integer)
set "sourceName"(value: string)
set "inStrictMode"(value: boolean)
set "baseLineno"(value: integer)
get "nextTempName"(): string
get "baseLineno"(): integer
get "functionCount"(): integer
get "inStrictMode"(): boolean
get "endLineno"(): integer
get "regexpCount"(): integer
set "symbols"(value: $List$Type<($AstSymbol$Type)>)
get "functions"(): $List<($FunctionNode)>
get "paramCount"(): integer
get "paramAndVarCount"(): integer
get "symbols"(): $List<($AstSymbol)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptNode$Type = ($ScriptNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptNode_ = $ScriptNode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$DamageAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DamageAction extends $IngredientAction {
readonly "amount": integer
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor(a: integer)

public "transform"(old: $ItemStack$Type, index: integer, container: $CraftingContainer$Type): $ItemStack
public "getType"(): string
public "toJson"(json: $JsonObject$Type): void
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DamageAction$Type = ($DamageAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DamageAction_ = $DamageAction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ConsoleLine$SourceLine" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine$SourceLine extends $Record {

constructor(buf: $FriendlyByteBuf$Type)
constructor(source: string, line: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "line"(): integer
public "source"(): string
public static "write"(buf: $FriendlyByteBuf$Type, sourceLine: $ConsoleLine$SourceLine$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$SourceLine$Type = ($ConsoleLine$SourceLine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleLine$SourceLine_ = $ConsoleLine$SourceLine$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$JsonRecipeSchemaType" {
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeNamespace, $RecipeNamespace$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RecipeSchemaType, $RecipeSchemaType$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType"

export class $JsonRecipeSchemaType extends $RecipeSchemaType {
readonly "namespace": $RecipeNamespace
readonly "id": $ResourceLocation
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType

constructor(namespace: $RecipeNamespace$Type, id: $ResourceLocation$Type, serializer: $RecipeSerializer$Type<(any)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonRecipeSchemaType$Type = ($JsonRecipeSchemaType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonRecipeSchemaType_ = $JsonRecipeSchemaType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$BuiltinKubeJSForgePlugin" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$BuiltinKubeJSPlugin, $BuiltinKubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$BuiltinKubeJSPlugin"
import {$ClassFilter, $ClassFilter$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassFilter"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$TypeWrappers, $TypeWrappers$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrappers"

export class $BuiltinKubeJSForgePlugin extends $BuiltinKubeJSPlugin {
static readonly "GLOBAL": $HashMap<(string), (any)>

constructor()

public "registerBindings"(event: $BindingsEvent$Type): void
public "registerEvents"(): void
public "registerClasses"(type: $ScriptType$Type, filter: $ClassFilter$Type): void
public "registerTypeWrappers"(type: $ScriptType$Type, typeWrappers: $TypeWrappers$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuiltinKubeJSForgePlugin$Type = ($BuiltinKubeJSForgePlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuiltinKubeJSForgePlugin_ = $BuiltinKubeJSForgePlugin$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$InformationJEIEventJS" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IRecipeRegistration, $IRecipeRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeRegistration"

export class $InformationJEIEventJS extends $EventJS {

constructor(reg: $IRecipeRegistration$Type)

public "addForType"<T>(type: $IIngredientType$Type<(T)>, o: any, s: ($Component$Type)[]): void
public "addFluid"(fluid: any, s: ($Component$Type)[]): void
public "addItem"(item: $Ingredient$Type, s: ($Component$Type)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InformationJEIEventJS$Type = ($InformationJEIEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InformationJEIEventJS_ = $InformationJEIEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$FluidAmounts" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $FluidAmounts {

}

export namespace $FluidAmounts {
const BUCKET: long
const MILLIBUCKET: long
const B: long
const MB: long
const INGOT: long
const NUGGET: long
const METAL_BLOCK: long
const BOTTLE: long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidAmounts$Type = ($FluidAmounts);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidAmounts_ = $FluidAmounts$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ThrowStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ThrowStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, expr: $AstNode$Type)
constructor(pos: integer, expr: $AstNode$Type)
constructor(expr: $AstNode$Type)
constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

public "getExpression"(): $AstNode
public "setExpression"(expression: $AstNode$Type): void
get "expression"(): $AstNode
set "expression"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThrowStatement$Type = ($ThrowStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThrowStatement_ = $ThrowStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockModificationEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BlockModificationEventJS extends $EventJS {

constructor()

/**
 * Modifies blocks that match the given predicate.
 * 
 * **NOTE**: tag predicates are not supported at this time.
 */
public "modify"(predicate: $BlockStatePredicate$Type, c: $Consumer$Type<($Block$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockModificationEventJS$Type = ($BlockModificationEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockModificationEventJS_ = $BlockModificationEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$LegacyCodeHandler" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LegacyCodeHandler$LegacyError, $LegacyCodeHandler$LegacyError$Type} from "packages/dev/latvian/mods/kubejs/util/$LegacyCodeHandler$LegacyError"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $LegacyCodeHandler extends $BaseFunction {
readonly "code": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(code: string)

public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "makeError"(cx: $Context$Type): $LegacyCodeHandler$LegacyError
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyCodeHandler$Type = ($LegacyCodeHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyCodeHandler_ = $LegacyCodeHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$ProcessingRecipeSchema" {
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$OutputFluid, $OutputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $ProcessingRecipeSchema {

}

export namespace $ProcessingRecipeSchema {
const RESULTS: $RecipeKey<(($Either<($OutputFluid), ($OutputItem)>)[])>
const INGREDIENTS: $RecipeKey<(($Either<($InputFluid), ($InputItem)>)[])>
const INGREDIENTS_UNWRAPPED: $RecipeKey<(($Either<($InputFluid), ($InputItem)>)[])>
const PROCESSING_TIME: $RecipeKey<(long)>
const PROCESSING_TIME_REQUIRED: $RecipeKey<(long)>
const HEAT_REQUIREMENT: $RecipeKey<(string)>
const KEEP_HELD_ITEM: $RecipeKey<(boolean)>
const PROCESSING_DEFAULT: $RecipeSchema
const PROCESSING_WITH_TIME: $RecipeSchema
const PROCESSING_UNWRAPPED: $RecipeSchema
const ITEM_APPLICATION: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipeSchema$Type = ($ProcessingRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProcessingRecipeSchema_ = $ProcessingRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$BoilerHeaterHandlerEvent" {
import {$BoilerHeaterHandlerEvent$BoilerHeaterCallback, $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type} from "packages/dev/latvian/mods/kubejs/create/events/$BoilerHeaterHandlerEvent$BoilerHeaterCallback"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BoilerHeaterHandlerEvent extends $EventJS {

constructor()

public "add"(block: $Block$Type, onUpdate: $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type): void
public "addAdvanced"(block: $BlockStatePredicate$Type, onUpdate: $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerHeaterHandlerEvent$Type = ($BoilerHeaterHandlerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilerHeaterHandlerEvent_ = $BoilerHeaterHandlerEvent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IRFactory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Parser, $Parser$Type} from "packages/dev/latvian/mods/rhino/$Parser"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$AstRoot, $AstRoot$Type} from "packages/dev/latvian/mods/rhino/ast/$AstRoot"

export class $IRFactory extends $Parser {
static readonly "ARGC_LIMIT": integer
static readonly "CLEAR_TI_MASK": integer
static readonly "TI_AFTER_EOL": integer
static readonly "TI_CHECK_LABEL": integer

constructor(cx: $Context$Type, env: $CompilerEnvirons$Type)
constructor(cx: $Context$Type)
constructor(cx: $Context$Type, env: $CompilerEnvirons$Type, errorReporter: $ErrorReporter$Type)

public "transform"(node: $AstNode$Type): $Node
public "transformTree"(root: $AstRoot$Type): $ScriptNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IRFactory$Type = ($IRFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IRFactory_ = $IRFactory$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdFunctionObject" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $IdFunctionObject extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(idcall: $IdFunctionCall$Type, tag: any, id: integer, name: string, arity: integer, scope: $Scriptable$Type)
constructor(idcall: $IdFunctionCall$Type, tag: any, id: integer, arity: integer)

public "getLength"(): integer
public "createObject"(cx: $Context$Type, scope: $Scriptable$Type): $Scriptable
public "getTag"(): any
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "addAsProperty"(target: $Scriptable$Type, cx: $Context$Type): void
public "exportAsScopeProperty"(cx: $Context$Type): void
public "markAsConstructor"(prototypeProperty: $Scriptable$Type): void
public "initFunction"(name: string, scope: $Scriptable$Type): void
public "hasTag"(tag: any): boolean
public "unknown"(): $RuntimeException
public "getFunctionName"(): string
public "methodId"(): integer
public "getArity"(): integer
public "getPrototype"(cx: $Context$Type): $Scriptable
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "tag"(): any
get "functionName"(): string
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdFunctionObject$Type = ($IdFunctionObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdFunctionObject_ = $IdFunctionObject$Type;
}}
declare module "packages/dev/latvian/mods/unit/$FixedNumberUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $FixedNumberUnit extends $Unit {
static readonly "ZERO": $FixedNumberUnit
static readonly "ONE": $FixedNumberUnit
static readonly "MINUS_ONE": $FixedNumberUnit
static readonly "TEN": $FixedNumberUnit
static readonly "SIXTEEN": $FixedNumberUnit
static readonly "PI": $FixedNumberUnit
static readonly "TWO_PI": $FixedNumberUnit
static readonly "HALF_PI": $FixedNumberUnit
static readonly "E": $FixedNumberUnit
static readonly "NaN": $FixedNumberUnit
readonly "value": double
static "EMPTY_ARRAY": ($Unit)[]


public "add"(other: $Unit$Type): $Unit
public "add"(value: double): $Unit
public "get"(variables: $UnitVariables$Type): double
public "equals"(obj: any): boolean
public "toString"(builder: $StringBuilder$Type): void
public "hashCode"(): integer
public "abs"(): $Unit
public "sin"(): $Unit
public "cos"(): $Unit
public "tan"(): $Unit
public "sqrt"(): $Unit
public "log"(): $Unit
public "log10"(): $Unit
public "pow"(other: $Unit$Type): $Unit
public "floor"(): $Unit
public "ceil"(): $Unit
public "getBoolean"(variables: $UnitVariables$Type): boolean
public static "of"(value: double): $FixedNumberUnit
public "mod"(value: double): $Unit
public "mod"(other: $Unit$Type): $Unit
public "atan"(): $Unit
public "log1p"(): $Unit
public "sub"(other: $Unit$Type): $Unit
public "sub"(value: double): $Unit
public "negate"(): $Unit
public "isFixed"(): boolean
public "div"(other: $Unit$Type): $Unit
public "div"(value: double): $Unit
public "sq"(): $Unit
public "mul"(value: double): $Unit
public "mul"(other: $Unit$Type): $Unit
public "bool"(): $Unit
public "deg"(): $Unit
public "smoothstep"(): $Unit
public "rad"(): $Unit
get "fixed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FixedNumberUnit$Type = ($FixedNumberUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FixedNumberUnit_ = $FixedNumberUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$LogType" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"

export class $LogType extends $Enum<($LogType)> {
static readonly "INIT": $LogType
static readonly "DEBUG": $LogType
static readonly "INFO": $LogType
static readonly "WARN": $LogType
static readonly "ERROR": $LogType
static readonly "VALUES": ($LogType)[]
readonly "name": string
readonly "callback": $BiConsumer<($Logger), (string)>


public static "values"(): ($LogType)[]
public static "valueOf"(name: string): $LogType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LogType$Type = (("init") | ("warn") | ("debug") | ("error") | ("info")) | ($LogType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LogType_ = $LogType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabEvent" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CreativeModeTab$TabVisibility, $CreativeModeTab$TabVisibility$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$TabVisibility"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeTabCallback, $CreativeTabCallback$Type} from "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabCallback"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $CreativeTabEvent extends $EventJS {
readonly "tab": $CreativeModeTab
readonly "showRestrictedItems": boolean

constructor(tab: $CreativeModeTab$Type, showRestrictedItems: boolean, callback: $CreativeTabCallback$Type)

public "add"(items: ($ItemStack$Type)[]): void
public "add"(items: ($ItemStack$Type)[], visibility: $CreativeModeTab$TabVisibility$Type): void
public "remove"(filter: $Ingredient$Type): void
public "addBefore"(order: $ItemStack$Type, items: ($ItemStack$Type)[]): void
public "addBefore"(order: $ItemStack$Type, items: ($ItemStack$Type)[], visibility: $CreativeModeTab$TabVisibility$Type): void
public "addAfter"(order: $ItemStack$Type, items: ($ItemStack$Type)[], visibility: $CreativeModeTab$TabVisibility$Type): void
public "addAfter"(order: $ItemStack$Type, items: ($ItemStack$Type)[]): void
public "setDisplayName"(component: $Component$Type): void
public "removeSearch"(filter: $Ingredient$Type): void
public "removeDisplay"(filter: $Ingredient$Type): void
public "setIcon"(icon: $ItemStack$Type): void
set "displayName"(value: $Component$Type)
set "icon"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabEvent$Type = ($CreativeTabEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabEvent_ = $CreativeTabEvent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$MojangMappings$TypeDef, $MojangMappings$TypeDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$TypeDef"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MojangMappings$MethodDefSignature, $MojangMappings$MethodDefSignature$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MethodDefSignature"
import {$MojangMappings$ClassDef, $MojangMappings$ClassDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$ClassDef"

export class $MojangMappings {


public "getClass"(name: string): $MojangMappings$ClassDef
public "write"(stream: $OutputStream$Type): void
public "getType"(string: string): $MojangMappings$TypeDef
public "getSignature"(types: ($MojangMappings$TypeDef$Type)[]): $MojangMappings$MethodDefSignature
public "cleanup"(): void
public static "parse"(mcVersion: string, lines: $List$Type<(string)>): $MojangMappings
public "readSignatureFromDescriptor"(descriptor: string): $MojangMappings$MethodDefSignature
public "getMMClasses"(): $Collection<($MojangMappings$ClassDef)>
public "updateOccurrences"(): void
get "mMClasses"(): $Collection<($MojangMappings$ClassDef)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$Type = ($MojangMappings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings_ = $MojangMappings$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipesEventJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {DocumentedRecipes, DocumentedRecipes$Type} from "packages/moe/wolfgirl/probejs/generated/DocumentedRecipes"
import {Shaped, Shaped$Type} from "packages/moe/wolfgirl/probejs/generated/schema/kubejs/Shaped"
import {$Callable, $Callable$Type} from "packages/java/util/concurrent/$Callable"
import {Stonecutting, Stonecutting$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/Stonecutting"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"
import {SmithingTransform, SmithingTransform$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/SmithingTransform"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {Smelting, Smelting$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/Smelting"
import {Blasting, Blasting$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/Blasting"
import {CampfireCooking, CampfireCooking$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/CampfireCooking"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {Shapeless, Shapeless$Type} from "packages/moe/wolfgirl/probejs/generated/schema/kubejs/Shapeless"
import {$AtomicInteger, $AtomicInteger$Type} from "packages/java/util/concurrent/atomic/$AtomicInteger"
import {Smoking, Smoking$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/Smoking"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {SmithingTrim, SmithingTrim$Type} from "packages/moe/wolfgirl/probejs/generated/schema/minecraft/SmithingTrim"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipesEventJS extends $EventJS {
static readonly "SKIP_ERROR": $Pattern
readonly "originalRecipes": $Map<($ResourceLocation), ($RecipeJS)>
readonly "addedRecipes": $Collection<($RecipeJS)>
readonly "failedCount": $AtomicInteger
readonly "takenIds": $Map<($ResourceLocation), ($RecipeJS)>
readonly "shaped": (result: $OutputItem$Type, pattern: (string)[], key: {[k: string]: $InputItem$Type}) => Shaped
readonly "shapeless": (result: $OutputItem$Type, ingredients: ($InputItem$Type)[]) => Shapeless
readonly "smelting": (result: $OutputItem$Type, ingredient: $InputItem$Type, xp?: number, cookingTime?: (number) | (string)) => Smelting
readonly "blasting": (result: $OutputItem$Type, ingredient: $InputItem$Type, xp?: number, cookingTime?: (number) | (string)) => Blasting
readonly "smoking": (result: $OutputItem$Type, ingredient: $InputItem$Type, xp?: number, cookingTime?: (number) | (string)) => Smoking
readonly "campfireCooking": (result: $OutputItem$Type, ingredient: $InputItem$Type, xp?: number, cookingTime?: (number) | (string)) => CampfireCooking
readonly "stonecutting": (result: $OutputItem$Type, ingredient: $InputItem$Type) => Stonecutting
readonly "smithing": (result: $OutputItem$Type, template: $InputItem$Type, base: $InputItem$Type, addition: $InputItem$Type) => SmithingTransform
readonly "smithingTrim": (template: $InputItem$Type, base: $InputItem$Type, addition: $InputItem$Type) => SmithingTrim

constructor()

public "remove"(filter: $RecipeFilter$Type): void
public "stage"(filter: $RecipeFilter$Type, stage: string): void
public "takeId"(recipe: $RecipeJS$Type, prefix: string, ids: string): $ResourceLocation
public "custom"(json: $JsonObject$Type): $RecipeJS
public static "runInParallel"(runnable: $Runnable$Type): void
public static "runInParallel"<T>(callable: $Callable$Type<(T)>): T
public "getRecipeFunction"(id: string): $RecipeTypeFunction
public "recipeStream"(filter: $RecipeFilter$Type): $Stream<($RecipeJS)>
public "containsRecipe"(filter: $RecipeFilter$Type): boolean
public "findRecipeIds"(filter: $RecipeFilter$Type): $Collection<($ResourceLocation)>
public "forEachRecipe"(filter: $RecipeFilter$Type, consumer: $Consumer$Type<($RecipeJS$Type)>): void
public "countRecipes"(filter: $RecipeFilter$Type): integer
public "findRecipes"(filter: $RecipeFilter$Type): $Collection<($RecipeJS)>
public "printAllTypes"(): void
public "setItemErrors"(b: boolean): void
public "printExamples"(type: string): void
public "customFilter"(filter: $Predicate$Type<($RecipeKJS$Type)>): $RecipeFilter
public "replaceOutput"(filter: $RecipeFilter$Type, match: $ReplacementMatch$Type, arg2: $OutputReplacement$Type): void
public "replaceInput"(filter: $RecipeFilter$Type, match: $ReplacementMatch$Type, arg2: $InputReplacement$Type): void
public "addRecipe"(r: $RecipeJS$Type, json: boolean): $RecipeJS
public "getRecipes"(): DocumentedRecipes
public "printTypes"(): void
set "itemErrors"(value: boolean)
get "recipes"(): DocumentedRecipes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipesEventJS$Type = ($RecipesEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipesEventJS_ = $RecipesEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AlignMode extends $Enum<($AlignMode)> {
static readonly "START": $AlignMode
static readonly "CENTER": $AlignMode
static readonly "END": $AlignMode


public static "values"(): ($AlignMode)[]
public static "valueOf"(name: string): $AlignMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AlignMode$Type = (("center") | ("start") | ("end")) | ($AlignMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AlignMode_ = $AlignMode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuInventoryClickEvent$Callback" {
import {$ChestMenuInventoryClickEvent, $ChestMenuInventoryClickEvent$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuInventoryClickEvent"

export interface $ChestMenuInventoryClickEvent$Callback {

 "onClick"(arg0: $ChestMenuInventoryClickEvent$Type): void

(arg0: $ChestMenuInventoryClickEvent$Type): void
}

export namespace $ChestMenuInventoryClickEvent$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Callback$Type = ($ChestMenuInventoryClickEvent$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuInventoryClickEvent$Callback_ = $ChestMenuInventoryClickEvent$Callback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$OutputFluid, $OutputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid"
import {$IngredientActionFilter, $IngredientActionFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientActionFilter"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeJS implements $RecipeKJS, $CustomJavaToJsWrapper {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "group"(g: string): $RecipeJS
public "remove"(): void
public "get"(key: string): any
public "toString"(): string
public "getValue"<T>(key: $RecipeKey$Type<(T)>): T
public "merge"(j: $JsonObject$Type): $RecipeJS
public "id"(_id: $ResourceLocation$Type): $RecipeJS
public "set"(key: string, value: any): $RecipeJS
public "getId"(): string
public "save"(): void
public "setValue"<T>(key: $RecipeKey$Type<(T)>, value: T): $RecipeJS
public "getPath"(): string
public "stage"(s: string): $RecipeJS
public "deserialize"(merge: boolean): void
public "inputFluidHasPriority"(from: any): boolean
public "outputItemHasPriority"(from: any): boolean
public "inputItemHasPriority"(from: any): boolean
/**
 * 
 * @deprecated
 */
public "getType"(): $ResourceLocation
public "readOutputFluid"(from: any): $OutputFluid
public "writeOutputFluid"(value: $OutputFluid$Type): $JsonElement
public "outputValues"(): ($RecipeComponentValue<(any)>)[]
public "inputValues"(): ($RecipeComponentValue<(any)>)[]
public "initValues"(created: boolean): void
public "afterLoaded"(): void
public "getFromToString"(): string
public "getAllValueMap"(): $Map<(string), ($RecipeComponentValue<(any)>)>
public "convertJavaToJs"(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>): $Scriptable
public "keepIngredient"(filter: $IngredientActionFilter$Type): $RecipeJS
public "consumeIngredient"(filter: $IngredientActionFilter$Type): $RecipeJS
public "replaceIngredient"(filter: $IngredientActionFilter$Type, item: $ItemStack$Type): $RecipeJS
public "getOriginalRecipe"(): $Recipe<(any)>
public "ingredientAction"(filter: $IngredientActionFilter$Type, action: $IngredientAction$Type): $RecipeJS
public "damageIngredient"(filter: $IngredientActionFilter$Type, damage: integer): $RecipeJS
public "damageIngredient"(filter: $IngredientActionFilter$Type): $RecipeJS
public "getSerializationTypeFunction"(): $RecipeTypeFunction
public "getOriginalRecipeResult"(): $ItemStack
public "customIngredientAction"(filter: $IngredientActionFilter$Type, id: string): $RecipeJS
public "getOriginalRecipeIngredients"(): $List<($Ingredient)>
public "hasChanged"(): boolean
public "serialize"(): void
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
/**
 * 
 * @deprecated
 */
public "setGroup"(group: string): void
public "hasInput"(match: $ReplacementMatch$Type): boolean
/**
 * 
 * @deprecated
 */
public "getOrCreateId"(): $ResourceLocation
/**
 * 
 * @deprecated
 */
public "getSchema"(): $RecipeSchema
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
/**
 * 
 * @deprecated
 */
public "getGroup"(): string
public "readInputFluid"(from: any): $InputFluid
public "writeInputFluid"(value: $InputFluid$Type): $JsonElement
public "writeInputItem"(value: $InputItem$Type): $JsonElement
public "readInputItem"(from: any): $InputItem
public "readOutputItem"(from: any): $OutputItem
public "writeOutputItem"(value: $OutputItem$Type): $JsonElement
public "modifyResult"(callback: $ModifyRecipeResultCallback$Type): $RecipeJS
public "createRecipe"(): $Recipe<(any)>
public "outputFluidHasPriority"(from: any): boolean
public "getMod"(): string
get "path"(): string
get "type"(): $ResourceLocation
get "fromToString"(): string
get "allValueMap"(): $Map<(string), ($RecipeComponentValue<(any)>)>
get "originalRecipe"(): $Recipe<(any)>
get "serializationTypeFunction"(): $RecipeTypeFunction
get "originalRecipeResult"(): $ItemStack
get "originalRecipeIngredients"(): $List<($Ingredient)>
get "orCreateId"(): $ResourceLocation
get "schema"(): $RecipeSchema
get "mod"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeJS$Type = ($RecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeJS_ = $RecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Wrapper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Wrapper {

 "unwrap"(): any

(): any
}

export namespace $Wrapper {
function unwrapped(o: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Wrapper$Type = ($Wrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Wrapper_ = $Wrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$LevelEventJS, $LevelEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$LevelEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntityEventJS extends $LevelEventJS {

constructor()

public "getLevel"(): $Level
public "getPlayer"(): $Player
public "getEntity"(): $Entity
get "level"(): $Level
get "player"(): $Player
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEventJS$Type = ($EntityEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEventJS_ = $EntityEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$JavaAdapter" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ObjToIntMap, $ObjToIntMap$Type} from "packages/dev/latvian/mods/rhino/$ObjToIntMap"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $JavaAdapter implements $IdFunctionCall {

constructor()

public static "init"(cx: $Context$Type, scope: $Scriptable$Type, sealed: boolean): void
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public static "getAdapterSelf"(adapterClass: $Class$Type<(any)>, adapter: any): any
public static "convertResult"(cx: $Context$Type, result: any, c: $Class$Type<(any)>): any
public static "createAdapterCode"(functionNames: $ObjToIntMap$Type, adapterName: string, superClass: $Class$Type<(any)>, interfaces: ($Class$Type<(any)>)[], scriptClassName: string, cx: $Context$Type): (byte)[]
public static "createAdapterWrapper"(obj: $Scriptable$Type, adapter: any, cx: $Context$Type): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaAdapter$Type = ($JavaAdapter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaAdapter_ = $JavaAdapter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$RecipeComponentWithParent, $RecipeComponentWithParent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentWithParent"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MappingRecipeComponent<T> implements $RecipeComponentWithParent<(T)> {

constructor(parent: $RecipeComponent$Type<(T)>, mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>)

public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: T): $JsonElement
public "read"(recipe: $RecipeJS$Type, from: any): T
public "parentComponent"(): $RecipeComponent<(T)>
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
public "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(T)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
public "asArray"(): $ArrayRecipeComponent<(T)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
public "orSelf"(): $RecipeComponent<(T)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
public "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MappingRecipeComponent$Type<T> = ($MappingRecipeComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MappingRecipeComponent_<T> = $MappingRecipeComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/item/ingredient/$IngredientWithCustomPredicate" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $IngredientWithCustomPredicate {
readonly "parent": $Ingredient
readonly "uuid": $UUID
readonly "predicate": $Predicate<($ItemStack)>

constructor(parent: $Ingredient$Type, uuid: $UUID$Type, predicate: $Predicate$Type<($ItemStack$Type)>)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientWithCustomPredicate$Type = ($IngredientWithCustomPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientWithCustomPredicate_ = $IngredientWithCustomPredicate$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerRespawnedEventJS" {
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"

/**
 * Invoked when a player respawns.
 * 
 * The reason of respawn can be either death or returning from the end.
 */
export class $PlayerRespawnedEventJS extends $PlayerEventJS {

constructor(player: $ServerPlayer$Type, oldPlayer: $ServerPlayer$Type, keepData: boolean)

/**
 * Gets the player that was before respawn. Note that this entity is already removed from the world.
 */
public "getOldPlayer"(): $ServerPlayer
/**
 * Gets whether the player's data was kept, e.g. when returning from the end.
 */
public "getKeepData"(): boolean
get "oldPlayer"(): $ServerPlayer
get "keepData"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerRespawnedEventJS$Type = ($PlayerRespawnedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerRespawnedEventJS_ = $PlayerRespawnedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$InputItem" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$IngredientSupplierKJS"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$JsonSerializable, $JsonSerializable$Type} from "packages/dev/latvian/mods/rhino/mod/util/$JsonSerializable"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $InputItem implements $IngredientSupplierKJS, $InputReplacement, $JsonSerializable {
static readonly "EMPTY": $InputItem
static readonly "PARSE_CACHE": $Map<(string), ($InputItem)>
readonly "ingredient": $Ingredient
readonly "count": integer


public "toString"(): string
public "isEmpty"(): boolean
public static "of"(ingredient: $Ingredient$Type, count: integer): $InputItem
public static "of"(o: $InputItem$Type): $InputItem
public "unwrap"(): $List<($InputItem)>
public "kjs$asIngredient"(): $Ingredient
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
public "withCount"(count: integer): $InputItem
public "validForMatching"(): boolean
public "toJson"(alwaysNest: boolean): $JsonElement
public "toJson"(): $JsonElement
public "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputItem$Type = ($Ingredient$Type) | (`${number}x ${Special.Item}`) | ($InputItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputItem_ = $InputItem$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$ReplaceAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ReplaceAction extends $IngredientAction {
readonly "item": $ItemStack
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor(a: $ItemStack$Type)

public "transform"(old: $ItemStack$Type, index: integer, container: $CraftingContainer$Type): $ItemStack
public "getType"(): string
public "toJson"(json: $JsonObject$Type): void
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplaceAction$Type = ($ReplaceAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplaceAction_ = $ReplaceAction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$ModIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $ModIngredient extends $KubeJSIngredient {
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($ModIngredient)>
readonly "mod": string
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(mod: string)

public "test"(stack: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getSerializer"(): $IIngredientSerializer<(any)>
public static "ofModFromNetwork"(buf: $FriendlyByteBuf$Type): $ModIngredient
public static "ofModFromJson"(json: $JsonObject$Type): $ModIngredient
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModIngredient$Type = ($ModIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModIngredient_ = $ModIngredient$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeFunction extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()

public "getLength"(): integer
public "resumeGenerator"(cx: $Context$Type, scope: $Scriptable$Type, operation: integer, state: any, value: any): any
public "initScriptFunction"(cx: $Context$Type, scope: $Scriptable$Type, es6GeneratorFunction: boolean): void
public "initScriptFunction"(cx: $Context$Type, scope: $Scriptable$Type): void
public "getArity"(): integer
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeFunction$Type = ($NativeFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeFunction_ = $NativeFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$WrappedJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJS {

}

export namespace $WrappedJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJS$Type = ($WrappedJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedJS_ = $WrappedJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$Lazy" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $Lazy<T> implements $Supplier<(T)> {


public "get"(): T
public static "of"<T>(supplier: $Supplier$Type<(T)>): $Lazy<(T)>
public static "of"<T>(supplier: $Supplier$Type<(T)>, expiresInMs: long): $Lazy<(T)>
public "forget"(): void
public static "serviceLoader"<T>(type: $Class$Type<(T)>): $Lazy<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Lazy$Type<T> = ($Lazy<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Lazy_<T> = $Lazy$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$ShapelessKubeJSRecipe$SerializerKJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ShapelessKubeJSRecipe, $ShapelessKubeJSRecipe$Type} from "packages/dev/latvian/mods/kubejs/recipe/special/$ShapelessKubeJSRecipe"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $ShapelessKubeJSRecipe$SerializerKJS implements $RecipeSerializer<($ShapelessKubeJSRecipe)> {

constructor()

public "fromJson"(id: $ResourceLocation$Type, json: $JsonObject$Type): $ShapelessKubeJSRecipe
public "fromNetwork"(id: $ResourceLocation$Type, buf: $FriendlyByteBuf$Type): $ShapelessKubeJSRecipe
public "toNetwork"(buf: $FriendlyByteBuf$Type, r: $ShapelessKubeJSRecipe$Type): void
public static "register"<S extends $RecipeSerializer<(T)>, T extends $Recipe<(any)>>(arg0: string, arg1: S): S
public "fromJson"(arg0: $ResourceLocation$Type, arg1: $JsonObject$Type, arg2: $ICondition$IContext$Type): $ShapelessKubeJSRecipe
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$SerializerKJS$Type = ($ShapelessKubeJSRecipe$SerializerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessKubeJSRecipe$SerializerKJS_ = $ShapelessKubeJSRecipe$SerializerKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$Painter" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$MutableNumberUnit, $MutableNumberUnit$Type} from "packages/dev/latvian/mods/unit/$MutableNumberUnit"
import {$VariableSet, $VariableSet$Type} from "packages/dev/latvian/mods/unit/$VariableSet"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$PainterObject, $PainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObject"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$UnitContext, $UnitContext$Type} from "packages/dev/latvian/mods/unit/$UnitContext"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"

export class $Painter implements $UnitVariables {
static readonly "INSTANCE": $Painter
readonly "id": string
readonly "unitContext": $UnitContext
readonly "deltaUnit": $MutableNumberUnit
readonly "screenWidthUnit": $MutableNumberUnit
readonly "screenHeightUnit": $MutableNumberUnit
readonly "mouseXUnit": $MutableNumberUnit
readonly "mouseYUnit": $MutableNumberUnit
readonly "defaultLineSizeUnit": $MutableNumberUnit

constructor(id: string)

public "clear"(): void
public "make"(type: string): $PainterObject
public "getObject"(key: string): $PainterObject
public "getVariables"(): $VariableSet
public "setVariable"(key: string, variable: $Unit$Type): void
public "guiScreenDraw"(screen: $Screen$Type, graphics: $GuiGraphics$Type, mouseX: integer, mouseY: integer, delta: float): void
public "inGameScreenDraw"(graphics: $GuiGraphics$Type, delta: float): void
public "paint"(root: $CompoundTag$Type): void
public "unitOf"(console: $ConsoleJS$Type, o: any): $Unit
public "unitOf"(cx: $Context$Type, o: any): $Unit
public "registerBuiltinObjects"(): void
get "variables"(): $VariableSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Painter$Type = ($Painter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Painter_ = $Painter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$CraftingContainerKJS" {
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"

export interface $CraftingContainerKJS {

 "getMenu"(): $AbstractContainerMenu
}

export namespace $CraftingContainerKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CraftingContainerKJS$Type = ($CraftingContainerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CraftingContainerKJS_ = $CraftingContainerKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ServerPlayerKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ChestMenuData, $ChestMenuData$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuData"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NotificationBuilder, $NotificationBuilder$Type} from "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityPotionEffectsJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$KubeJSGUI, $KubeJSGUI$Type} from "packages/dev/latvian/mods/kubejs/gui/$KubeJSGUI"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$Type} from "packages/dev/latvian/mods/kubejs/player/$KubeJSInventoryListener"
import {$PlayerStatsJS, $PlayerStatsJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerStatsJS"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$PlayerKJS, $PlayerKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$PlayerKJS"

export interface $ServerPlayerKJS extends $PlayerKJS {

 "setMouseItem"(item: $ItemStack$Type): void
 "isMiningBlock"(): boolean
 "getStats"(): $PlayerStatsJS
 "paint"(renderer: $CompoundTag$Type): void
 "notify"(builder: $NotificationBuilder$Type): void
 "sendData"(channel: string, data: $CompoundTag$Type): void
 "kick"(reason: $Component$Type): void
 "kick"(): void
 "isOp"(): boolean
 "ban"(banner: string, reason: string, expiresInMillis: long): void
 "openGUI"(gui: $Consumer$Type<($KubeJSGUI$Type)>): void
 "openChestGUI"(title: $Component$Type, rows: integer, gui: $Consumer$Type<($ChestMenuData$Type)>): void
 "setSelectedSlot"(index: integer): void
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "setCreativeMode"(mode: boolean): void
 "isAdvancementDone"(id: $ResourceLocation$Type): boolean
 "revokeAdvancement"(id: $ResourceLocation$Type): void
 "openInventoryGUI"(inventory: $InventoryKJS$Type, title: $Component$Type): void
 "getSpawnLocation"(): $BlockContainerJS
 "unlockAdvancement"(id: $ResourceLocation$Type): void
 "setSpawnLocation"(c: $BlockContainerJS$Type): void
 "captureInventory"(autoRestore: boolean): $Container
 "getInventory"(): $InventoryKJS
 "getStages"(): $Stages
 "isFake"(): boolean
 "getProfile"(): $GameProfile
 "give"(item: $ItemStack$Type): void
 "getMouseItem"(): $ItemStack
 "spawn"(): void
 "addFood"(f: integer, m: float): void
 "giveInHand"(item: $ItemStack$Type): void
 "getFoodLevel"(): integer
 "isPlayer"(): boolean
 "notify"(title: $Component$Type, text: $Component$Type): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "getSaturation"(): float
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "getXp"(): integer
 "setSaturation"(saturation: float): void
 "setXp"(xp: integer): void
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setStatusMessage"(message: $Component$Type): void
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "sendInventoryUpdate"(): void
 "getSelectedSlot"(): integer
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$Type, ticks: integer): void
 "foodEaten"(is: $ItemStack$Type): void
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "isLiving"(): boolean
 "getEquipment"(slot: $EquipmentSlot$Type): $ItemStack
 "setEquipment"(slot: $EquipmentSlot$Type, item: $ItemStack$Type): void
 "swing"(): void
 "swing"(hand: $InteractionHand$Type): void
 "setOffHandItem"(item: $ItemStack$Type): void
 "getOffHandItem"(): $ItemStack
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(hand: $InteractionHand$Type, item: $ItemStack$Type): void
 "getHeldItem"(hand: $InteractionHand$Type): $ItemStack
 "rayTrace"(): $RayTraceResultJS
 "getHeadArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getDefaultMovementSpeed"(): double
 "getReachDistance"(): double
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setMovementSpeedAddition"(speed: double): void
 "isHoldingInAnyHand"(i: $Ingredient$Type): boolean
 "setLegsArmorItem"(item: $ItemStack$Type): void
 "setFeetArmorItem"(item: $ItemStack$Type): void
 "setHeadArmorItem"(item: $ItemStack$Type): void
 "getMainHandItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "removeAttribute"(attribute: $Attribute$Type, identifier: string): void
 "setDefaultMovementSpeed"(speed: double): void
 "damageEquipment"(slot: $EquipmentSlot$Type): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "getAttributeBaseValue"(attribute: $Attribute$Type): double
 "setChestArmorItem"(item: $ItemStack$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getAttributeTotalValue"(attribute: $Attribute$Type): double
 "modifyAttribute"(attribute: $Attribute$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): void
 "setMainHandItem"(item: $ItemStack$Type): void
 "getChestArmorItem"(): $ItemStack
 "canEntityBeSeen"(entity: $LivingEntity$Type): boolean
 "setAttributeBaseValue"(attribute: $Attribute$Type, value: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: string): void
 "getData"(): $AttachedData<($Player)>
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getItem"(): $ItemStack
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag

(item: $ItemStack$Type): void
}

export namespace $ServerPlayerKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerPlayerKJS$Type = ($ServerPlayerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerPlayerKJS_ = $ServerPlayerKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeWith" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$SymbolScriptable, $SymbolScriptable$Type} from "packages/dev/latvian/mods/rhino/$SymbolScriptable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $NativeWith implements $Scriptable, $SymbolScriptable, $IdFunctionCall {


public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, id: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, symbol: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, id: string, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, id: string): void
public "delete"(cx: $Context$Type, index: integer): void
public "delete"(cx: $Context$Type, key: $Symbol$Type): void
public "getDefaultValue"(cx: $Context$Type, typeHint: $Class$Type<(any)>): any
public "getClassName"(): string
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, id: string, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "setParentScope"(parent: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getIds"(cx: $Context$Type): (any)[]
public "hasInstance"(cx: $Context$Type, value: $Scriptable$Type): boolean
public "getPrototype"(cx: $Context$Type): $Scriptable
public "setPrototype"(prototype: $Scriptable$Type): void
public "getAllIds"(cx: $Context$Type): (any)[]
public "getTypeOf"(): $MemberType
public "enumerationIteratorHasNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
public "enumerationIteratorNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
get "className"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
get "typeOf"(): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeWith$Type = ($NativeWith);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeWith_ = $NativeWith$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$AbstractIngredient, $AbstractIngredient$Type} from "packages/net/minecraftforge/common/crafting/$AbstractIngredient"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientKJS, $IngredientKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$IngredientKJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $KubeJSIngredient extends $AbstractIngredient implements $IngredientKJS {
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor()

public "write"(arg0: $FriendlyByteBuf$Type): void
public "toJson"(arg0: $JsonObject$Type): void
public "toJson"(): $JsonObject
public "isSimple"(): boolean
public "isEmpty"(): boolean
public "canBeUsedForMatching"(): boolean
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "simple"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSIngredient$Type = ($KubeJSIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSIngredient_ = $KubeJSIngredient$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnitToken" {
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export interface $UnitToken {

 "nextUnaryOperator"(): boolean
 "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
 "interpret"(stream: $UnitTokenStream$Type): $Unit
}

export namespace $UnitToken {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitToken$Type = ($UnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitToken_ = $UnitToken$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$ExplosionJS" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$Level$ExplosionInteraction, $Level$ExplosionInteraction$Type} from "packages/net/minecraft/world/level/$Level$ExplosionInteraction"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $ExplosionJS {
readonly "x": double
readonly "y": double
readonly "z": double
 "exploder": $Entity
 "strength": float
 "causesFire": boolean
 "explosionMode": $Level$ExplosionInteraction

constructor(l: $LevelAccessor$Type, _x: double, _y: double, _z: double)

public "explosionMode"(mode: $Level$ExplosionInteraction$Type): $ExplosionJS
public "causesFire"(b: boolean): $ExplosionJS
public "exploder"(entity: $Entity$Type): $ExplosionJS
public "strength"(f: float): $ExplosionJS
public "explode"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionJS$Type = ($ExplosionJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionJS_ = $ExplosionJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$XorOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $XorOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $XorOpUnit$Type = ($XorOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $XorOpUnit_ = $XorOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ConditionalExpression" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ConditionalExpression extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getQuestionMarkPosition"(): integer
public "setQuestionMarkPosition"(questionMarkPosition: integer): void
public "hasSideEffects"(): boolean
public "setColonPosition"(colonPosition: integer): void
public "setTestExpression"(testExpression: $AstNode$Type): void
public "getTestExpression"(): $AstNode
public "getColonPosition"(): integer
public "getTrueExpression"(): $AstNode
public "setFalseExpression"(falseExpression: $AstNode$Type): void
public "getFalseExpression"(): $AstNode
public "setTrueExpression"(trueExpression: $AstNode$Type): void
get "questionMarkPosition"(): integer
set "questionMarkPosition"(value: integer)
set "colonPosition"(value: integer)
set "testExpression"(value: $AstNode$Type)
get "testExpression"(): $AstNode
get "colonPosition"(): integer
get "trueExpression"(): $AstNode
set "falseExpression"(value: $AstNode$Type)
get "falseExpression"(): $AstNode
set "trueExpression"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalExpression$Type = ($ConditionalExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalExpression_ = $ConditionalExpression$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/rei/$REIEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $REIEvents {

}

export namespace $REIEvents {
const GROUP: $EventGroup
const HIDE: $EventHandler
const ADD: $EventHandler
const INFORMATION: $EventHandler
const REMOVE_CATEGORIES: $EventHandler
const REMOVE_RECIPES: $EventHandler
const GROUP_ENTRIES: $EventHandler
function register(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $REIEvents$Type = ($REIEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $REIEvents_ = $REIEvents$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$RemapperException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $RemapperException extends $RuntimeException {

constructor(message: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemapperException$Type = ($RemapperException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemapperException_ = $RemapperException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"

export interface $BlockEntityAttachment {

 "readAttachment"(tag: $CompoundTag$Type): void
 "writeAttachment"(): $CompoundTag
 "onRemove"(newState: $BlockState$Type): void
}

export namespace $BlockEntityAttachment {
const EMPTY_ARRAY: ($BlockEntityAttachment)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachment$Type = ($BlockEntityAttachment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachment_ = $BlockEntityAttachment$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS$Entry" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"

export class $ObjectDescJS$Entry extends $Record {

constructor(key: string, value: $TypeDescJS$Type, optional: boolean)
constructor(key: string, value: $TypeDescJS$Type, optional: boolean, wrap: boolean)

public "value"(): $TypeDescJS
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "wrap"(): boolean
public "key"(): string
public "optional"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectDescJS$Entry$Type = ($ObjectDescJS$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectDescJS$Entry_ = $ObjectDescJS$Entry$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$RemappingHelper$MappingContext" {
import {$MojangMappings, $MojangMappings$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings"
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $RemappingHelper$MappingContext extends $Record {

constructor(mcVersion: string, mappings: $MojangMappings$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "mappings"(): $MojangMappings
public "mcVersion"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemappingHelper$MappingContext$Type = ($RemappingHelper$MappingContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemappingHelper$MappingContext_ = $RemappingHelper$MappingContext$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeNumber" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeNumber extends $IdScriptableObject {
static readonly "MAX_SAFE_INTEGER": double
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "toString"(): string
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getTypeOf"(): $MemberType
get "className"(): string
get "typeOf"(): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeNumber$Type = ($NativeNumber);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeNumber_ = $NativeNumber$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventResult$Type" {
import {$EventExit, $EventExit$Type} from "packages/dev/latvian/mods/kubejs/event/$EventExit"
import {$EventResult, $EventResult$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$EventResult as $EventResult$0, $EventResult$Type as $EventResult$0$Type} from "packages/dev/architectury/event/$EventResult"

export class $EventResult$Type extends $Enum<($EventResult$Type)> {
static readonly "ERROR": $EventResult$Type
static readonly "PASS": $EventResult$Type
static readonly "INTERRUPT_DEFAULT": $EventResult$Type
static readonly "INTERRUPT_FALSE": $EventResult$Type
static readonly "INTERRUPT_TRUE": $EventResult$Type
readonly "defaultResult": $EventResult
readonly "defaultArchResult": $EventResult$0
readonly "defaultExit": $EventExit


public "exit"(value: any): $EventExit
public static "values"(): ($EventResult$Type)[]
public static "valueOf"(name: string): $EventResult$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type$Type = (("interrupt_default") | ("pass") | ("interrupt_false") | ("interrupt_true") | ("error")) | ($EventResult$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventResult$Type_ = $EventResult$Type$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$LevelEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $LevelEvents {

}

export namespace $LevelEvents {
const GROUP: $EventGroup
const LOADED: $EventHandler
const UNLOADED: $EventHandler
const TICK: $EventHandler
const BEFORE_EXPLOSION: $EventHandler
const AFTER_EXPLOSION: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelEvents$Type = ($LevelEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelEvents_ = $LevelEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ScreenDrawMode extends $Enum<($ScreenDrawMode)> {
static readonly "ALWAYS": $ScreenDrawMode
static readonly "INGAME": $ScreenDrawMode
static readonly "GUI": $ScreenDrawMode


public static "values"(): ($ScreenDrawMode)[]
public static "valueOf"(name: string): $ScreenDrawMode
public "ingame"(): boolean
public "gui"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenDrawMode$Type = (("always") | ("gui") | ("ingame")) | ($ScreenDrawMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenDrawMode_ = $ScreenDrawMode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$ShapelessRecipeSchema$ShapelessRecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ShapelessRecipeSchema$ShapelessRecipeJS extends $RecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "getSerializationTypeFunction"(): $RecipeTypeFunction
get "serializationTypeFunction"(): $RecipeTypeFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessRecipeSchema$ShapelessRecipeJS$Type = ($ShapelessRecipeSchema$ShapelessRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessRecipeSchema$ShapelessRecipeJS_ = $ShapelessRecipeSchema$ShapelessRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$SpecialRecipeSerializerManager" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"

export class $SpecialRecipeSerializerManager extends $EventJS {
static readonly "INSTANCE": $SpecialRecipeSerializerManager
static readonly "EVENT": $Event<($Runnable)>

constructor()

public "reset"(): void
public "ignoreSpecialMod"(modid: string): void
public "addSpecialFlag"(id: $ResourceLocation$Type): void
public "addSpecialMod"(modid: string): void
public "ignoreSpecialFlag"(id: $ResourceLocation$Type): void
public "isSpecial"(recipe: $Recipe$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSerializerManager$Type = ($SpecialRecipeSerializerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialRecipeSerializerManager_ = $SpecialRecipeSerializerManager$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddLakeProperties" {
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $AddLakeProperties {
 "id": $ResourceLocation
 "worldgenLayer": $GenerationStep$Decoration
 "biomes": $BiomeFilter
 "fluid": $BlockStatePredicate
 "barrier": $BlockStatePredicate
 "chance": integer
 "retrogen": integer

constructor()

public "setInner"(p: $BlockStatePredicate$Type): void
public "setOuter"(p: $BlockStatePredicate$Type): void
set "inner"(value: $BlockStatePredicate$Type)
set "outer"(value: $BlockStatePredicate$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddLakeProperties$Type = ($AddLakeProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddLakeProperties_ = $AddLakeProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyCallbackJS" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$BooleanProperty, $BooleanProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$BooleanProperty"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$StringRepresentable, $StringRepresentable$Type} from "packages/net/minecraft/util/$StringRepresentable"
import {$EnumProperty, $EnumProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$EnumProperty"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$ImmutableMap, $ImmutableMap$Type} from "packages/com/google/common/collect/$ImmutableMap"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockStateModifyCallbackJS {

constructor(state: $BlockState$Type)

/**
 * Gets the value of the pased in property
 */
public "get"<T extends $Comparable<(T)>>(property: $Property$Type<(T)>): T
public "toString"(): string
/**
 * Gets the value of the passed in property
 */
public "getValue"<T extends $Comparable<(T)>>(property: $Property$Type<(T)>): T
/**
 * Sets the value of the specified boolean property
 */
public "set"(property: $BooleanProperty$Type, value: boolean): $BlockStateModifyCallbackJS
/**
 * Sets the value of the specified integer property
 */
public "set"(property: $IntegerProperty$Type, value: integer): $BlockStateModifyCallbackJS
/**
 * Sets the value of the specified enum property
 */
public "set"<T extends ($Enum<(T)>) & ($StringRepresentable)>(property: $EnumProperty$Type<(T)>, value: string): $BlockStateModifyCallbackJS
/**
 * Get the properties this block has that can be changed
 */
public "getProperties"(): $Collection<($Property<(any)>)>
/**
 * Gets the state. If it has been modified, gets the new state
 */
public "getState"(): $BlockState
/**
 * Sets the value of the specified property
 */
public "setValue"<T extends $Comparable<(T)>, V extends T>(property: $Property$Type<(T)>, comparable: V): $BlockStateModifyCallbackJS
/**
 * Rotate the block using the specified Rotation
 */
public "rotate"(rotation: $Rotation$Type): $BlockStateModifyCallbackJS
/**
 * Cycles the property
 */
public "cycle"<T extends $Comparable<(T)>>(property: $Property$Type<(T)>): $BlockStateModifyCallbackJS
/**
 * Checks if this block has the specified property
 */
public "hasProperty"<T extends $Comparable<(T)>>(property: $Property$Type<(T)>): boolean
/**
 * Mirror the block using the specified Mirror
 */
public "mirror"(mirror: $Mirror$Type): $BlockStateModifyCallbackJS
/**
 * Updates the shape of this block. Mostly used in waterloggable blocks to update the water flow
 */
public "updateShape"(direction: $Direction$Type, blockState: $BlockState$Type, levelAccessor: $LevelAccessor$Type, blockPos: $BlockPos$Type, blockPos2: $BlockPos$Type): $BlockStateModifyCallbackJS
public "populateNeighbours"(map: $Map$Type<($Map$Type<($Property$Type<(any)>), ($Comparable$Type<(any)>)>), ($BlockState$Type)>): $BlockStateModifyCallbackJS
/**
 * Get a map of this blocks properties to it's value
 */
public "getValues"(): $ImmutableMap<($Property<(any)>), ($Comparable<(any)>)>
/**
 * Gets the value of the passed in property as an Optional. If the property does not exist in this block the Optional will be empty
 */
public "getOptionalValue"<T extends $Comparable<(T)>>(property: $Property$Type<(T)>): $Optional<(T)>
get "properties"(): $Collection<($Property<(any)>)>
get "state"(): $BlockState
get "values"(): $ImmutableMap<($Property<(any)>), ($Comparable<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyCallbackJS$Type = ($BlockStateModifyCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateModifyCallbackJS_ = $BlockStateModifyCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ImageButtonKJS" {
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $ImageButtonKJS {

 "kjs$getButtonTexture"(): $ResourceLocation

(): $ResourceLocation
}

export namespace $ImageButtonKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ImageButtonKJS$Type = ($ImageButtonKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ImageButtonKJS_ = $ImageButtonKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ConstProperties" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $ConstProperties {

 "isConst"(arg0: string): boolean
 "putConst"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type, arg3: any): void
 "defineConst"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type): void
}

export namespace $ConstProperties {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstProperties$Type = ($ConstProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstProperties_ = $ConstProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$KubeJSClient" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ConsoleLine, $ConsoleLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$File, $File$Type} from "packages/java/io/$File"
import {$KubeJSCommon, $KubeJSCommon$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSCommon"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ExportablePackResources, $ExportablePackResources$Type} from "packages/dev/latvian/mods/kubejs/script/data/$ExportablePackResources"

export class $KubeJSClient extends $KubeJSCommon {

constructor()

public "init"(): void
public "export"(packs: $List$Type<($ExportablePackResources$Type)>): void
public "reloadConfig"(): void
public "reloadLang"(): void
public "generateTypings"(source: $CommandSourceStack$Type): void
public "openErrors"(type: $ScriptType$Type): void
public "openErrors"(type: $ScriptType$Type, errors: $List$Type<($ConsoleLine$Type)>, warnings: $List$Type<($ConsoleLine$Type)>): void
public "reloadTextures"(): void
public "clientSetup"(): void
public static "copyDefaultOptionsFile"(optionsFile: $File$Type): void
public "getClientPlayer"(): $Player
public static "reloadClientScripts"(): void
public "reloadStartupScripts"(dedicated: boolean): void
public "handleDataFromServerPacket"(channel: string, data: $CompoundTag$Type): void
public "reloadClientInternal"(): void
public "paint"(tag: $CompoundTag$Type): void
get "clientPlayer"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSClient$Type = ($KubeJSClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSClient_ = $KubeJSClient$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/mixin/forge/$RecipeManagerAccessor" {
import {$ICondition$IContext, $ICondition$IContext$Type} from "packages/net/minecraftforge/common/crafting/conditions/$ICondition$IContext"

export interface $RecipeManagerAccessor {

 "getContext"(): $ICondition$IContext

(): $ICondition$IContext
}

export namespace $RecipeManagerAccessor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeManagerAccessor$Type = ($RecipeManagerAccessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeManagerAccessor_ = $RecipeManagerAccessor$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$DebugInfoEventJS" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClientEventJS, $ClientEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$ClientEventJS"

/**
 * Invoked when the debug info is rendered.
 */
export class $DebugInfoEventJS extends $ClientEventJS {

constructor(l: $List$Type<(string)>)

/**
 * The lines of debug info. Mutating this list will change the debug info.
 */
public "getLines"(): $List<(string)>
/**
 * Whether the debug info should be rendered.
 */
public "getShowDebug"(): boolean
get "lines"(): $List<(string)>
get "showDebug"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DebugInfoEventJS$Type = ($DebugInfoEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DebugInfoEventJS_ = $DebugInfoEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$AfterEntityFallenOnBlockCallbackJS" {
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$EntitySteppedOnBlockCallbackJS"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $AfterEntityFallenOnBlockCallbackJS extends $EntitySteppedOnBlockCallbackJS {

constructor(blockGetter: $BlockGetter$Type, entity: $Entity$Type)

/**
 * Returns the Vec3 of the entity's velocity. Use .x, .y and .z to get the respective components of that
 */
public "getVelocity"(): $Vec3
/**
 * Sets the entity's velocity
 */
public "setVelocity"(vec: $Vec3$Type): void
/**
 * Sets the entity's velocity
 */
public "setVelocity"(x: float, y: float, z: float): void
/**
 * Bounce the entity upwards by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounce"(bounciness: float): void
get "velocity"(): $Vec3
set "velocity"(value: $Vec3$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterEntityFallenOnBlockCallbackJS$Type = ($AfterEntityFallenOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterEntityFallenOnBlockCallbackJS_ = $AfterEntityFallenOnBlockCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeCraftingGrid" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ModifyRecipeCraftingGrid {

constructor(c: $CraftingContainer$Type)

public "get"(index: integer): $ItemStack
public "find"(ingredient: $Ingredient$Type, skip: integer): $ItemStack
public "find"(ingredient: $Ingredient$Type): $ItemStack
public "findAll"(): $List<($ItemStack)>
public "findAll"(ingredient: $Ingredient$Type): $List<($ItemStack)>
public "getWidth"(): integer
public "getHeight"(): integer
public "getPlayer"(): $Player
public "getMenu"(): $AbstractContainerMenu
get "width"(): integer
get "height"(): integer
get "player"(): $Player
get "menu"(): $AbstractContainerMenu
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyRecipeCraftingGrid$Type = ($ModifyRecipeCraftingGrid);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifyRecipeCraftingGrid_ = $ModifyRecipeCraftingGrid$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$PressurePlateBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$BlockSetType, $BlockSetType$Type} from "packages/net/minecraft/world/level/block/state/properties/$BlockSetType"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $PressurePlateBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "behaviour"(wt: $BlockSetType$Type): $PressurePlateBlockBuilder
public "behaviour"(wt: string): $PressurePlateBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PressurePlateBlockBuilder$Type = ($PressurePlateBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PressurePlateBlockBuilder_ = $PressurePlateBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$JavaIteratorWrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$IdEnumerationIterator, $IdEnumerationIterator$Type} from "packages/dev/latvian/mods/rhino/$IdEnumerationIterator"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $JavaIteratorWrapper extends $Record implements $IdEnumerationIterator {

constructor(parent: $Iterator$Type<(any)>)

public "parent"(): $Iterator<(any)>
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "enumerationIteratorHasNext"(cx: $Context$Type, callback: $Consumer$Type<(any)>): boolean
public "enumerationIteratorNext"(cx: $Context$Type, callback: $Consumer$Type<(any)>): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaIteratorWrapper$Type = ($JavaIteratorWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaIteratorWrapper_ = $JavaIteratorWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventExceptionHandler" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$EventHandlerContainer, $EventHandlerContainer$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandlerContainer"

export interface $EventExceptionHandler {

 "handle"(arg0: $EventJS$Type, arg1: $EventHandlerContainer$Type, arg2: $Throwable$Type): $Throwable

(arg0: $EventJS$Type, arg1: $EventHandlerContainer$Type, arg2: $Throwable$Type): $Throwable
}

export namespace $EventExceptionHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExceptionHandler$Type = ($EventExceptionHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventExceptionHandler_ = $EventExceptionHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/predicate/$BlockIDPredicate" {
import {$BlockIDPredicate$PropertyObject, $BlockIDPredicate$PropertyObject$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockIDPredicate$PropertyObject"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockPredicate, $BlockPredicate$Type} from "packages/dev/latvian/mods/kubejs/block/predicate/$BlockPredicate"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BlockIDPredicate implements $BlockPredicate {

constructor(i: $ResourceLocation$Type)

public "toString"(): string
public "check"(b: $BlockContainerJS$Type): boolean
public "checkState"(state: $BlockState$Type): boolean
public "with"(key: string, value: string): $BlockIDPredicate
public "getBlockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
public "getBlockState"(): $BlockState
get "blockProperties"(): $List<($BlockIDPredicate$PropertyObject)>
get "blockState"(): $BlockState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$Type = ($BlockIDPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIDPredicate_ = $BlockIDPredicate$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$ComplexParticleType" {
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$ParticleOptions$Deserializer, $ParticleOptions$Deserializer$Type} from "packages/net/minecraft/core/particles/$ParticleOptions$Deserializer"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $ComplexParticleType extends $ParticleType<($ParticleOptions)> {

constructor(bl: boolean, deserializer: $ParticleOptions$Deserializer$Type<($ParticleOptions$Type)>)

public "codec"(): $Codec<($ParticleOptions)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComplexParticleType$Type = ($ComplexParticleType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComplexParticleType_ = $ComplexParticleType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$SequencedAssemblyRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $SequencedAssemblyRecipeSchema {

}

export namespace $SequencedAssemblyRecipeSchema {
const RESULTS: $RecipeKey<(($OutputItem)[])>
const INGREDIENT: $RecipeKey<($InputItem)>
const SEQUENCE: $RecipeKey<(($RecipeJS)[])>
const TRANSITIONAL_ITEM: $RecipeKey<($OutputItem)>
const LOOPS: $RecipeKey<(integer)>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyRecipeSchema$Type = ($SequencedAssemblyRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencedAssemblyRecipeSchema_ = $SequencedAssemblyRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$NumberLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $NumberLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(number: double)
constructor(pos: integer, value: string, number: double)
constructor(pos: integer, value: string)
constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

public "toString"(): string
public "getValue"(): string
public "setValue"(value: string): void
public "getNumber"(): double
public "setNumber"(value: double): void
get "value"(): string
set "value"(value: string)
get "number"(): double
set "number"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberLiteral$Type = ($NumberLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberLiteral_ = $NumberLiteral$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$UintMap" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UintMap {

constructor(initialCapacity: integer)
constructor()

public "remove"(key: integer): void
public "put"(key: integer, value: integer): void
public "put"(key: integer, value: any): void
public "getInt"(key: integer, defaultValue: integer): integer
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "getObject"(key: integer): any
public "getKeys"(): (integer)[]
public "has"(key: integer): boolean
public "getExistingInt"(key: integer): integer
get "empty"(): boolean
get "keys"(): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UintMap$Type = ($UintMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UintMap_ = $UintMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$KubeJSBlockEventHandler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSBlockEventHandler {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSBlockEventHandler$Type = ($KubeJSBlockEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSBlockEventHandler_ = $KubeJSBlockEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/command/$ArgumentTypeWrapper" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandRegistryEventJS, $CommandRegistryEventJS$Type} from "packages/dev/latvian/mods/kubejs/command/$CommandRegistryEventJS"
import {$ArgumentType, $ArgumentType$Type} from "packages/com/mojang/brigadier/arguments/$ArgumentType"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"

export interface $ArgumentTypeWrapper {

 "create"(arg0: $CommandRegistryEventJS$Type): $ArgumentType<(any)>
 "getResult"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>, arg1: string): any
}

export namespace $ArgumentTypeWrapper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrapper$Type = ($ArgumentTypeWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArgumentTypeWrapper_ = $ArgumentTypeWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$CustomChestMenu" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ChestMenuData, $ChestMenuData$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuData"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $CustomChestMenu extends $AbstractContainerMenu {
static readonly "TYPES": ($MenuType<(any)>)[]
 "data": $ChestMenuData
static readonly "SLOT_CLICKED_OUTSIDE": integer
static readonly "QUICKCRAFT_TYPE_CHARITABLE": integer
static readonly "QUICKCRAFT_TYPE_GREEDY": integer
static readonly "QUICKCRAFT_TYPE_CLONE": integer
static readonly "QUICKCRAFT_HEADER_START": integer
static readonly "QUICKCRAFT_HEADER_CONTINUE": integer
static readonly "QUICKCRAFT_HEADER_END": integer
static readonly "CARRIED_SLOT_SIZE": integer
readonly "lastSlots": $NonNullList<($ItemStack)>
readonly "slots": $NonNullList<($Slot)>
 "remoteSlots": $NonNullList<($ItemStack)>
 "containerId": integer

constructor(containerId: integer, data: $ChestMenuData$Type)

public "getCarried"(): $ItemStack
public "setCarried"(stack: $ItemStack$Type): void
public "stillValid"(player: $Player$Type): boolean
public "removed"(player: $Player$Type): void
public "clicked"(slot: integer, button: integer, clickType: $ClickType$Type, player: $Player$Type): void
public "quickMoveStack"(player: $Player$Type, slot: integer): $ItemStack
public "initializeContents"(stateId: integer, list: $List$Type<($ItemStack$Type)>, carried: $ItemStack$Type): void
get "carried"(): $ItemStack
set "carried"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomChestMenu$Type = ($CustomChestMenu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomChestMenu_ = $CustomChestMenu$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$LootBuilder" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConditionalFunction, $ConditionalFunction$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionalFunction"
import {$LootBuilderPool, $LootBuilderPool$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilderPool"
import {$ConditionContainer, $ConditionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionContainer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$FunctionContainer, $FunctionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$FunctionContainer"
import {$CopyNameFunction$NameSource, $CopyNameFunction$NameSource$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$CopyNameFunction$NameSource"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LootBuilder implements $FunctionContainer, $ConditionContainer {
 "type": string
 "customId": $ResourceLocation
 "pools": $JsonArray
 "functions": $JsonArray
 "conditions": $JsonArray

constructor(prev: $JsonElement$Type)

public "toJson"(): $JsonObject
public "addCondition"(o: $JsonObject$Type): $LootBuilder
public "addFunction"(o: $JsonObject$Type): $LootBuilder
public "clearPools"(): void
public "clearConditions"(): void
public "clearFunctions"(): void
public "addPool"(p: $Consumer$Type<($LootBuilderPool$Type)>): void
public "name"(name: $Component$Type): $FunctionContainer
public "name"(name: $Component$Type, entity: $LootContext$EntityTarget$Type): $FunctionContainer
public "count"(count: $NumberProvider$Type): $FunctionContainer
public "damage"(damage: $NumberProvider$Type): $FunctionContainer
public "nbt"(tag: $CompoundTag$Type): $FunctionContainer
public "addConditionalFunction"(func: $Consumer$Type<($ConditionalFunction$Type)>): $FunctionContainer
public "furnaceSmelt"(): $FunctionContainer
public "copyName"(source: $CopyNameFunction$NameSource$Type): $FunctionContainer
public "lootingEnchant"(count: $NumberProvider$Type, limit: integer): $FunctionContainer
public "enchantWithLevels"(levels: $NumberProvider$Type, treasure: boolean): $FunctionContainer
public "enchantRandomly"(enchantments: ($ResourceLocation$Type)[]): $FunctionContainer
public "lootTable"(table: $ResourceLocation$Type, seed: long): $FunctionContainer
public "survivesExplosion"(): $ConditionContainer
public "randomChance"(chance: double): $ConditionContainer
public "randomChanceWithLooting"(chance: double, multiplier: double): $ConditionContainer
public "entityScores"(entity: $LootContext$EntityTarget$Type, scores: $Map$Type<(string), (any)>): $ConditionContainer
public "entityProperties"(entity: $LootContext$EntityTarget$Type, properties: $JsonObject$Type): $ConditionContainer
public "killedByPlayer"(): $ConditionContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootBuilder$Type = ($LootBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootBuilder_ = $LootBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$LivingEntityHurtEventJS" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntityEventJS, $LivingEntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

/**
 * Invoked before an entity is hurt by a damage source.
 */
export class $LivingEntityHurtEventJS extends $LivingEntityEventJS {

constructor(entity: $LivingEntity$Type, source: $DamageSource$Type, amount: float)

/**
 * The damage source.
 */
public "getSource"(): $DamageSource
/**
 * The entity that was hurt.
 */
public "getEntity"(): $LivingEntity
/**
 * The amount of damage.
 */
public "getDamage"(): float
get "source"(): $DamageSource
get "entity"(): $LivingEntity
get "damage"(): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityHurtEventJS$Type = ($LivingEntityHurtEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityHurtEventJS_ = $LivingEntityHurtEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemModelPropertiesEventJS" {
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ClampedItemPropertyFunction, $ClampedItemPropertyFunction$Type} from "packages/net/minecraft/client/renderer/item/$ClampedItemPropertyFunction"

export class $ItemModelPropertiesEventJS extends $StartupEventJS {

constructor()

/**
 * Register a model property for an item. Model properties are used to change the appearance of an item in the world.
 * 
 * More about model properties: https://minecraft.fandom.com/wiki/Model#Item_predicates
 */
public "register"(ingredient: $Ingredient$Type, overwriteId: string, callback: $ClampedItemPropertyFunction$Type): void
/**
 * Register a model property for all items.
 */
public "registerAll"(overwriteId: string, callback: $ClampedItemPropertyFunction$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModelPropertiesEventJS$Type = ($ItemModelPropertiesEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModelPropertiesEventJS_ = $ItemModelPropertiesEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder$Helmet" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorItemBuilder$Helmet extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "armorTier": $MutableArmorTier
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Helmet$Type = ($ArmorItemBuilder$Helmet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Helmet_ = $ArmorItemBuilder$Helmet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerChatReceivedEventJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"

export class $PlayerChatReceivedEventJS extends $PlayerEventJS {
readonly "component": $Component

constructor(player: $ServerPlayer$Type, component: $Component$Type)

public "getMessage"(): string
public "getComponent"(): $MutableComponent
public "getUsername"(): string
get "message"(): string
get "component"(): $MutableComponent
get "username"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatReceivedEventJS$Type = ($PlayerChatReceivedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerChatReceivedEventJS_ = $PlayerChatReceivedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Symbol" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Symbol {

}

export namespace $Symbol {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symbol$Type = ($Symbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symbol_ = $Symbol$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/$KubeJSGUI" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$SimpleContainer, $SimpleContainer$Type} from "packages/net/minecraft/world/$SimpleContainer"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"

export class $KubeJSGUI {
static readonly "EMPTY_CONTAINER": $SimpleContainer
 "width": integer
 "height": integer
 "title": $Component
 "inventoryLabelX": integer
 "inventoryLabelY": integer
 "inventory": $InventoryKJS
 "inventoryWidth": integer
 "inventoryHeight": integer
 "playerSlotsX": integer
 "playerSlotsY": integer

constructor()
constructor(buf: $FriendlyByteBuf$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public "setInventory"(inv: $InventoryKJS$Type): void
set "inventory"(value: $InventoryKJS$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSGUI$Type = ($KubeJSGUI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSGUI_ = $KubeJSGUI$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ClientLevelKJS" {
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FireworksJS, $FireworksJS$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$ExplosionJS, $ExplosionJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$LevelKJS, $LevelKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$LevelKJS"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $ClientLevelKJS extends $LevelKJS {

 "getSide"(): $ScriptType
 "getEntities"(): $EntityArrayList
 "spawnParticles"(options: $ParticleOptions$Type, overrideLimiter: boolean, x: double, y: double, z: double, vx: double, vy: double, vz: double, count: integer, speed: double): void
 "getBlock"(x: integer, y: integer, z: integer): $BlockContainerJS
 "getBlock"(pos: $BlockPos$Type): $BlockContainerJS
 "getBlock"(blockEntity: $BlockEntity$Type): $BlockContainerJS
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "createExplosion"(x: double, y: double, z: double): $ExplosionJS
 "getEntitiesWithin"(aabb: $AABB$Type): $EntityArrayList
 "createEntityList"(entities: $Collection$Type<(any)>): $EntityArrayList
 "getPlayers"(): $EntityArrayList
 "isOverworld"(): boolean
 "getDimension"(): $ResourceLocation
 "createEntity"(type: $EntityType$Type<(any)>): $Entity
 "spawnFireworks"(x: double, y: double, z: double, f: $FireworksJS$Type): void
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getData"(): $AttachedData<($Level)>
 "getDisplayName"(): $Component

(): $ScriptType
}

export namespace $ClientLevelKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientLevelKJS$Type = ($ClientLevelKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientLevelKJS_ = $ClientLevelKJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnitTokenStream" {
import {$CharStream, $CharStream$Type} from "packages/dev/latvian/mods/unit/token/$CharStream"
import {$ArrayList, $ArrayList$Type} from "packages/java/util/$ArrayList"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitContext, $UnitContext$Type} from "packages/dev/latvian/mods/unit/$UnitContext"

export class $UnitTokenStream {
readonly "context": $UnitContext
readonly "input": string
readonly "charStream": $CharStream
readonly "infix": $ArrayList<($UnitToken)>
readonly "inputStringPos": $ArrayList<(integer)>
readonly "unit": $Unit

constructor(context: $UnitContext$Type, input: string)

public "toString"(): string
public "nextToken"(): $UnitToken
public "readFully"(): $UnitToken
public "getUnit"(): $Unit
public "peekToken"(): $UnitToken
public "ifNextToken"(token: $UnitToken$Type): boolean
public "readSingleToken"(): $UnitToken
get "unit"(): $Unit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitTokenStream$Type = ($UnitTokenStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitTokenStream_ = $UnitTokenStream$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator$Model" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"

export class $VariantBlockStateGenerator$Model {

constructor()

public "x"(_x: integer): $VariantBlockStateGenerator$Model
public "y"(_y: integer): $VariantBlockStateGenerator$Model
public "toJson"(): $JsonObject
public "uvlock"(): $VariantBlockStateGenerator$Model
public "model"(s: string): $VariantBlockStateGenerator$Model
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariantBlockStateGenerator$Model$Type = ($VariantBlockStateGenerator$Model);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariantBlockStateGenerator$Model_ = $VariantBlockStateGenerator$Model$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$LootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LootEventJS extends $EventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "removeAll"(): void
public "modify"(id: $ResourceLocation$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
public "addJson"(id: $ResourceLocation$Type, json: $JsonObject$Type): void
public "getDirectory"(): string
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootEventJS$Type = ($LootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootEventJS_ = $LootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$KubeJSItemEventHandler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSItemEventHandler {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSItemEventHandler$Type = ($KubeJSItemEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSItemEventHandler_ = $KubeJSItemEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$PlayerChatDecorateEventJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ChatEvent$ChatComponent, $ChatEvent$ChatComponent$Type} from "packages/dev/architectury/event/events/common/$ChatEvent$ChatComponent"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"

/**
 * Invoked when a player sends a chat message.
 * 
 * If cancelled (`PlayerEvents.chat`), the message will not be sent.
 */
export class $PlayerChatDecorateEventJS extends $PlayerEventJS {
 "chatComponent": $ChatEvent$ChatComponent

constructor(player: $ServerPlayer$Type, chatComponent: $ChatEvent$ChatComponent$Type)

/**
 * Gets the message that the player sent.
 */
public "getMessage"(): string
/**
 * Gets the message that the player sent.
 */
public "getComponent"(): $Component
/**
 * Sets the message that the player sent.
 */
public "setMessage"(text: $Component$Type): void
/**
 * Gets the username of the player that sent the message.
 */
public "getUsername"(): string
/**
 * Sets the message that the player sent.
 */
public "setComponent"(text: $Component$Type): void
get "message"(): string
get "component"(): $Component
set "message"(value: $Component$Type)
get "username"(): string
set "component"(value: $Component$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerChatDecorateEventJS$Type = ($PlayerChatDecorateEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerChatDecorateEventJS_ = $PlayerChatDecorateEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$ReloadStartupScriptsMessage" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $ReloadStartupScriptsMessage extends $BaseS2CMessage {
readonly "dedicated": boolean

constructor(dedicated: boolean)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReloadStartupScriptsMessage$Type = ($ReloadStartupScriptsMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReloadStartupScriptsMessage_ = $ReloadStartupScriptsMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$MobEffectBuilder$EffectTickCallback" {
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $MobEffectBuilder$EffectTickCallback {

 "applyEffectTick"(arg0: $LivingEntity$Type, arg1: integer): void

(arg0: $LivingEntity$Type, arg1: integer): void
}

export namespace $MobEffectBuilder$EffectTickCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MobEffectBuilder$EffectTickCallback$Type = ($MobEffectBuilder$EffectTickCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MobEffectBuilder$EffectTickCallback_ = $MobEffectBuilder$EffectTickCallback$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ResolvedOverload" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ResolvedOverload {


public "equals"(other: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ResolvedOverload$Type = ($ResolvedOverload);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ResolvedOverload_ = $ResolvedOverload$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/$AddWorldgenEventJS" {
import {$ClassWrapper, $ClassWrapper$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassWrapper"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AddSpawnProperties, $AddSpawnProperties$Type} from "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddSpawnProperties"
import {$AddOreProperties, $AddOreProperties$Type} from "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddOreProperties"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$VerticalAnchor, $VerticalAnchor$Type} from "packages/net/minecraft/world/level/levelgen/$VerticalAnchor"
import {$AddLakeProperties, $AddLakeProperties$Type} from "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddLakeProperties"

export class $AddWorldgenEventJS extends $StartupEventJS {
readonly "anchors": $ClassWrapper<($VerticalAnchor)>

constructor()

public "addSpawn"(filter: $BiomeFilter$Type, category: $MobCategory$Type, spawn: string): void
public "addSpawn"(category: $MobCategory$Type, spawn: string): void
public "addSpawn"(p: $Consumer$Type<($AddSpawnProperties$Type)>): void
public "addOre"(p: $Consumer$Type<($AddOreProperties$Type)>): void
public "addLake"(p: $Consumer$Type<($AddLakeProperties$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddWorldgenEventJS$Type = ($AddWorldgenEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddWorldgenEventJS_ = $AddWorldgenEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$PaintingVariantBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$PaintingVariant, $PaintingVariant$Type} from "packages/net/minecraft/world/entity/decoration/$PaintingVariant"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $PaintingVariantBuilder extends $BuilderBase<($PaintingVariant)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "width"(width: integer): $PaintingVariantBuilder
public "height"(height: integer): $PaintingVariantBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintingVariantBuilder$Type = ($PaintingVariantBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintingVariantBuilder_ = $PaintingVariantBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$ItemObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $ItemObject extends $BoxObject {
 "itemStack": $ItemStack
 "overlay": $Unit
 "customText": string
 "rotation": $Unit
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public static "drawItem"(poseStack: $PoseStack$Type, stack: $ItemStack$Type, hash: integer, renderOverlay: boolean, text: string): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemObject$Type = ($ItemObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemObject_ = $ItemObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Enchantment$Rarity, $Enchantment$Rarity$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment$Rarity"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$EnchantmentBuilder$DamageBonusFunction, $EnchantmentBuilder$DamageBonusFunction$Type} from "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$DamageBonusFunction"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$EnchantmentBuilder$DamageProtectionFunction, $EnchantmentBuilder$DamageProtectionFunction$Type} from "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$DamageProtectionFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$EnchantmentBuilder$PostFunction, $EnchantmentBuilder$PostFunction$Type} from "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder$PostFunction"

export class $EnchantmentBuilder extends $BuilderBase<($Enchantment)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "slots"(s: ($EquipmentSlot$Type)[]): $EnchantmentBuilder
public "category"(c: $EnchantmentCategory$Type): $EnchantmentBuilder
public "checkCompatibility"(i: $Object2BooleanFunction$Type<($ResourceLocation$Type)>): $EnchantmentBuilder
public "maxCost"(i: $Int2IntFunction$Type): $EnchantmentBuilder
public "canEnchant"(i: $Object2BooleanFunction$Type<($ItemStack$Type)>): $EnchantmentBuilder
public "treasureOnly"(): $EnchantmentBuilder
public "minCost"(i: $Int2IntFunction$Type): $EnchantmentBuilder
public "damageProtection"(i: $EnchantmentBuilder$DamageProtectionFunction$Type): $EnchantmentBuilder
public "undiscoverable"(): $EnchantmentBuilder
public "veryRare"(): $EnchantmentBuilder
public "untradeable"(): $EnchantmentBuilder
public "uncommon"(): $EnchantmentBuilder
public "curse"(): $EnchantmentBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
public "weapon"(): $EnchantmentBuilder
public "armor"(): $EnchantmentBuilder
public "vanishable"(): $EnchantmentBuilder
public "armorChest"(): $EnchantmentBuilder
public "fishingRod"(): $EnchantmentBuilder
public "armorFeet"(): $EnchantmentBuilder
public "armorLegs"(): $EnchantmentBuilder
public "wearable"(): $EnchantmentBuilder
public "armorHead"(): $EnchantmentBuilder
public "rarity"(r: $Enchantment$Rarity$Type): $EnchantmentBuilder
public "damageBonus"(i: $EnchantmentBuilder$DamageBonusFunction$Type): $EnchantmentBuilder
public "maxLevel"(i: integer): $EnchantmentBuilder
public "minLevel"(i: integer): $EnchantmentBuilder
public "rare"(): $EnchantmentBuilder
public "bow"(): $EnchantmentBuilder
public "crossbow"(): $EnchantmentBuilder
public "postHurt"(i: $EnchantmentBuilder$PostFunction$Type): $EnchantmentBuilder
public "postAttack"(i: $EnchantmentBuilder$PostFunction$Type): $EnchantmentBuilder
public "breakable"(): $EnchantmentBuilder
public "trident"(): $EnchantmentBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnchantmentBuilder$Type = ($EnchantmentBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnchantmentBuilder_ = $EnchantmentBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$MinecraftServerKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$MinecraftServer$ReloadableResources, $MinecraftServer$ReloadableResources$Type} from "packages/net/minecraft/server/$MinecraftServer$ReloadableResources"
import {$WithAttachedData, $WithAttachedData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithAttachedData"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PlayerSelector, $PlayerSelector$Type} from "packages/dev/latvian/mods/kubejs/core/$PlayerSelector"
import {$DataSenderKJS, $DataSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$DataSenderKJS"
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$AdvancementJS, $AdvancementJS$Type} from "packages/dev/latvian/mods/kubejs/player/$AdvancementJS"
import {$MinecraftEnvironmentKJS, $MinecraftEnvironmentKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MinecraftEnvironmentKJS"
import {$WithPersistentData, $WithPersistentData$Type} from "packages/dev/latvian/mods/kubejs/core/$WithPersistentData"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$Callback"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $MinecraftServerKJS extends $WithAttachedData<($MinecraftServer)>, $WithPersistentData, $DataSenderKJS, $MinecraftEnvironmentKJS {

 "self"(): $MinecraftServer
 "getLevel"(dimension: $ResourceLocation$Type): $ServerLevel
 "sendData"(channel: string, data: $CompoundTag$Type): void
 "getOverworld"(): $ServerLevel
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "getAdvancement"(id: $ResourceLocation$Type): $AdvancementJS
 "getReloadableResources"(): $MinecraftServer$ReloadableResources
 "getPlayers"(): $EntityArrayList
 "getEntities"(): $EntityArrayList
 "restoreInventories"(): $Map<($UUID), ($Map<(integer), ($ItemStack)>)>
 "getPlayer"(selector: $PlayerSelector$Type): $ServerPlayer
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getData"(): $AttachedData<($MinecraftServer)>
 "getPersistentData"(): $CompoundTag
 "sendData"(channel: string): void
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeatingInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component
}

export namespace $MinecraftServerKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftServerKJS$Type = ($MinecraftServerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftServerKJS_ = $MinecraftServerKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$InterpreterData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $InterpreterData {


public "getParent"(): $InterpreterData
public "getFunction"(index: integer): $InterpreterData
public "getFunctionCount"(): integer
public "getParamAndVarCount"(): integer
public "icodeHashCode"(): integer
public "getFunctionName"(): string
public "getParamOrVarConst"(index: integer): boolean
get "parent"(): $InterpreterData
get "functionCount"(): integer
get "paramAndVarCount"(): integer
get "functionName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterpreterData$Type = ($InterpreterData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterpreterData_ = $InterpreterData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ItemKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientSupplierKJS, $IngredientSupplierKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$IngredientSupplierKJS"
import {$MutableToolTier, $MutableToolTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableToolTier"
import {$FoodBuilder, $FoodBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$FoodBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Rarity, $Rarity$Type} from "packages/net/minecraft/world/item/$Rarity"
import {$FoodProperties, $FoodProperties$Type} from "packages/net/minecraft/world/food/$FoodProperties"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$ItemStackKey, $ItemStackKey$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemStackKey"

export interface $ItemKJS extends $IngredientSupplierKJS {

 "self"(): $Item
 "getItemBuilder"(): $ItemBuilder
 "setNameKey"(key: string): void
 "setMaxStackSize"(i: integer): void
 "getTypeItemStackKey"(): $ItemStackKey
 "setFoodProperties"(properties: $FoodProperties$Type): void
 "setFoodProperties"(consumer: $Consumer$Type<($FoodBuilder$Type)>): void
 "setCraftingRemainder"(i: $Item$Type): void
 "setFireResistant"(b: boolean): void
 "setArmorToughness"(armorToughness: double): void
 "setArmorProtection"(armorProtection: double): void
 "setAttackDamage"(attackDamage: double): void
 "setArmorKnockbackResistance"(knockbackResistance: double): void
 "removeAttribute"(attribute: $Attribute$Type, uuid: $UUID$Type): void
 "setItemBuilder"(b: $ItemBuilder$Type): void
 "setBurnTime"(i: integer): void
 "setRarity"(r: $Rarity$Type): void
 "setMaxDamage"(i: integer): void
 "getCreativeTab"(): string
 "setDigSpeed"(speed: float): void
 "addAttribute"(attribute: $Attribute$Type, uuid: $UUID$Type, name: string, d: double, operation: $AttributeModifier$Operation$Type): void
 "setTier"(c: $Consumer$Type<($MutableToolTier$Type)>): void
 "getDigSpeed"(): float
 "setAttackSpeed"(attackSpeed: double): void
 "getAttributes"(attribute: $Attribute$Type): $List<($AttributeModifier)>
 "getIdLocation"(): $ResourceLocation
 "getId"(): string
 "getTypeData"(): $CompoundTag
 "getMod"(): string
 "kjs$asIngredient"(): $Ingredient
}

export namespace $ItemKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemKJS$Type = ($ItemKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemKJS_ = $ItemKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenPainterObject" {
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$PainterObject, $PainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObject"

export class $ScreenPainterObject extends $PainterObject {
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor()

public "draw"(arg0: $PaintScreenEventJS$Type): void
public "preDraw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenPainterObject$Type = ($ScreenPainterObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenPainterObject_ = $ScreenPainterObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ScreenPainterObject, $ScreenPainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenPainterObject"

export class $BoxObject extends $ScreenPainterObject {
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoxObject$Type = ($BoxObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoxObject_ = $BoxObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$FirstClickMessage" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $FirstClickMessage extends $BaseC2SMessage {

constructor(t: integer)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FirstClickMessage$Type = ($FirstClickMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FirstClickMessage_ = $FirstClickMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$UnboundFluidStackJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export class $UnboundFluidStackJS extends $FluidStackJS {

constructor(f: $ResourceLocation$Type)

public "getId"(): string
public "setAmount"(a: long): void
public "copy"(amount: long): $FluidStackJS
public "getAmount"(): long
public "setNbt"(n: $CompoundTag$Type): void
public "getNbt"(): $CompoundTag
public "getFluidStack"(): $FluidStack
public "isEmpty"(): boolean
get "id"(): string
set "amount"(value: long)
get "amount"(): long
set "nbt"(value: $CompoundTag$Type)
get "nbt"(): $CompoundTag
get "fluidStack"(): $FluidStack
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnboundFluidStackJS$Type = ($UnboundFluidStackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnboundFluidStackJS_ = $UnboundFluidStackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS" {
import {$HitResult, $HitResult$Type} from "packages/net/minecraft/world/phys/$HitResult"
import {$HitResult$Type, $HitResult$Type$Type} from "packages/net/minecraft/world/phys/$HitResult$Type"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $RayTraceResultJS {
readonly "fromEntity": $Entity
readonly "type": $HitResult$Type
readonly "distance": double
 "hit": $Vec3
 "block": $BlockContainerJS
 "facing": $Direction
 "entity": $Entity

constructor(from: $Entity$Type, result: $HitResult$Type, d: double)

public "getHitZ"(): double
public "getHitY"(): double
public "getHitX"(): double
get "hitZ"(): double
get "hitY"(): double
get "hitX"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RayTraceResultJS$Type = ($RayTraceResultJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RayTraceResultJS_ = $RayTraceResultJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$EmptyTagTargetException" {
import {$NoSuchElementException, $NoSuchElementException$Type} from "packages/java/util/$NoSuchElementException"

export class $EmptyTagTargetException extends $NoSuchElementException {

constructor(message: string)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyTagTargetException$Type = ($EmptyTagTargetException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyTagTargetException_ = $EmptyTagTargetException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$ServerEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $ServerEvents {

}

export namespace $ServerEvents {
const GROUP: $EventGroup
const LOW_DATA: $EventHandler
const HIGH_DATA: $EventHandler
const LOADED: $EventHandler
const UNLOADED: $EventHandler
const TICK: $EventHandler
const TAGS: $EventHandler
const COMMAND_REGISTRY: $EventHandler
const COMMAND: $EventHandler
const CUSTOM_COMMAND: $EventHandler
const RECIPES: $EventHandler
const RECIPES_AFTER_LOADED: $EventHandler
const SPECIAL_RECIPES: $EventHandler
const COMPOSTABLE_RECIPES: $EventHandler
const GENERIC_LOOT_TABLES: $EventHandler
const BLOCK_LOOT_TABLES: $EventHandler
const ENTITY_LOOT_TABLES: $EventHandler
const GIFT_LOOT_TABLES: $EventHandler
const FISHING_LOOT_TABLES: $EventHandler
const CHEST_LOOT_TABLES: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerEvents$Type = ($ServerEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerEvents_ = $ServerEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$RemoveStageMessage" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $RemoveStageMessage extends $BaseS2CMessage {

constructor(p: $UUID$Type, s: string)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveStageMessage$Type = ($RemoveStageMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveStageMessage_ = $RemoveStageMessage$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdEnumerationIterator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $IdEnumerationIterator {

 "enumerationIteratorHasNext"(arg0: $Context$Type, arg1: $Consumer$Type<(any)>): boolean
 "enumerationIteratorNext"(arg0: $Context$Type, arg1: $Consumer$Type<(any)>): boolean
}

export namespace $IdEnumerationIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdEnumerationIterator$Type = ($IdEnumerationIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdEnumerationIterator_ = $IdEnumerationIterator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilderMap" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$AbstractMap, $AbstractMap$Type} from "packages/java/util/$AbstractMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeComponentBuilderMap extends $AbstractMap<($RecipeKey<(any)>), (any)> {
static readonly "EMPTY": $RecipeComponentBuilderMap
readonly "holders": ($RecipeComponentValue<(any)>)[]
 "hasChanged": boolean

constructor(keys: ($RecipeKey$Type<(any)>)[])
constructor(holders: ($RecipeComponentValue$Type<(any)>)[])
constructor(builder: $RecipeComponentBuilder$Type)

public "get"(key: any): any
public "put"(key: $RecipeKey$Type<(any)>, value: any): any
public "equals"(o: any): boolean
public "hashCode"(): integer
public "entrySet"(): $Set<($Map$Entry<($RecipeKey<(any)>), (any)>)>
public "getOrDefault"(key: any, defaultValue: any): any
public "getHolder"(key: any): $RecipeComponentValue<(any)>
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentBuilderMap$Type = ($RecipeComponentBuilderMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentBuilderMap_ = $RecipeComponentBuilderMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FireworksJS, $FireworksJS$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS"
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$SpecialEquality, $SpecialEquality$Type} from "packages/dev/latvian/mods/rhino/util/$SpecialEquality"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ExplosionJS, $ExplosionJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"

export class $BlockContainerJS implements $SpecialEquality {
readonly "minecraftLevel": $Level

constructor(w: $Level$Type, p: $BlockPos$Type)
constructor(blockEntity: $BlockEntity$Type)

public "equals"(obj: any): boolean
public "toString"(): string
public "offset"(f: $Direction$Type): $BlockContainerJS
public "offset"(x: integer, y: integer, z: integer): $BlockContainerJS
public "offset"(f: $Direction$Type, d: integer): $BlockContainerJS
public "set"(id: $ResourceLocation$Type, properties: $Map$Type<(any), (any)>): void
public "set"(id: $ResourceLocation$Type, properties: $Map$Type<(any), (any)>, flags: integer): void
public "set"(id: $ResourceLocation$Type): void
public "getProperties"(): $Map<(string), (string)>
public "getId"(): string
public "clearCache"(): void
public "getLevel"(): $Level
public "getItem"(): $ItemStack
public "getInventory"(facing: $Direction$Type): $InventoryKJS
public "getInventory"(): $InventoryKJS
public "getY"(): integer
public "getLight"(): integer
public "getDimension"(): $ResourceLocation
public "getZ"(): integer
public "getX"(): integer
public "canSeeSkyFromBelowWater"(): boolean
public "getDrops"(): $List<($ItemStack)>
public "getDrops"(entity: $Entity$Type, heldItem: $ItemStack$Type): $List<($ItemStack)>
public "getEntity"(): $BlockEntity
public "createEntity"(type: $EntityType$Type<(any)>): $Entity
public "hasTag"(tag: $ResourceLocation$Type): boolean
public "getBlockState"(): $BlockState
public "getDown"(): $BlockContainerJS
public "getNorth"(): $BlockContainerJS
public "getUp"(): $BlockContainerJS
public "getEast"(): $BlockContainerJS
public "getSkyLight"(): integer
public "getSouth"(): $BlockContainerJS
public "popItem"(item: $ItemStack$Type): void
public "spawnLightning"(): void
public "spawnLightning"(effectOnly: boolean): void
public "spawnLightning"(effectOnly: boolean, player: $ServerPlayer$Type): void
public "getPlayersInRadius"(radius: double): $EntityArrayList
public "getPlayersInRadius"(): $EntityArrayList
public "getWest"(): $BlockContainerJS
public "getTypeData"(): $CompoundTag
public "setEntityData"(tag: $CompoundTag$Type): void
public "popItemFromFace"(item: $ItemStack$Type, dir: $Direction$Type): void
public "getBiomeId"(): $ResourceLocation
public "mergeEntityData"(tag: $CompoundTag$Type): void
public "setBlockState"(state: $BlockState$Type, flags: integer): void
public "spawnFireworks"(fireworks: $FireworksJS$Type): void
public "createExplosion"(): $ExplosionJS
public "getCanSeeSky"(): boolean
public "getBlockLight"(): integer
public "getPos"(): $BlockPos
public "getEntityId"(): string
public "specialEquals"(o: any, shallow: boolean): boolean
public "getEntityData"(): $CompoundTag
public "getTags"(): $Collection<($ResourceLocation)>
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
get "properties"(): $Map<(string), (string)>
get "id"(): string
get "level"(): $Level
get "item"(): $ItemStack
get "inventory"(): $InventoryKJS
get "y"(): integer
get "light"(): integer
get "dimension"(): $ResourceLocation
get "z"(): integer
get "x"(): integer
get "drops"(): $List<($ItemStack)>
get "entity"(): $BlockEntity
get "blockState"(): $BlockState
get "down"(): $BlockContainerJS
get "north"(): $BlockContainerJS
get "up"(): $BlockContainerJS
get "east"(): $BlockContainerJS
get "skyLight"(): integer
get "south"(): $BlockContainerJS
get "playersInRadius"(): $EntityArrayList
get "west"(): $BlockContainerJS
get "typeData"(): $CompoundTag
set "entityData"(value: $CompoundTag$Type)
get "biomeId"(): $ResourceLocation
get "canSeeSky"(): boolean
get "blockLight"(): integer
get "pos"(): $BlockPos
get "entityId"(): string
get "entityData"(): $CompoundTag
get "tags"(): $Collection<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockContainerJS$Type = ($BlockContainerJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockContainerJS_ = $BlockContainerJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$GeneratedClientResourcePack" {
import {$GeneratedResourcePack, $GeneratedResourcePack$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedResourcePack"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PackResources, $PackResources$Type} from "packages/net/minecraft/server/packs/$PackResources"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GeneratedClientResourcePack extends $GeneratedResourcePack {
readonly "client": $Minecraft

constructor(client: $Minecraft$Type)

public "generate"(map: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>): void
public static "inject"(client: $Minecraft$Type, packs: $List$Type<($PackResources$Type)>): $List<($PackResources)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedClientResourcePack$Type = ($GeneratedClientResourcePack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedClientResourcePack_ = $GeneratedClientResourcePack$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$BlockStateKJS" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BlockStateKJS {

 "setRequiresTool"(v: boolean): void
 "setDestroySpeed"(v: float): void
 "setLightEmission"(v: integer): void
}

export namespace $BlockStateKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateKJS$Type = ($BlockStateKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateKJS_ = $BlockStateKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$JavaMembers" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$FieldAndMethods, $FieldAndMethods$Type} from "packages/dev/latvian/mods/rhino/$FieldAndMethods"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JavaMembers$MethodInfo, $JavaMembers$MethodInfo$Type} from "packages/dev/latvian/mods/rhino/$JavaMembers$MethodInfo"
import {$Constructor, $Constructor$Type} from "packages/java/lang/reflect/$Constructor"
import {$JavaMembers$FieldInfo, $JavaMembers$FieldInfo$Type} from "packages/dev/latvian/mods/rhino/$JavaMembers$FieldInfo"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $JavaMembers {
readonly "localContext": $Context


public "get"(scope: $Scriptable$Type, name: string, javaObject: any, isStatic: boolean, cx: $Context$Type): any
public "put"(scope: $Scriptable$Type, name: string, javaObject: any, value: any, isStatic: boolean, cx: $Context$Type): void
public static "lookupClass"(cx: $Context$Type, scope: $Scriptable$Type, dynamicType: $Class$Type<(any)>, staticType: $Class$Type<(any)>, includeProtected: boolean): $JavaMembers
public "has"(name: string, isStatic: boolean): boolean
public static "javaSignature"(type: $Class$Type<(any)>): string
public "getAccessibleConstructors"(): $List<($Constructor<(any)>)>
public "getAccessibleFields"(cx: $Context$Type, includeProtected: boolean): $Collection<($JavaMembers$FieldInfo)>
public "getFieldAndMethodsObjects"(scope: $Scriptable$Type, javaObject: any, isStatic: boolean, cx: $Context$Type): $Map<(string), ($FieldAndMethods)>
public "getAccessibleMethods"(cx: $Context$Type, includeProtected: boolean): $Collection<($JavaMembers$MethodInfo)>
public static "liveConnectSignature"(argTypes: ($Class$Type<(any)>)[]): string
public "getIds"(isStatic: boolean): (any)[]
get "accessibleConstructors"(): $List<($Constructor<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaMembers$Type = ($JavaMembers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaMembers_ = $JavaMembers$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$StringUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $StringUnitToken extends $Record implements $UnitToken {

constructor(name: string)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringUnitToken$Type = ($StringUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringUnitToken_ = $StringUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$KubeJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$KubeJSCommon, $KubeJSCommon$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSCommon"
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"
import {$ScriptPack, $ScriptPack$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPack"
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Mod, $Mod$Type} from "packages/dev/architectury/platform/$Mod"

export class $KubeJS {
static readonly "MOD_ID": string
static readonly "MOD_NAME": string
static readonly "LOGGER": $Logger
static readonly "MC_VERSION_NUMBER": integer
static readonly "MC_VERSION_STRING": string
static "QUERY": string
static readonly "NAME_COMPONENT": $Component
static "instance": $KubeJS
static "PROXY": $KubeJSCommon
static "thisMod": $Mod

constructor()

public static "id"(path: string): $ResourceLocation
public "setup"(): void
public static "appendModId"(id: string): string
public static "verifyFilePath"(path: $Path$Type): $Path
public "loadComplete"(): void
public static "loadScripts"(pack: $ScriptPack$Type, dir: $Path$Type, path: string): void
public static "getGameDirectory"(): $Path
public static "getClientScriptManager"(): $ScriptManager
public static "getStartupScriptManager"(): $ScriptManager
get "gameDirectory"(): $Path
get "clientScriptManager"(): $ScriptManager
get "startupScriptManager"(): $ScriptManager
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJS$Type = ($KubeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJS_ = $KubeJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeSchemaRegistryEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RecipeComponentFactory, $RecipeComponentFactory$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeSchemaRegistryEventJS extends $EventJS {

constructor(namespaces: $Map$Type<(string), ($RecipeNamespace$Type)>, mappedRecipes: $Map$Type<(string), ($ResourceLocation$Type)>)

public "register"(id: $ResourceLocation$Type, schema: $RecipeSchema$Type): void
public "namespace"(namespace: string): $RecipeNamespace
public "getComponents"(): $Map<(string), ($RecipeComponentFactory)>
public "mapRecipe"(name: string, type: string): void
public "mapRecipe"(name: string, type: $ResourceLocation$Type): void
get "components"(): $Map<(string), ($RecipeComponentFactory)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaRegistryEventJS$Type = ($RecipeSchemaRegistryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaRegistryEventJS_ = $RecipeSchemaRegistryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeObject" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$DataObject, $DataObject$Type} from "packages/dev/latvian/mods/rhino/util/$DataObject"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NativeObject extends $IdScriptableObject implements $Map<(any), (any)>, $DataObject {
readonly "localContext": $Context
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type)

public "remove"(key: any): any
public "get"(key: any): any
public "put"(key: any, value: any): any
public "toString"(): string
public "values"(): $Collection<(any)>
public "clear"(): void
public "entrySet"(): $Set<($Map$Entry<(any), (any)>)>
public "putAll"(m: $Map$Type<(any), (any)>): void
public "containsKey"(key: any): boolean
public "keySet"(): $Set<(any)>
public "containsValue"(value: any): boolean
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "createDataObject"<T>(instanceFactory: $Supplier$Type<(T)>, cx: $Context$Type): T
public "isDataObjectList"(): boolean
public "createDataObjectList"<T>(instanceFactory: $Supplier$Type<(T)>, cx: $Context$Type): $List<(T)>
public "remove"(arg0: any, arg1: any): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(any), (any)>
public "isEmpty"(): boolean
public "replace"(arg0: any, arg1: any): any
public "replace"(arg0: any, arg1: any, arg2: any): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public "size"(): integer
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): $Map<(any), (any)>
public static "of"<K, V>(): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any, arg16: any, arg17: any, arg18: any, arg19: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any, arg16: any, arg17: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any, arg14: any, arg15: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any, arg12: any, arg13: any): $Map<(any), (any)>
public static "of"<K, V>(arg0: any, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any, arg6: any, arg7: any, arg8: any, arg9: any, arg10: any, arg11: any): $Map<(any), (any)>
public "merge"(arg0: any, arg1: any, arg2: $BiFunction$Type<(any), (any), (any)>): any
public "putIfAbsent"(arg0: any, arg1: any): any
public "compute"(arg0: any, arg1: $BiFunction$Type<(any), (any), (any)>): any
public static "entry"<K, V>(arg0: any, arg1: any): $Map$Entry<(any), (any)>
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: any, arg1: $Function$Type<(any), (any)>): any
public "getOrDefault"(arg0: any, arg1: any): any
public "computeIfPresent"(arg0: any, arg1: $BiFunction$Type<(any), (any), (any)>): any
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(any), (any)>
[index: string | number]: any
get "className"(): string
get "dataObjectList"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeObject$Type = ($NativeObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeObject_ = $NativeObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockBrokenEventJS" {
import {$IntValue, $IntValue$Type} from "packages/dev/architectury/utils/value/$IntValue"
import {$ServerPlayer, $ServerPlayer$Type} from "packages/net/minecraft/server/level/$ServerPlayer"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

/**
 * Invoked when a block is destroyed by a player.
 */
export class $BlockBrokenEventJS extends $PlayerEventJS {

constructor(entity: $ServerPlayer$Type, level: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, xp: $IntValue$Type)

/**
 * The block that was broken.
 */
public "getBlock"(): $BlockContainerJS
/**
 * Sets the experience dropped by the block. Only works on Forge.
 */
public "setXp"(xp: integer): void
/**
 * The experience dropped by the block. Always `0` on Fabric.
 */
public "getXp"(): integer
get "block"(): $BlockContainerJS
set "xp"(value: integer)
get "xp"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBrokenEventJS$Type = ($BlockBrokenEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBrokenEventJS_ = $BlockBrokenEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ExpressionStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ExpressionStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, expr: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(expr: $AstNode$Type)
constructor(expr: $AstNode$Type, hasResult: boolean)
constructor()

public "getExpression"(): $AstNode
public "hasSideEffects"(): boolean
public "setHasResult"(): void
public "setExpression"(expression: $AstNode$Type): void
get "expression"(): $AstNode
set "expression"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExpressionStatement$Type = ($ExpressionStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExpressionStatement_ = $ExpressionStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabCallback" {
import {$CreativeModeTab$TabVisibility, $CreativeModeTab$TabVisibility$Type} from "packages/net/minecraft/world/item/$CreativeModeTab$TabVisibility"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $CreativeTabCallback {

 "remove"(arg0: $Ingredient$Type, arg1: boolean, arg2: boolean): void
 "addBefore"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $CreativeModeTab$TabVisibility$Type): void
 "addAfter"(arg0: $ItemStack$Type, arg1: ($ItemStack$Type)[], arg2: $CreativeModeTab$TabVisibility$Type): void
}

export namespace $CreativeTabCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabCallback$Type = ($CreativeTabCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabCallback_ = $CreativeTabCallback$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeCallSite" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeCallSite extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "toString"(): string
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeCallSite$Type = ($NativeCallSite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeCallSite_ = $NativeCallSite$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$BasicItemJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BasicItemJS extends $Item {
static readonly "BY_BLOCK": $Map<($Block), ($Item)>
static readonly "BASE_ATTACK_DAMAGE_UUID": $UUID
static readonly "MAX_STACK_SIZE": integer
static readonly "EAT_DURATION": integer
static readonly "MAX_BAR_WIDTH": integer
 "craftingRemainingItem": $Item
 "descriptionId": string
 "renderProperties": any

constructor(p: $ItemBuilder$Type)

public "getItemBuilder"(): $ItemBuilder
public "getName"(itemStack: $ItemStack$Type): $Component
public "getDefaultAttributeModifiers"(slot: $EquipmentSlot$Type): $Multimap<($Attribute), ($AttributeModifier)>
get "itemBuilder"(): $ItemBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicItemJS$Type = ($BasicItemJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicItemJS_ = $BasicItemJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Scope" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$AstSymbol, $AstSymbol$Type} from "packages/dev/latvian/mods/rhino/ast/$AstSymbol"
import {$Jump, $Jump$Type} from "packages/dev/latvian/mods/rhino/ast/$Jump"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Scope extends $Jump {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer, len: integer)
constructor(pos: integer)

public "replaceWith"(newScope: $Scope$Type): void
public "getSymbol"(name: string): $AstSymbol
public "setSymbolTable"(table: $Map$Type<(string), ($AstSymbol$Type)>): void
public "addChildScope"(child: $Scope$Type): void
public "getTop"(): $ScriptNode
public "setTop"(top: $ScriptNode$Type): void
public "setParentScope"(parentScope: $Scope$Type): void
public "getSymbolTable"(): $Map<(string), ($AstSymbol)>
public "getDefiningScope"(name: string): $Scope
public static "splitScope"(scope: $Scope$Type): $Scope
public static "joinScopes"(source: $Scope$Type, dest: $Scope$Type): void
public "getChildScopes"(): $List<($Scope)>
public "clearParentScope"(): void
public "getStatements"(): $List<($AstNode)>
public "getParentScope"(): $Scope
public "putSymbol"(symbol: $AstSymbol$Type): void
set "symbolTable"(value: $Map$Type<(string), ($AstSymbol$Type)>)
get "top"(): $ScriptNode
set "top"(value: $ScriptNode$Type)
set "parentScope"(value: $Scope$Type)
get "symbolTable"(): $Map<(string), ($AstSymbol)>
get "childScopes"(): $List<($Scope)>
get "statements"(): $List<($AstNode)>
get "parentScope"(): $Scope
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Scope$Type = ($Scope);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Scope_ = $Scope$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$SpecialRecipeSchema" {
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"

export interface $SpecialRecipeSchema {

}

export namespace $SpecialRecipeSchema {
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRecipeSchema$Type = ($SpecialRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialRecipeSchema_ = $SpecialRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$CropBlockBuilder$ShapeBuilder, $CropBlockBuilder$ShapeBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder$ShapeBuilder"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$CropBlockBuilder$SurviveCallback, $CropBlockBuilder$SurviveCallback$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder$SurviveCallback"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export class $CropBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
/**
 * Set if the crop should drop seeds when harvested.
 */
public "dropSeed"(dropSeed: boolean): $CropBlockBuilder
public "survive"(surviveCallback: $CropBlockBuilder$SurviveCallback$Type): $CropBlockBuilder
public "growTick"(growSpeedCallback: $ToDoubleFunction$Type<($RandomTickCallbackJS$Type)>): $CropBlockBuilder
/**
 * Add a crop output with a specific chance.
 */
public "crop"(output: any, chance: double): $CropBlockBuilder
/**
 * Add a crop output with a 100% chance.
 */
public "crop"(output: any): $CropBlockBuilder
/**
 * Set the age of the crop and the shape of the crop at that age.
 */
public "age"(age: integer, builder: $Consumer$Type<($CropBlockBuilder$ShapeBuilder$Type)>): $CropBlockBuilder
/**
 * Set the age of the crop. Note that the box will be the same for all ages (A full block size).
 */
public "age"(age: integer): $CropBlockBuilder
public "texture"(id: string, tex: string): $BlockBuilder
public "bonemeal"(bonemealCallback: $ToIntFunction$Type<($RandomTickCallbackJS$Type)>): $CropBlockBuilder
public "randomTick"(randomTickCallback: $Consumer$Type<($RandomTickCallbackJS$Type)>): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CropBlockBuilder$Type = ($CropBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CropBlockBuilder_ = $CropBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction$Fixed" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BlockTintFunction, $BlockTintFunction$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export class $BlockTintFunction$Fixed extends $Record implements $BlockTintFunction {

constructor(color: $Color$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "color"(): $Color
public "getColor"(state: $BlockState$Type, level: $BlockAndTintGetter$Type, pos: $BlockPos$Type, index: integer): $Color
public static "of"(cx: $Context$Type, o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Fixed$Type = ($BlockTintFunction$Fixed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTintFunction$Fixed_ = $BlockTintFunction$Fixed$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$REProgState" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $REProgState {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $REProgState$Type = ($REProgState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $REProgState_ = $REProgState$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$SpecialSpoutHandlerEvent$SpoutHandler" {
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export interface $SpecialSpoutHandlerEvent$SpoutHandler {

 "fillBlock"(arg0: $BlockContainerJS$Type, arg1: $FluidStackJS$Type, arg2: boolean): long

(arg0: $BlockContainerJS$Type, arg1: $FluidStackJS$Type, arg2: boolean): long
}

export namespace $SpecialSpoutHandlerEvent$SpoutHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialSpoutHandlerEvent$SpoutHandler$Type = ($SpecialSpoutHandlerEvent$SpoutHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialSpoutHandlerEvent$SpoutHandler_ = $SpecialSpoutHandlerEvent$SpoutHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockLeftClickedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

/**
 * Invoked when a player left clicks on a block.
 */
export class $BlockLeftClickedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, hand: $InteractionHand$Type, pos: $BlockPos$Type, direction: $Direction$Type)

/**
 * The item that was used to left click the block.
 */
public "getItem"(): $ItemStack
/**
 * The block that was left clicked.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The face of the block that was left clicked.
 */
public "getFacing"(): $Direction
/**
 * The player that left clicked the block.
 */
public "getEntity"(): $Player
get "item"(): $ItemStack
get "block"(): $BlockContainerJS
get "facing"(): $Direction
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockLeftClickedEventJS$Type = ($BlockLeftClickedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockLeftClickedEventJS_ = $BlockLeftClickedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$DetectorBlockEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LevelEventJS, $LevelEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$LevelEventJS"

/**
 * Invoked when a detector block registered in KubeJS receives a block update.
 * 
 * `Powered`/`Unpowered` event will be fired when the detector block is powered/unpowered.
 */
export class $DetectorBlockEventJS extends $LevelEventJS {

constructor(i: string, l: $Level$Type, p: $BlockPos$Type, pow: boolean)

/**
 * The level where the detector block is located.
 */
public "getLevel"(): $Level
/**
 * The detector block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * If the detector block is powered.
 */
public "isPowered"(): boolean
/**
 * The id of the detector block when it was registered.
 */
public "getDetectorId"(): string
get "level"(): $Level
get "block"(): $BlockContainerJS
get "powered"(): boolean
get "detectorId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlockEventJS$Type = ($DetectorBlockEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DetectorBlockEventJS_ = $DetectorBlockEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$TemplateLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$TemplateCharacters, $TemplateCharacters$Type} from "packages/dev/latvian/mods/rhino/ast/$TemplateCharacters"

export class $TemplateLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getSize"(): integer
public "getElement"(index: integer): $AstNode
public "addElement"(element: $AstNode$Type): void
public "getElements"(): $List<($AstNode)>
public "getTemplateStrings"(): $List<($TemplateCharacters)>
public "getSubstitutions"(): $List<($AstNode)>
public "setElements"(elements: $List$Type<($AstNode$Type)>): void
get "size"(): integer
get "elements"(): $List<($AstNode)>
get "templateStrings"(): $List<($TemplateCharacters)>
get "substitutions"(): $List<($AstNode)>
set "elements"(value: $List$Type<($AstNode$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemplateLiteral$Type = ($TemplateLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemplateLiteral_ = $TemplateLiteral$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$BoundFluidStackJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export class $BoundFluidStackJS extends $FluidStackJS {

constructor(fs: $FluidStack$Type)

public "getId"(): string
public "setAmount"(amount: long): void
public "copy"(amount: long): $FluidStackJS
public "getAmount"(): long
public "setNbt"(nbt: $CompoundTag$Type): void
public "getNbt"(): $CompoundTag
public "getFluidStack"(): $FluidStack
public "getFluid"(): $Fluid
get "id"(): string
set "amount"(value: long)
get "amount"(): long
set "nbt"(value: $CompoundTag$Type)
get "nbt"(): $CompoundTag
get "fluidStack"(): $FluidStack
get "fluid"(): $Fluid
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundFluidStackJS$Type = ($BoundFluidStackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundFluidStackJS_ = $BoundFluidStackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$GroupFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $GroupFilter implements $RecipeFilter {

constructor(g: string)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupFilter$Type = ($GroupFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GroupFilter_ = $GroupFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$CodeGenerator" {
import {$Icode, $Icode$Type} from "packages/dev/latvian/mods/rhino/$Icode"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$InterpreterData, $InterpreterData$Type} from "packages/dev/latvian/mods/rhino/$InterpreterData"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"

export class $CodeGenerator extends $Icode {


public "compile"(compilerEnv: $CompilerEnvirons$Type, tree: $ScriptNode$Type, returnFunction: boolean, cx: $Context$Type): $InterpreterData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodeGenerator$Type = ($CodeGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodeGenerator_ = $CodeGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$LootBuilderPool" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConditionalFunction, $ConditionalFunction$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionalFunction"
import {$ConditionContainer, $ConditionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionContainer"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FunctionContainer, $FunctionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$FunctionContainer"
import {$CopyNameFunction$NameSource, $CopyNameFunction$NameSource$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$CopyNameFunction$NameSource"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$LootTableEntry, $LootTableEntry$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootTableEntry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LootBuilderPool implements $FunctionContainer, $ConditionContainer {
 "rolls": $NumberProvider
 "bonusRolls": $NumberProvider
readonly "conditions": $JsonArray
readonly "functions": $JsonArray
readonly "entries": $JsonArray

constructor()

public "setUniformRolls"(min: float, max: float): void
public "addEmpty"(weight: integer): $LootTableEntry
public "setBinomialRolls"(n: integer, p: float): void
public "addEntry"(json: $JsonObject$Type): $LootTableEntry
public "toJson"(): $JsonObject
public "addItem"(item: $ItemStack$Type, weight: integer, count: $NumberProvider$Type): $LootTableEntry
public "addItem"(item: $ItemStack$Type): $LootTableEntry
public "addItem"(item: $ItemStack$Type, weight: integer): $LootTableEntry
public "addTag"(tag: string, expand: boolean): $LootTableEntry
public "addLootTable"(table: $ResourceLocation$Type): $LootTableEntry
public "name"(name: $Component$Type): $FunctionContainer
public "name"(name: $Component$Type, entity: $LootContext$EntityTarget$Type): $FunctionContainer
public "count"(count: $NumberProvider$Type): $FunctionContainer
public "damage"(damage: $NumberProvider$Type): $FunctionContainer
public "nbt"(tag: $CompoundTag$Type): $FunctionContainer
public "addConditionalFunction"(func: $Consumer$Type<($ConditionalFunction$Type)>): $FunctionContainer
public "furnaceSmelt"(): $FunctionContainer
public "copyName"(source: $CopyNameFunction$NameSource$Type): $FunctionContainer
public "lootingEnchant"(count: $NumberProvider$Type, limit: integer): $FunctionContainer
public "enchantWithLevels"(levels: $NumberProvider$Type, treasure: boolean): $FunctionContainer
public "enchantRandomly"(enchantments: ($ResourceLocation$Type)[]): $FunctionContainer
public "lootTable"(table: $ResourceLocation$Type, seed: long): $FunctionContainer
public "survivesExplosion"(): $ConditionContainer
public "randomChance"(chance: double): $ConditionContainer
public "randomChanceWithLooting"(chance: double, multiplier: double): $ConditionContainer
public "entityScores"(entity: $LootContext$EntityTarget$Type, scores: $Map$Type<(string), (any)>): $ConditionContainer
public "entityProperties"(entity: $LootContext$EntityTarget$Type, properties: $JsonObject$Type): $ConditionContainer
public "killedByPlayer"(): $ConditionContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootBuilderPool$Type = ($LootBuilderPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootBuilderPool_ = $LootBuilderPool$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$MapJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $MapJS {

}

export namespace $MapJS {
function of(o: any): $Map<(any), (any)>
function json(map: any): $JsonObject
function nbt(map: any): $CompoundTag
function orEmpty(o: any): $Map<(any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapJS$Type = ($MapJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapJS_ = $MapJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Loop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $Loop extends $Scope {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getBody"(): $AstNode
public "setParens"(lp: integer, rp: integer): void
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "setBody"(body: $AstNode$Type): void
get "body"(): $AstNode
set "lp"(value: integer)
set "rp"(value: integer)
get "lp"(): integer
get "rp"(): integer
set "body"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Loop$Type = ($Loop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Loop_ = $Loop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"

export interface $DescriptionContext {

 "typeName"(type: $Class$Type<(any)>): string
 "javaType"(type: $Class$Type<(any)>): $TypeDescJS
}

export namespace $DescriptionContext {
const DEFAULT: $DescriptionContext
const DISPLAY: $DescriptionContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DescriptionContext$Type = ($DescriptionContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DescriptionContext_ = $DescriptionContext$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$JavaScriptException" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export class $JavaScriptException extends $RhinoException {

constructor(cx: $Context$Type, value: any, sourceName: string, lineNumber: integer)

public "getValue"(): any
public "details"(): string
get "value"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaScriptException$Type = ($JavaScriptException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaScriptException_ = $JavaScriptException$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$BlockEvents" {
import {$Extra, $Extra$Type} from "packages/dev/latvian/mods/kubejs/event/$Extra"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $BlockEvents {

}

export namespace $BlockEvents {
const GROUP: $EventGroup
const SUPPORTS_BLOCK: $Extra
const MODIFICATION: $EventHandler
const RIGHT_CLICKED: $EventHandler
const LEFT_CLICKED: $EventHandler
const PLACED: $EventHandler
const BROKEN: $EventHandler
const DETECTOR_CHANGED: $EventHandler
const DETECTOR_POWERED: $EventHandler
const DETECTOR_UNPOWERED: $EventHandler
const FARMLAND_TRAMPLED: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEvents$Type = ($BlockEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEvents_ = $BlockEvents$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$GroupUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $GroupUnit extends $Unit {
readonly "units": ($Unit)[]
static "EMPTY_ARRAY": ($Unit)[]

constructor(units: ($Unit$Type)[])

public "get"(variables: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GroupUnit$Type = ($GroupUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GroupUnit_ = $GroupUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidLike" {
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $FluidLike extends $ReplacementMatch {

 "matches"(other: $FluidLike$Type): boolean
 "copy"(amount: long): $FluidLike
 "getAmount"(): long
 "isEmpty"(): boolean

(other: $FluidLike$Type): boolean
}

export namespace $FluidLike {
function of(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidLike$Type = ($FluidLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidLike_ = $FluidLike$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$CountingMap" {
import {$Object2LongEntry, $Object2LongEntry$Type} from "packages/dev/latvian/mods/rhino/mod/util/$Object2LongEntry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"

export class $CountingMap {

constructor()

public "add"(key: any, value: long): long
public "get"(key: any): long
public "clear"(): void
public "set"(key: any, value: long): long
public "forEach"(forEach: $Consumer$Type<($Object2LongEntry$Type)>): void
public "getSize"(): integer
public "getEntries"(): $List<($Object2LongEntry)>
public "getKeys"(): $Set<(any)>
public "getTotalCount"(): long
public "getValues"(): $Collection<(long)>
get "size"(): integer
get "entries"(): $List<($Object2LongEntry)>
get "keys"(): $Set<(any)>
get "totalCount"(): long
get "values"(): $Collection<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountingMap$Type = ($CountingMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CountingMap_ = $CountingMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$FinishUsingCallback" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $ItemBuilder$FinishUsingCallback {

 "finishUsingItem"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type): $ItemStack

(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type): $ItemStack
}

export namespace $ItemBuilder$FinishUsingCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$FinishUsingCallback$Type = ($ItemBuilder$FinishUsingCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$FinishUsingCallback_ = $ItemBuilder$FinishUsingCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$LootTablesKJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$LootDataId, $LootDataId$Type} from "packages/net/minecraft/world/level/storage/loot/$LootDataId"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LootDataType, $LootDataType$Type} from "packages/net/minecraft/world/level/storage/loot/$LootDataType"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $LootTablesKJS {

 "kjs$completeReload"(parsedMap: $Map$Type<($LootDataType$Type<(any)>), ($Map$Type<($ResourceLocation$Type), (any)>)>, elements: $Map$Type<($LootDataId$Type<(any)>), (any)>): void
}

export namespace $LootTablesKJS {
function kjs$postLootEvents(map: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LootTablesKJS$Type = ($LootTablesKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LootTablesKJS_ = $LootTablesKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptType" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ScriptTypePredicate, $ScriptTypePredicate$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypePredicate"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptTypeHolder, $ScriptTypeHolder$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypeHolder"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptType extends $Enum<($ScriptType)> implements $ScriptTypePredicate, $ScriptTypeHolder {
static readonly "STARTUP": $ScriptType
static readonly "SERVER": $ScriptType
static readonly "CLIENT": $ScriptType
static readonly "VALUES": ($ScriptType)[]
readonly "name": string
readonly "console": $ConsoleJS
readonly "path": $Path
readonly "nameStrip": string


public static "values"(): ($ScriptType)[]
public "test"(type: $ScriptType$Type): boolean
public static "valueOf"(name: string): $ScriptType
public "getLogFile"(): $Path
public "isStartup"(): boolean
public "getValidTypes"(): $List<($ScriptType)>
public "kjs$getScriptType"(): $ScriptType
public "isClient"(): boolean
public static "getCurrent"(cx: $Context$Type): $ScriptType
public "isServer"(): boolean
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($ScriptType)>
public static "isEqual"<T>(arg0: any): $Predicate<($ScriptType)>
get "logFile"(): $Path
get "startup"(): boolean
get "validTypes"(): $List<($ScriptType)>
get "client"(): boolean
get "server"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptType$Type = (("server") | ("startup") | ("client")) | ($ScriptType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptType_ = $ScriptType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/command/$KubeJSCommands" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"
import {$DynamicCommandExceptionType, $DynamicCommandExceptionType$Type} from "packages/com/mojang/brigadier/exceptions/$DynamicCommandExceptionType"

export class $KubeJSCommands {
static readonly "NO_REGISTRY": $DynamicCommandExceptionType

constructor()

public static "register"(dispatcher: $CommandDispatcher$Type<($CommandSourceStack$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCommands$Type = ($KubeJSCommands);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCommands_ = $KubeJSCommands$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$FarmlandTrampledEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * Invoked when an entity attempts to trample farmland.
 */
export class $FarmlandTrampledEventJS extends $EntityEventJS {

constructor(l: $Level$Type, pos: $BlockPos$Type, state: $BlockState$Type, d: float, e: $Entity$Type)

/**
 * The level that the farmland and the entity are in.
 */
public "getLevel"(): $Level
/**
 * The farmland block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * The distance of the entity from the block.
 */
public "getDistance"(): float
/**
 * The entity that is attempting to trample the farmland.
 */
public "getEntity"(): $Entity
get "level"(): $Level
get "block"(): $BlockContainerJS
get "distance"(): float
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FarmlandTrampledEventJS$Type = ($FarmlandTrampledEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FarmlandTrampledEventJS_ = $FarmlandTrampledEventJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$SqrtFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SqrtFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SqrtFuncUnit$Type = ($SqrtFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SqrtFuncUnit_ = $SqrtFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$ChestLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ChestLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "getDirectory"(): string
public "addChest"(id: $ResourceLocation$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestLootEventJS$Type = ($ChestLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestLootEventJS_ = $ChestLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$KubeJSServerEventHandler" {
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CommandPerformEvent, $CommandPerformEvent$Type} from "packages/dev/architectury/event/events/common/$CommandPerformEvent"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$EventResult, $EventResult$Type} from "packages/dev/architectury/event/$EventResult"
import {$Commands$CommandSelection, $Commands$CommandSelection$Type} from "packages/net/minecraft/commands/$Commands$CommandSelection"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"

export class $KubeJSServerEventHandler {

constructor()

public static "init"(): void
public static "command"(event: $CommandPerformEvent$Type): $EventResult
public static "registerCommands"(dispatcher: $CommandDispatcher$Type<($CommandSourceStack$Type)>, registry: $CommandBuildContext$Type, selection: $Commands$CommandSelection$Type): void
public static "serverBeforeStart"(server: $MinecraftServer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSServerEventHandler$Type = ($KubeJSServerEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSServerEventHandler_ = $KubeJSServerEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$ErroredRecipeJS" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RecipeExceptionJS, $RecipeExceptionJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeExceptionJS"
import {$RecipesEventJS, $RecipesEventJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipesEventJS"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ErroredRecipeJS extends $RecipeJS {
readonly "dummyFunction": $BaseFunction
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor(event: $RecipesEventJS$Type, rex: $RecipeExceptionJS$Type)
constructor(event: $RecipesEventJS$Type, errorMessage: string, rex: $RecipeExceptionJS$Type, skipError: $Pattern$Type)

public "toString"(): string
public "deserialize"(merge: boolean): void
public "getAllValueMap"(): $Map<(string), ($RecipeComponentValue<(any)>)>
public "serialize"(): void
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
get "allValueMap"(): $Map<(string), ($RecipeComponentValue<(any)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ErroredRecipeJS$Type = ($ErroredRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ErroredRecipeJS_ = $ErroredRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$EntitySpawnedEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * Invoked when an entity is about to be added to the world.
 * 
 * This event also fires for existing entities when they are loaded from a save.
 */
export class $EntitySpawnedEventJS extends $EntityEventJS {

constructor(entity: $Entity$Type, level: $Level$Type)

/**
 * The level the entity is being added to.
 */
public "getLevel"(): $Level
/**
 * The entity being added to the world.
 */
public "getEntity"(): $Entity
get "level"(): $Level
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySpawnedEventJS$Type = ($EntitySpawnedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySpawnedEventJS_ = $EntitySpawnedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$FixedArrayDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export class $FixedArrayDescJS extends $Record implements $TypeDescJS {

constructor(types: ($TypeDescJS$Type)[])

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "types"(): ($TypeDescJS)[]
public "build"(builder: $StringBuilder$Type): void
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "build"(): string
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FixedArrayDescJS$Type = ($FixedArrayDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FixedArrayDescJS_ = $FixedArrayDescJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$WrappedExecutable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Executable, $Executable$Type} from "packages/java/lang/reflect/$Executable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $WrappedExecutable {

 "invoke"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: any, arg3: (any)[]): any
 "getReturnType"(): $Class<(any)>
 "isStatic"(): boolean
 "unwrap"(): $Executable
 "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): any

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: any, arg3: (any)[]): any
}

export namespace $WrappedExecutable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedExecutable$Type = ($WrappedExecutable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedExecutable_ = $WrappedExecutable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/predicate/$BlockPredicate" {
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"

export interface $BlockPredicate {

 "check"(arg0: $BlockContainerJS$Type): boolean

(arg0: $BlockContainerJS$Type): boolean
}

export namespace $BlockPredicate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockPredicate$Type = ($BlockPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockPredicate_ = $BlockPredicate$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$LabeledStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Label, $Label$Type} from "packages/dev/latvian/mods/rhino/ast/$Label"

export class $LabeledStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getLabels"(): $List<($Label)>
public "setStatement"(statement: $AstNode$Type): void
public "getFirstLabel"(): $Label
public "hasSideEffects"(): boolean
public "addLabel"(label: $Label$Type): void
public "setLabels"(labels: $List$Type<($Label$Type)>): void
public "getLabelByName"(name: string): $Label
public "getStatement"(): $AstNode
get "labels"(): $List<($Label)>
set "statement"(value: $AstNode$Type)
get "firstLabel"(): $Label
set "labels"(value: $List$Type<($Label$Type)>)
get "statement"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LabeledStatement$Type = ($LabeledStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LabeledStatement_ = $LabeledStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$FallingBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export class $FallingBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "dustColor"(color: $Color$Type): $FallingBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FallingBlockBuilder$Type = ($FallingBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FallingBlockBuilder_ = $FallingBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$RadFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $RadFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RadFuncUnit$Type = ($RadFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RadFuncUnit_ = $RadFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$FastDtoa" {
import {$FastDtoaBuilder, $FastDtoaBuilder$Type} from "packages/dev/latvian/mods/rhino/v8dtoa/$FastDtoaBuilder"

export class $FastDtoa {

constructor()

public static "dtoa"(v: double, buffer: $FastDtoaBuilder$Type): boolean
public static "numberToString"(v: double): string
public static "numberToString"(v: double, buffer: $FastDtoaBuilder$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FastDtoa$Type = ($FastDtoa);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FastDtoa_ = $FastDtoa$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $OrRecipeComponent<H, L> extends $Record implements $RecipeComponent<($Either<(H), (L)>)> {

constructor(high: $RecipeComponent$Type<(H)>, low: $RecipeComponent$Type<(L)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: $Either$Type<(H), (L)>): $JsonElement
public "read"(recipe: $RecipeJS$Type, from: any): $Either<(H), (L)>
public "high"(): $RecipeComponent<(H)>
public "low"(): $RecipeComponent<(L)>
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: $Either$Type<(H), (L)>, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $Either$Type<(H), (L)>, match: $ReplacementMatch$Type): boolean
public "replaceOutput"(recipe: $RecipeJS$Type, original: $Either$Type<(H), (L)>, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $Either<(H), (L)>
public "replaceInput"(recipe: $RecipeJS$Type, original: $Either$Type<(H), (L)>, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $Either<(H), (L)>
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "checkValueHasChanged"(oldValue: $Either$Type<(H), (L)>, newValue: $Either$Type<(H), (L)>): boolean
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Either<(H), (L)>)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($Either<(H), (L)>)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($Either<(H), (L)>), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($Either<(H), (L)>), (O)>
public "asArray"(): $ArrayRecipeComponent<($Either<(H), (L)>)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($Either<(H), (L)>)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($Either<(H), (L)>)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($Either<(H), (L)>)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Either$Type<(H), (L)>)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Either$Type<(H), (L)>)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($Either$Type<(H), (L)>)>, map: $Map$Type<(any), (any)>): void
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "orSelf"(): $RecipeComponent<($Either<(H), (L)>)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($Either<(H), (L)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($Either<(H), (L)>)>)>
public "checkEmpty"(key: $RecipeKey$Type<($Either$Type<(H), (L)>)>, value: $Either$Type<(H), (L)>): string
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($Either<(H), (L)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrRecipeComponent$Type<H, L> = ($OrRecipeComponent<(H), (L)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrRecipeComponent_<H, L> = $OrRecipeComponent$Type<(H), (L)>;
}}
declare module "packages/dev/latvian/mods/rhino/$TopLevel$Builtins" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TopLevel$Builtins extends $Enum<($TopLevel$Builtins)> {
static readonly "Object": $TopLevel$Builtins
static readonly "Array": $TopLevel$Builtins
static readonly "Function": $TopLevel$Builtins
static readonly "String": $TopLevel$Builtins
static readonly "Number": $TopLevel$Builtins
static readonly "Boolean": $TopLevel$Builtins
static readonly "RegExp": $TopLevel$Builtins
static readonly "Error": $TopLevel$Builtins
static readonly "Symbol": $TopLevel$Builtins
static readonly "GeneratorFunction": $TopLevel$Builtins


public static "values"(): ($TopLevel$Builtins)[]
public static "valueOf"(name: string): $TopLevel$Builtins
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TopLevel$Builtins$Type = (("number") | ("regexp") | ("symbol") | ("boolean") | ("string") | ("array") | ("function") | ("error") | ("generatorfunction") | ("object")) | ($TopLevel$Builtins);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TopLevel$Builtins_ = $TopLevel$Builtins$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$FluidComponents" {
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$OutputFluid, $OutputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$Either, $Either$Type} from "packages/com/mojang/datafixers/util/$Either"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $FluidComponents {

}

export namespace $FluidComponents {
const INPUT: $RecipeComponent<($InputFluid)>
const INPUT_ARRAY: $RecipeComponent<(($InputFluid)[])>
const INPUT_OR_ITEM: $RecipeComponent<($Either<($InputFluid), ($InputItem)>)>
const INPUT_OR_ITEM_ARRAY: $RecipeComponent<(($Either<($InputFluid), ($InputItem)>)[])>
const OUTPUT: $RecipeComponent<($OutputFluid)>
const OUTPUT_ARRAY: $RecipeComponent<(($OutputFluid)[])>
const OUTPUT_OR_ITEM: $RecipeComponent<($Either<($OutputFluid), ($OutputItem)>)>
const OUTPUT_OR_ITEM_ARRAY: $RecipeComponent<(($Either<($OutputFluid), ($OutputItem)>)[])>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidComponents$Type = ($FluidComponents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidComponents_ = $FluidComponents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockExplodedCallbackJS" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $BlockExplodedCallbackJS {

constructor(level: $Level$Type, pos: $BlockPos$Type, explosion: $Explosion$Type)

public "getCause"(): $Entity
public "getLevel"(): $Level
public "getBlock"(): $BlockContainerJS
public "getRadius"(): float
public "getExplosion"(): $Explosion
public "getDamageSource"(): $DamageSource
public "getBlockState"(): $BlockState
public "getAffectedPlayers"(): $List<($Player)>
public "getIgniter"(): $LivingEntity
get "cause"(): $Entity
get "level"(): $Level
get "block"(): $BlockContainerJS
get "radius"(): float
get "explosion"(): $Explosion
get "damageSource"(): $DamageSource
get "blockState"(): $BlockState
get "affectedPlayers"(): $List<($Player)>
get "igniter"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockExplodedCallbackJS$Type = ($BlockExplodedCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockExplodedCallbackJS_ = $BlockExplodedCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$SoundEventBuilder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $SoundEventBuilder extends $BuilderBase<($SoundEvent)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundEventBuilder$Type = ($SoundEventBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundEventBuilder_ = $SoundEventBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/predicate/$BlockIDPredicate$PropertyObject" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"

export class $BlockIDPredicate$PropertyObject extends $Record {

constructor(property: $Property$Type<(any)>, value: any)

public "value"(): any
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "property"(): $Property<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockIDPredicate$PropertyObject$Type = ($BlockIDPredicate$PropertyObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockIDPredicate$PropertyObject_ = $BlockIDPredicate$PropertyObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ClassFileField" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClassFileField {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFileField$Type = ($ClassFileField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFileField_ = $ClassFileField$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$SmithingTemplateItemBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$LangEventJS, $LangEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$LangEventJS"
import {$SmithingTemplateItem, $SmithingTemplateItem$Type} from "packages/net/minecraft/world/item/$SmithingTemplateItem"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SmithingTemplateItemBuilder extends $ItemBuilder {
 "appliesToText": $Component
 "ingredientsText": $Component
 "appliesToSlotDescriptionText": $Component
 "ingredientSlotDescriptionText": $Component
readonly "appliesToEmptyIcons": $List<($ResourceLocation)>
readonly "ingredientsSlotEmptyIcons": $List<($ResourceLocation)>
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $SmithingTemplateItem
public "generateLang"(lang: $LangEventJS$Type): void
/**
 * Adds all armor and basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "equipmentIcons"(): $SmithingTemplateItemBuilder
/**
 * Adds a dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "crystalIcons"(): $SmithingTemplateItemBuilder
/**
 * Adds an ingot to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds an amethyst shard to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shardIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a quartz to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "quartzIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a lapis lazuli to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "lapisIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a axe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "axeIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a pickaxe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "pickaxeIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a hoe to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "hoeIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a dust to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "dustIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds all armor icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "armorIcons"(): $SmithingTemplateItemBuilder
/**
 * Adds a diamond to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "diamondIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a shovel to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "shovelIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds an emerald to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "emeraldIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a sword to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "swordIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds a helmet to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "helmetIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds all basic tool icons to the list of base slot icons that the smithing table cycles through when this smithing template is put in
 */
public "toolIcons"(): $SmithingTemplateItemBuilder
/**
 * Adds a chestplate to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "chestplateIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds boots to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "bootsIcon"(): $SmithingTemplateItemBuilder
/**
 * Adds leggings to the list of base item slot icons that the smithing table cycles through when this smithing template is put in
 */
public "leggingsIcon"(): $SmithingTemplateItemBuilder
/**
 * Sets the description text that shows in the item tooltip to describe what it can be applied to.
 * Using 'Armor' or 'Diamond Equipment' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "appliesTo"(text: string): $SmithingTemplateItemBuilder
/**
 * Adds an ingot, dust, diamond, emerald, quartz, lapis lazuli and amethyst shard icons to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "ingotAndCrystalIcons"(): $SmithingTemplateItemBuilder
/**
 * Sets the description text that shows when you hover over the base item slot when this item is put in smithing table as a template.
 * Using 'Add a piece of armor' or 'Add diamond armor, weapon, or tool' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `appliesToSlotDescriptionText` field.
 */
public "appliesToSlotDescription"(text: string): $SmithingTemplateItemBuilder
/**
 * Sets the description text that shows when you hover over the ingredient slot when this item is put in smithing table as a template.
 * Using 'Add ingot or crystal' or 'Add Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientSlotDescriptionText` field.
 */
public "ingredientsSlotDescription"(text: string): $SmithingTemplateItemBuilder
/**
 * Adds the specified texture location to the list of ingredient slot icons that the smithing table cycles through when this smithing template is put in
 */
public "addIngredientsSlotIcon"(location: $ResourceLocation$Type): $SmithingTemplateItemBuilder
/**
 * Adds the specified texture location to the list of base slot icons that the smithing table cycles through when this smithing template is put in.
 */
public "addAppliesToSlotIcon"(location: $ResourceLocation$Type): $SmithingTemplateItemBuilder
/**
 * Sets the description text that shows in the item tooltip to describe what ingredients can be added.
 * Using 'Ingots & Crystals' or 'Netherite Ingot' will use the vanilla language keys so it is translated into other languages automatically.
 * THIS IS PURELY VISUAL
 * 
 * If you wish to apply non standard formatting (like change the colour) set the `ingredientsText` field.
 */
public "ingredients"(text: string): $SmithingTemplateItemBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTemplateItemBuilder$Type = ($SmithingTemplateItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmithingTemplateItemBuilder_ = $SmithingTemplateItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$CustomIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $CustomIngredient extends $KubeJSIngredient {
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($CustomIngredient)>
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(predicate: $Predicate$Type<($ItemStack$Type)>)

public "test"(stack: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getSerializer"(): $IIngredientSerializer<($CustomIngredient)>
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "serializer"(): $IIngredientSerializer<($CustomIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredient$Type = ($CustomIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomIngredient_ = $CustomIngredient$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$Tags" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $Tags {

constructor()

public static "block"(id: $ResourceLocation$Type): $TagKey<($Block)>
public static "item"(id: $ResourceLocation$Type): $TagKey<($Item)>
public static "forType"<T>(object: T, registry: $Registry$Type<(T)>): $Stream<($TagKey<(T)>)>
public static "byFluid"(fluid: $Fluid$Type): $Stream<($TagKey<($Fluid)>)>
public static "entityType"(id: $ResourceLocation$Type): $TagKey<($EntityType<(any)>)>
public static "biome"(id: $ResourceLocation$Type): $TagKey<($Biome)>
public static "byItem"(item: $Item$Type): $Stream<($TagKey<($Item)>)>
public static "byBlockState"(state: $BlockState$Type): $Stream<($TagKey<($Block)>)>
public static "byEntity"(entity: $Entity$Type): $Stream<($TagKey<($EntityType<(any)>)>)>
public static "byBlock"(block: $Block$Type): $Stream<($TagKey<($Block)>)>
public static "byEntityType"(entityType: $EntityType$Type<(any)>): $Stream<($TagKey<($EntityType<(any)>)>)>
public static "byItemStack"(stack: $ItemStack$Type): $Stream<($TagKey<($Item)>)>
public static "fluid"(id: $ResourceLocation$Type): $TagKey<($Fluid)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Tags$Type = ($Tags);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Tags_ = $Tags$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptSource" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptFileInfo, $ScriptFileInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptFileInfo"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ScriptSource {

 "readSource"(arg0: $ScriptFileInfo$Type): $List<(string)>

(arg0: $ScriptFileInfo$Type): $List<(string)>
}

export namespace $ScriptSource {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptSource$Type = ($ScriptSource);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptSource_ = $ScriptSource$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$ReleaseUsingCallback" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $ItemBuilder$ReleaseUsingCallback {

 "releaseUsing"(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void

(arg0: $ItemStack$Type, arg1: $Level$Type, arg2: $LivingEntity$Type, arg3: integer): void
}

export namespace $ItemBuilder$ReleaseUsingCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$ReleaseUsingCallback$Type = ($ItemBuilder$ReleaseUsingCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$ReleaseUsingCallback_ = $ItemBuilder$ReleaseUsingCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachmentType" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"
import {$BlockEntityAttachment$Factory, $BlockEntityAttachment$Factory$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment$Factory"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockEntityAttachmentType extends $Record {
static readonly "ALL": $Lazy<($Map<(string), ($BlockEntityAttachmentType)>)>

constructor(type: string, input: $ObjectDescJS$Type, factory: $Function$Type<($Map$Type<(string), (any)>), ($BlockEntityAttachment$Factory$Type)>)

public "type"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $Function<($Map<(string), (any)>), ($BlockEntityAttachment$Factory)>
public "input"(): $ObjectDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentType$Type = ($BlockEntityAttachmentType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentType_ = $BlockEntityAttachmentType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$GenericForgeEventConsumer" {
import {$GenericEvent, $GenericEvent$Type} from "packages/net/minecraftforge/eventbus/api/$GenericEvent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $GenericForgeEventConsumer extends $Consumer<($GenericEvent<(any)>)> {

 "accept"(arg0: $GenericEvent$Type<(any)>): void
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<($GenericEvent<(any)>)>

(arg0: $GenericEvent$Type<(any)>): void
}

export namespace $GenericForgeEventConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericForgeEventConsumer$Type = ($GenericForgeEventConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericForgeEventConsumer_ = $GenericForgeEventConsumer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$InvertRuleTest" {
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export class $InvertRuleTest extends $RuleTest {
static readonly "CODEC": $Codec<($InvertRuleTest)>
readonly "original": $RuleTest

constructor(t: $RuleTest$Type)

public "test"(blockState: $BlockState$Type, random: $RandomSource$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvertRuleTest$Type = ($InvertRuleTest);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvertRuleTest_ = $InvertRuleTest$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$CosFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $CosFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CosFuncUnit$Type = ($CosFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CosFuncUnit_ = $CosFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$WindowKJS" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"

export interface $WindowKJS {

 "kjs$loadIcons"(original: $List$Type<($IoSupplier$Type<($InputStream$Type)>)>): $List<($IoSupplier<($InputStream)>)>
}

export namespace $WindowKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowKJS$Type = ($WindowKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowKJS_ = $WindowKJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$BoolFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $BoolFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public "getFloat"(variables: $UnitVariables$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoolFuncUnit$Type = ($BoolFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoolFuncUnit_ = $BoolFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$ShapelessRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $ShapelessRecipeSchema {

}

export namespace $ShapelessRecipeSchema {
const RESULT: $RecipeKey<($OutputItem)>
const INGREDIENTS: $RecipeKey<(($InputItem)[])>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessRecipeSchema$Type = ($ShapelessRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessRecipeSchema_ = $ShapelessRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$HsvFuncUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"

export class $HsvFuncUnit extends $FuncUnit {
readonly "h": $Unit
readonly "s": $Unit
readonly "v": $Unit
readonly "a": $Unit
static readonly "FACTORY": $FunctionFactory
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(args: ($Unit$Type)[])

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public "withAlpha"(a: $Unit$Type): $Unit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HsvFuncUnit$Type = ($HsvFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HsvFuncUnit_ = $HsvFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MinecraftRemapper" {
import {$Remapper, $Remapper$Type} from "packages/dev/latvian/mods/rhino/util/$Remapper"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $MinecraftRemapper implements $Remapper {


public static "load"(stream: $InputStream$Type, debug: boolean): $MinecraftRemapper
public "getUnmappedClass"(mmName: string): string
public "getMappedField"(from: $Class$Type<(any)>, field: $Field$Type): string
public "getMappedMethod"(from: $Class$Type<(any)>, method: $Method$Type): string
public "getMappedClass"(from: $Class$Type<(any)>): string
public static "getTypeName"(type: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftRemapper$Type = ($MinecraftRemapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftRemapper_ = $MinecraftRemapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ClientProperties" {
import {$OptionalInt, $OptionalInt$Type} from "packages/java/util/$OptionalInt"

export class $ClientProperties {
 "title": string
 "blurScaledPackIcon": boolean


public "get"(key: string, def: boolean): boolean
public "get"(key: string, def: double): double
public "get"(key: string, def: integer): integer
public "get"(key: string, def: string): string
public static "get"(): $ClientProperties
public "save"(): void
public static "reload"(): void
public "getMemoryColor"(color: (float)[]): (float)[]
public "getLogColor"(color: (float)[]): (float)[]
public "getShowTagNames"(): boolean
public "getColor3f"(color: integer): (float)[]
public "getExportAtlases"(): boolean
public "getBackgroundColor"(): $OptionalInt
public "getBarColor"(color: integer): integer
public "getBarBorderColor"(color: integer): integer
public "getColor"(key: string, def: integer): integer
public "getDisableRecipeBook"(): boolean
public "getMenuBackgroundScale"(): float
public "getMenuInnerBackgroundBrightness"(): integer
public "getMenuBackgroundBrightness"(): integer
get "showTagNames"(): boolean
get "exportAtlases"(): boolean
get "backgroundColor"(): $OptionalInt
get "disableRecipeBook"(): boolean
get "menuBackgroundScale"(): float
get "menuInnerBackgroundBrightness"(): integer
get "menuBackgroundBrightness"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientProperties$Type = ($ClientProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientProperties_ = $ClientProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$StencilTexture" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BufferedImage, $BufferedImage$Type} from "packages/java/awt/image/$BufferedImage"

export class $StencilTexture {
 "width": integer
 "height": integer
 "pixels": (integer)[]
 "mcmeta": (byte)[]

constructor(img: $BufferedImage$Type, mcmeta: (byte)[])

public "create"(colors: $JsonObject$Type): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StencilTexture$Type = ($StencilTexture);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StencilTexture_ = $StencilTexture$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ConstantEntry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ConstantEntry {


public "equals"(obj: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantEntry$Type = ($ConstantEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstantEntry_ = $ConstantEntry$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$ArrayDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export class $ArrayDescJS extends $Record implements $TypeDescJS {

constructor(type: $TypeDescJS$Type)

public "type"(): $TypeDescJS
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "build"(builder: $StringBuilder$Type): void
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "build"(): string
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDescJS$Type = ($ArrayDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDescJS_ = $ArrayDescJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$TypeDef" {
import {$MojangMappings$MethodDefSignature, $MojangMappings$MethodDefSignature$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MethodDefSignature"
import {$MojangMappings$ClassDef, $MojangMappings$ClassDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$ClassDef"

export class $MojangMappings$TypeDef {
readonly "parent": $MojangMappings$ClassDef
readonly "array": integer
 "occurrences": integer
 "index": integer

constructor(parent: $MojangMappings$ClassDef$Type, array: integer)

public "getRawDescriptor"(): string
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(other: $MojangMappings$TypeDef$Type): integer
public "getSingleArgumentSignature"(): $MojangMappings$MethodDefSignature
get "rawDescriptor"(): string
get "singleArgumentSignature"(): $MojangMappings$MethodDefSignature
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$TypeDef$Type = ($MojangMappings$TypeDef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings$TypeDef_ = $MojangMappings$TypeDef$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$MinecraftClientKJS" {
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$MinecraftEnvironmentKJS, $MinecraftEnvironmentKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MinecraftEnvironmentKJS"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$Callback"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export interface $MinecraftClientKJS extends $MinecraftEnvironmentKJS {

 "self"(): $Minecraft
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "setCurrentScreen"(gui: $Screen$Type): void
 "getCurrentScreen"(): $Screen
 "getCurrentWorldName"(): string
 "isKeyDown"(key: integer): boolean
 "isCtrlDown"(): boolean
 "isAltDown"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "isShiftDown"(): boolean
 "tell"(message: $Component$Type): void
 "setTitle"(t: string): void
 "getScheduledEvents"(): $ScheduledEvents
 "scheduleRepeatingInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleRepeating"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "scheduleInTicks"(ticks: long, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "schedule"(timer: $TemporalAmount$Type, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
 "getDisplayName"(): $Component

(): $Minecraft
}

export namespace $MinecraftClientKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinecraftClientKJS$Type = ($MinecraftClientKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinecraftClientKJS_ = $MinecraftClientKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"

export class $NotificationBuilder {
static readonly "NO_TEXT": ($Component)[]
static readonly "DEFAULT_DURATION": $Duration
static readonly "DEFAULT_BORDER_COLOR": $Color
static readonly "DEFAULT_BACKGROUND_COLOR": $Color
 "duration": $Duration
 "text": $Component
 "iconSize": integer
 "outlineColor": $Color
 "borderColor": $Color
 "backgroundColor": $Color
 "textShadow": boolean

constructor(buf: $FriendlyByteBuf$Type)
constructor()

public static "of"(cx: $Context$Type, object: any): $NotificationBuilder
public static "make"(consumer: $Consumer$Type<($NotificationBuilder$Type)>): $NotificationBuilder
public "write"(buf: $FriendlyByteBuf$Type): void
public "setAtlasIcon"(icon: string): void
public "setItemIcon"(stack: $ItemStack$Type): void
public "show"(): void
public "setIcon"(icon: string): void
set "atlasIcon"(value: string)
set "itemIcon"(value: $ItemStack$Type)
set "icon"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationBuilder$Type = ((builder: $NotificationBuilder) => void) | ($Component$Type) | ($NotificationBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotificationBuilder_ = $NotificationBuilder$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$SetUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SetUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(symbol: $UnitSymbol$Type, left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SetUnit$Type = ($SetUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SetUnit_ = $SetUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$SyncStagesMessage" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SyncStagesMessage extends $BaseS2CMessage {

constructor(p: $UUID$Type, s: $Collection$Type<(string)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SyncStagesMessage$Type = ($SyncStagesMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SyncStagesMessage_ = $SyncStagesMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$FunctionContainer" {
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ConditionalFunction, $ConditionalFunction$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionalFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CopyNameFunction$NameSource, $CopyNameFunction$NameSource$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$CopyNameFunction$NameSource"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"

export interface $FunctionContainer {

 "name"(name: $Component$Type): $FunctionContainer
 "name"(name: $Component$Type, entity: $LootContext$EntityTarget$Type): $FunctionContainer
 "count"(count: $NumberProvider$Type): $FunctionContainer
 "addFunction"(arg0: $JsonObject$Type): $FunctionContainer
 "damage"(damage: $NumberProvider$Type): $FunctionContainer
 "nbt"(tag: $CompoundTag$Type): $FunctionContainer
 "addConditionalFunction"(func: $Consumer$Type<($ConditionalFunction$Type)>): $FunctionContainer
 "furnaceSmelt"(): $FunctionContainer
 "copyName"(source: $CopyNameFunction$NameSource$Type): $FunctionContainer
 "lootingEnchant"(count: $NumberProvider$Type, limit: integer): $FunctionContainer
 "enchantWithLevels"(levels: $NumberProvider$Type, treasure: boolean): $FunctionContainer
 "enchantRandomly"(enchantments: ($ResourceLocation$Type)[]): $FunctionContainer
 "lootTable"(table: $ResourceLocation$Type, seed: long): $FunctionContainer

(name: $Component$Type): $FunctionContainer
}

export namespace $FunctionContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionContainer$Type = ($FunctionContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionContainer_ = $FunctionContainer$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ContinueStatement" {
import {$Name, $Name$Type} from "packages/dev/latvian/mods/rhino/ast/$Name"
import {$Jump, $Jump$Type} from "packages/dev/latvian/mods/rhino/ast/$Jump"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Loop, $Loop$Type} from "packages/dev/latvian/mods/rhino/ast/$Loop"

export class $ContinueStatement extends $Jump {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, label: $Name$Type)
constructor(pos: integer, label: $Name$Type)
constructor(label: $Name$Type)
constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

public "getTarget"(): $Loop
public "setTarget"(target: $Loop$Type): void
public "setLabel"(label: $Name$Type): void
public "getLabel"(): $Name
get "target"(): $Loop
set "target"(value: $Loop$Type)
set "label"(value: $Name$Type)
get "label"(): $Name
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinueStatement$Type = ($ContinueStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinueStatement_ = $ContinueStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/ingredient/$TagContext" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$Holder, $Holder$Type} from "packages/net/minecraft/core/$Holder"
import {$TagManager$LoadResult, $TagManager$LoadResult$Type} from "packages/net/minecraft/tags/$TagManager$LoadResult"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$MutableObject, $MutableObject$Type} from "packages/org/apache/commons/lang3/mutable/$MutableObject"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"

export interface $TagContext {

 "isEmpty"<T>(tag: $TagKey$Type<(T)>): boolean
 "contains"<T>(tag: $TagKey$Type<(T)>, value: T): boolean
 "getTag"<T>(arg0: $TagKey$Type<(T)>): $Iterable<($Holder<(T)>)>
 "patchIngredientTags"(tag: $TagKey$Type<($Item$Type)>): $Collection<($ItemStack)>
 "areTagsBound"(): boolean

(tag: $TagKey$Type<(T)>): boolean
}

export namespace $TagContext {
const EMPTY: $TagContext
const INSTANCE: $MutableObject<($TagContext)>
function usingRegistry(registryAccess: $RegistryAccess$Type): $TagContext
function fromLoadResult(results: $List$Type<($TagManager$LoadResult$Type<(any)>)>): $TagContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagContext$Type = ($TagContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagContext_ = $TagContext$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$KubeJSNet" {
import {$SimpleNetworkManager, $SimpleNetworkManager$Type} from "packages/dev/architectury/networking/simple/$SimpleNetworkManager"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export interface $KubeJSNet {

}

export namespace $KubeJSNet {
const NET: $SimpleNetworkManager
const SEND_DATA_FROM_CLIENT: $MessageType
const SEND_DATA_FROM_SERVER: $MessageType
const PAINT: $MessageType
const ADD_STAGE: $MessageType
const REMOVE_STAGE: $MessageType
const SYNC_STAGES: $MessageType
const FIRST_CLICK: $MessageType
const NOTIFICATION: $MessageType
const RELOAD_STARTUP_SCRIPTS: $MessageType
const DISPLAY_SERVER_ERRORS: $MessageType
const DISPLAY_CLIENT_ERRORS: $MessageType
function init(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSNet$Type = ($KubeJSNet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSNet_ = $KubeJSNet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ClassFilter" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ClassFilter {

constructor()

public "allow"(c: $Class$Type<(any)>): void
public "allow"(s: string): void
public "isAllowed"(s: string): boolean
public "deny"(c: $Class$Type<(any)>): void
public "deny"(s: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFilter$Type = ($ClassFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFilter_ = $ClassFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$Possible" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $Possible<T> extends $Record {
static readonly "EMPTY": $Possible<(any)>
static readonly "NULL": $Possible<(any)>

constructor(value: any)

public "value"(): any
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "cast"<C>(type: $Class$Type<(C)>): $Possible<(C)>
public "isEmpty"(): boolean
public static "of"<T>(o: T): $Possible<(T)>
public "isSet"(): boolean
public static "absent"<T>(): $Possible<(T)>
get "empty"(): boolean
get "set"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Possible$Type<T> = ($Possible<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Possible_<T> = $Possible$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/$IngredientForgeHelper" {
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$IngredientPlatformHelper, $IngredientPlatformHelper$Type} from "packages/dev/latvian/mods/kubejs/platform/$IngredientPlatformHelper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $IngredientForgeHelper implements $IngredientPlatformHelper {

constructor()

public "regex"(pattern: $Pattern$Type): $Ingredient
public static "register"(): void
public "mod"(mod: string): $Ingredient
public "wildcard"(): $Ingredient
public "or"(ingredients: ($Ingredient$Type)[]): $Ingredient
public "subtract"(base: $Ingredient$Type, subtracted: $Ingredient$Type): $Ingredient
public "and"(ingredients: ($Ingredient$Type)[]): $Ingredient
public "isWildcard"(ingredient: $Ingredient$Type): boolean
public "creativeTab"(tab: $CreativeModeTab$Type): $Ingredient
public "custom"(parent: $Ingredient$Type, predicate: $Predicate$Type<($ItemStack$Type)>): $Ingredient
public "custom"(parent: $Ingredient$Type, uuid: $UUID$Type): $Ingredient
public "strongNBT"(item: $ItemStack$Type): $Ingredient
public "weakNBT"(item: $ItemStack$Type): $Ingredient
public static "get"(): $IngredientPlatformHelper
public "stack"(ingredient: $Ingredient$Type, count: integer): $InputItem
public "tag"(tag: string): $Ingredient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientForgeHelper$Type = ($IngredientForgeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientForgeHelper_ = $IngredientForgeHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/platform/$FluidIngredientHelper" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$OpenEndedPipe$IEffectHandler, $OpenEndedPipe$IEffectHandler$Type} from "packages/com/simibubi/create/content/fluids/$OpenEndedPipe$IEffectHandler"
import {$FluidIngredient, $FluidIngredient$Type} from "packages/com/simibubi/create/foundation/fluid/$FluidIngredient"
import {$SpecialSpoutHandlerEvent$SpoutHandler, $SpecialSpoutHandlerEvent$SpoutHandler$Type} from "packages/dev/latvian/mods/kubejs/create/events/$SpecialSpoutHandlerEvent$SpoutHandler"
import {$BlockStatePredicate, $BlockStatePredicate$Type} from "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate"
import {$OpenEndedPipe, $OpenEndedPipe$Type} from "packages/com/simibubi/create/content/fluids/$OpenEndedPipe"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"
import {$BlockSpoutingBehaviour, $BlockSpoutingBehaviour$Type} from "packages/com/simibubi/create/api/behaviour/$BlockSpoutingBehaviour"

export class $FluidIngredientHelper {

constructor()

public static "toFluidIngredient"(fluidStack: $FluidStackJS$Type): $FluidIngredient
public static "createEffectHandler"(fluidIngredient: $FluidIngredient$Type, handler: $BiConsumer$Type<($OpenEndedPipe$Type), ($FluidStackJS$Type)>): $OpenEndedPipe$IEffectHandler
public static "createSpoutingHandler"(block: $BlockStatePredicate$Type, handler: $SpecialSpoutHandlerEvent$SpoutHandler$Type): $BlockSpoutingBehaviour
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidIngredientHelper$Type = ($FluidIngredientHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidIngredientHelper_ = $FluidIngredientHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$ClientGamePacketListener, $ClientGamePacketListener$Type} from "packages/net/minecraft/network/protocol/game/$ClientGamePacketListener"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Packet, $Packet$Type} from "packages/net/minecraft/network/protocol/$Packet"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityAttachment, $BlockEntityAttachment$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEntityJS extends $BlockEntity {
readonly "info": $BlockEntityInfo
readonly "x": integer
readonly "y": integer
readonly "z": integer
 "tick": integer
 "cycle": integer
 "data": $CompoundTag
readonly "attachments": ($BlockEntityAttachment)[]
 "inventory": $InventoryKJS
 "placerId": $UUID
 "blockState": $BlockState

constructor(blockPos: $BlockPos$Type, blockState: $BlockState$Type, entityInfo: $BlockEntityInfo$Type)

public "sendEvent"(eventId: integer, data: integer): void
public "save"(): void
public "sync"(): void
public "getBlock"(): $BlockContainerJS
public "load"(tag: $CompoundTag$Type): void
public "triggerEvent"(eventId: integer, data: integer): boolean
public "getUpdateTag"(): $CompoundTag
public "getUpdatePacket"(): $Packet<($ClientGamePacketListener)>
get "block"(): $BlockContainerJS
get "updateTag"(): $CompoundTag
get "updatePacket"(): $Packet<($ClientGamePacketListener)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityJS$Type = ($BlockEntityJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityJS_ = $BlockEntityJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ModelGenerator$Face" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"

export class $ModelGenerator$Face {

constructor()

public "toJson"(): $JsonObject
public "tintindex"(i: integer): $ModelGenerator$Face
public "uv"(u0: double, v0: double, u1: double, v1: double): $ModelGenerator$Face
public "tex"(t: string): $ModelGenerator$Face
public "cull"(): $ModelGenerator$Face
public "cull"(d: $Direction$Type): $ModelGenerator$Face
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Face$Type = ($ModelGenerator$Face);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator$Face_ = $ModelGenerator$Face$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$SingleItemMatch" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemMatch, $ItemMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ItemMatch"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $SingleItemMatch extends $Record implements $ItemMatch {

constructor(stack: $ItemStack$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "contains"(item: $ItemStack$Type): boolean
public "contains"(itemLike: $ItemLike$Type): boolean
public "contains"(arg0: $Ingredient$Type): boolean
public "stack"(): $ItemStack
/**
 * 
 * @deprecated
 */
public "contains"(block: $Block$Type): boolean
public "containsAny"(itemLikes: $Iterable$Type<($ItemLike$Type)>): boolean
public "containsAny"(...itemLikes: ($ItemLike$Type)[]): boolean
public static "of"(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SingleItemMatch$Type = ($SingleItemMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SingleItemMatch_ = $SingleItemMatch$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$StageChangeEvent" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"

export class $StageChangeEvent {


public "getPlayerStages"(): $Stages
public "getPlayer"(): $Player
public "getStage"(): string
get "playerStages"(): $Stages
get "player"(): $Player
get "stage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageChangeEvent$Type = ($StageChangeEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StageChangeEvent_ = $StageChangeEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockItemBuilder" {
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BlockItemBuilder extends $ItemBuilder {
 "blockBuilder": $BlockBuilder
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "getTranslationKeyGroup"(): string
get "translationKeyGroup"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockItemBuilder$Type = ($BlockItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockItemBuilder_ = $BlockItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$KMath" {
import {$Vector4f, $Vector4f$Type} from "packages/org/joml/$Vector4f"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"
import {$Vector3d, $Vector3d$Type} from "packages/org/joml/$Vector3d"
import {$Matrix3f, $Matrix3f$Type} from "packages/org/joml/$Matrix3f"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $KMath {
static readonly "E": double
static readonly "PI": double
static readonly "DEGREES_TO_RADIANS": double
static readonly "RADIANS_TO_DEGREES": double

constructor()

public static "floor"(value: double): long
public static "ceil"(value: double): long
public static "map"(value: double, min0: double, max0: double, min1: double, max1: double): double
public static "v3"(x: double, y: double, z: double): $Vec3
public static "block"(x: double, y: double, z: double): $BlockPos
public static "deg"(value: double): double
public static "quaternion"(x: float, y: float, z: float, w: float): $Quaternionf
public static "clamp"(value: double, min: double, max: double): double
public static "v4f"(x: float, y: float, z: float, w: float): $Vector4f
public static "v3f"(x: float, y: float, z: float): $Vector3f
public static "v3d"(x: double, y: double, z: double): $Vector3d
public static "m4f"(): $Matrix4f
public static "clampedLerp"(value: double, min: double, max: double): double
public static "degreesDifference"(current: double, target: double): double
public static "rotateIfNecessary"(current: double, target: double, max: double): double
public static "wrapDegrees"(d: double): double
public static "m3f"(): $Matrix3f
public static "isPowerOfTwo"(value: integer): boolean
public static "rad"(value: double): double
public static "approachDegrees"(current: double, target: double, speed: double): double
public static "approach"(current: double, target: double, speed: double): double
public static "lerp"(value: double, min: double, max: double): double
public static "poseStack"(): $PoseStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KMath$Type = ($KMath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KMath_ = $KMath$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$TagWrapperStages" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"

export class $TagWrapperStages extends $Stages {
readonly "player": $Player

constructor(player: $Player$Type)

public "getAll"(): $Collection<(string)>
public "addNoUpdate"(stage: string): boolean
public "removeNoUpdate"(stage: string): boolean
get "all"(): $Collection<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapperStages$Type = ($TagWrapperStages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagWrapperStages_ = $TagWrapperStages$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$LazyComponentKJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $LazyComponentKJS extends $Supplier<($Component)> {

 "get"(): $Component

(): $Component
}

export namespace $LazyComponentKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyComponentKJS$Type = ($LazyComponentKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyComponentKJS_ = $LazyComponentKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$CreativeTabContentSupplier, $CreativeTabContentSupplier$Type} from "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabContentSupplier"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CreativeTabIconSupplier, $CreativeTabIconSupplier$Type} from "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabIconSupplier"

export class $CreativeTabBuilder extends $BuilderBase<($CreativeModeTab)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "content"(content: $CreativeTabContentSupplier$Type): $CreativeTabBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
public "icon"(icon: $CreativeTabIconSupplier$Type): $CreativeTabBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabBuilder$Type = ($CreativeTabBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabBuilder_ = $CreativeTabBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaMap" {
import {$ValueUnwrapper, $ValueUnwrapper$Type} from "packages/dev/latvian/mods/rhino/util/$ValueUnwrapper"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NativeJavaObject, $NativeJavaObject$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NativeJavaMap extends $NativeJavaObject {

constructor(cx: $Context$Type, scope: $Scriptable$Type, jo: any, map: $Map$Type<(any), (any)>, mapValueType: $Class$Type<(any)>, valueUnwrapper: $ValueUnwrapper$Type)
constructor(cx: $Context$Type, scope: $Scriptable$Type, jo: any, map: $Map$Type<(any), (any)>)

public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, name: string): void
public "delete"(cx: $Context$Type, index: integer): void
public "getClassName"(): string
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, name: string, start: $Scriptable$Type): boolean
public "getIds"(cx: $Context$Type): (any)[]
public static "unwrapped"(o: any): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaMap$Type = ($NativeJavaMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaMap_ = $NativeJavaMap$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$VariableDeclaration" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$VariableInitializer, $VariableInitializer$Type} from "packages/dev/latvian/mods/rhino/ast/$VariableInitializer"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $VariableDeclaration extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setType"(type: integer): $Node
public "getVariables"(): $List<($VariableInitializer)>
public "setVariables"(variables: $List$Type<($VariableInitializer$Type)>): void
public "addVariable"(v: $VariableInitializer$Type): void
public "setIsStatement"(isStatement: boolean): void
public "isStatement"(): boolean
public "isLet"(): boolean
public "isConst"(): boolean
public "isVar"(): boolean
set "type"(value: integer)
get "variables"(): $List<($VariableInitializer)>
set "variables"(value: $List$Type<($VariableInitializer$Type)>)
get "statement"(): boolean
get "let"(): boolean
get "const"(): boolean
get "var"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableDeclaration$Type = ($VariableDeclaration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableDeclaration_ = $VariableDeclaration$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$ScheduledServerEvent" {
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export class $ScheduledServerEvent extends $ScheduledEvents$ScheduledEvent {
readonly "server": $MinecraftServer
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "ofTicks": boolean
 "repeating": boolean
 "timer": long
 "endTime": long

constructor(server: $MinecraftServer$Type)

public static "make"(server: $MinecraftServer$Type): $ScheduledEvents
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledServerEvent$Type = ($ScheduledServerEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledServerEvent_ = $ScheduledServerEvent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$FunctionObject" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Member, $Member$Type} from "packages/java/lang/reflect/$Member"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $FunctionObject extends $BaseFunction {
static readonly "JAVA_UNSUPPORTED_TYPE": integer
static readonly "JAVA_STRING_TYPE": integer
static readonly "JAVA_INT_TYPE": integer
static readonly "JAVA_BOOLEAN_TYPE": integer
static readonly "JAVA_DOUBLE_TYPE": integer
static readonly "JAVA_SCRIPTABLE_TYPE": integer
static readonly "JAVA_OBJECT_TYPE": integer
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(name: string, methodOrConstructor: $Member$Type, scope: $Scriptable$Type, cx: $Context$Type)

public "getLength"(): integer
public "createObject"(cx: $Context$Type, scope: $Scriptable$Type): $Scriptable
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public static "getTypeTag"(type: $Class$Type<(any)>): integer
public static "convertArg"(cx: $Context$Type, scope: $Scriptable$Type, arg: any, typeTag: integer): any
public "addAsConstructor"(scope: $Scriptable$Type, prototype: $Scriptable$Type, cx: $Context$Type): void
public "getFunctionName"(): string
public "getArity"(): integer
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "functionName"(): string
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionObject$Type = ($FunctionObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionObject_ = $FunctionObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$RegExIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $RegExIngredient extends $KubeJSIngredient {
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($RegExIngredient)>
readonly "pattern": $Pattern
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(json: $JsonObject$Type)
constructor(buf: $FriendlyByteBuf$Type)
constructor(pattern: $Pattern$Type)

public "test"(stack: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getSerializer"(): $IIngredientSerializer<(any)>
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegExIngredient$Type = ($RegExIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegExIngredient_ = $RegExIngredient$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$ItemComponents" {
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $ItemComponents {

}

export namespace $ItemComponents {
const INPUT: $RecipeComponent<($InputItem)>
const INPUT_ARRAY: $RecipeComponent<(($InputItem)[])>
const UNWRAPPED_INPUT_ARRAY: $RecipeComponent<(($InputItem)[])>
const OUTPUT: $RecipeComponent<($OutputItem)>
const OUTPUT_ARRAY: $RecipeComponent<(($OutputItem)[])>
const OUTPUT_ID_WITH_COUNT: $RecipeComponent<($OutputItem)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemComponents$Type = ($ItemComponents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemComponents_ = $ItemComponents$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ObjToIntMap" {
import {$ObjToIntMap$Iterator, $ObjToIntMap$Iterator$Type} from "packages/dev/latvian/mods/rhino/$ObjToIntMap$Iterator"

export class $ObjToIntMap {

constructor(keyCountHint: integer)
constructor()

public "remove"(key: any): void
public "get"(key: any, defaultValue: integer): integer
public "put"(key: any, value: integer): void
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "intern"(keyArg: any): any
public "getKeys"(): (any)[]
public "getKeys"(array: (any)[], offset: integer): void
public "has"(key: any): boolean
public "getExisting"(key: any): integer
public "newIterator"(): $ObjToIntMap$Iterator
get "empty"(): boolean
get "keys"(): (any)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjToIntMap$Type = ($ObjToIntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjToIntMap_ = $ObjToIntMap$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$BoundFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $BoundFunction extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type, scope: $Scriptable$Type, targetFunction: $Callable$Type, boundThis: $Scriptable$Type, boundArgs: (any)[])

public "getLength"(): integer
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, extraArgs: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, extraArgs: (any)[]): $Scriptable
public "hasInstance"(cx: $Context$Type, instance: $Scriptable$Type): boolean
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoundFunction$Type = ($BoundFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoundFunction_ = $BoundFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemTintFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ItemTintFunction {

 "getColor"(arg0: $ItemStack$Type, arg1: integer): $Color

(cx: $Context$Type, o: any): $ItemTintFunction
}

export namespace $ItemTintFunction {
const BLOCK: $ItemTintFunction
const POTION: $ItemTintFunction
const MAP: $ItemTintFunction
const DISPLAY_COLOR_NBT: $ItemTintFunction
function of(cx: $Context$Type, o: any): $ItemTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTintFunction$Type = (($ItemTintFunction$Type)[]) | (string) | ((stack: $ItemStack, index: integer) => void) | ($ItemTintFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTintFunction_ = $ItemTintFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$FunctionCall" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"

export class $FunctionCall extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getTarget"(): $AstNode
public "setTarget"(target: $AstNode$Type): void
public "getArguments"(): $List<($AstNode)>
public "setParens"(lp: integer, rp: integer): void
public "addArgument"(arg: $AstNode$Type): void
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "setArguments"(arg0: $List$Type<($AstNode$Type)>): void
get "target"(): $AstNode
set "target"(value: $AstNode$Type)
get "arguments"(): $List<($AstNode)>
set "lp"(value: integer)
set "rp"(value: integer)
get "lp"(): integer
get "rp"(): integer
set "arguments"(value: $List$Type<($AstNode$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionCall$Type = ($FunctionCall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionCall_ = $FunctionCall$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$CustomPredicateIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $CustomPredicateIngredient extends $KubeJSIngredient {
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($CustomPredicateIngredient)>
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(parent: $Ingredient$Type, uuid: $UUID$Type)

public "test"(target: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getStackingIds"(): $IntList
public "getSerializer"(): $IIngredientSerializer<($CustomPredicateIngredient)>
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "stackingIds"(): $IntList
get "serializer"(): $IIngredientSerializer<($CustomPredicateIngredient)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomPredicateIngredient$Type = ($CustomPredicateIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomPredicateIngredient_ = $CustomPredicateIngredient$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$SlotMapContainer" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ScriptableObject$Slot, $ScriptableObject$Slot$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$Slot"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SlotMap, $SlotMap$Type} from "packages/dev/latvian/mods/rhino/$SlotMap"
import {$ScriptableObject$SlotAccess, $ScriptableObject$SlotAccess$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$SlotAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $SlotMapContainer implements $SlotMap {


public "remove"(key: any, index: integer, cx: $Context$Type): void
public "get"(key: any, index: integer, accessType: $ScriptableObject$SlotAccess$Type): $ScriptableObject$Slot
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $Iterator<($ScriptableObject$Slot)>
public "query"(key: any, index: integer): $ScriptableObject$Slot
public "readLock"(): long
public "dirtySize"(): integer
public "unlockRead"(stamp: long): void
public "addSlot"(newSlot: $ScriptableObject$Slot$Type): void
public "spliterator"(): $Spliterator<($ScriptableObject$Slot)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ScriptableObject$Slot>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotMapContainer$Type = ($SlotMapContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotMapContainer_ = $SlotMapContainer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/command/$ArgumentTypeWrappers" {
import {$ClassWrapper, $ClassWrapper$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassWrapper"
import {$ArgumentTypeWrapper, $ArgumentTypeWrapper$Type} from "packages/dev/latvian/mods/kubejs/command/$ArgumentTypeWrapper"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$CommandRegistryEventJS, $CommandRegistryEventJS$Type} from "packages/dev/latvian/mods/kubejs/command/$CommandRegistryEventJS"
import {$ArgumentType, $ArgumentType$Type} from "packages/com/mojang/brigadier/arguments/$ArgumentType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"

export class $ArgumentTypeWrappers extends $Enum<($ArgumentTypeWrappers)> implements $ArgumentTypeWrapper {
static readonly "BOOLEAN": $ArgumentTypeWrappers
static readonly "FLOAT": $ArgumentTypeWrappers
static readonly "DOUBLE": $ArgumentTypeWrappers
static readonly "INTEGER": $ArgumentTypeWrappers
static readonly "LONG": $ArgumentTypeWrappers
static readonly "STRING": $ArgumentTypeWrappers
static readonly "GREEDY_STRING": $ArgumentTypeWrappers
static readonly "WORD": $ArgumentTypeWrappers
static readonly "ENTITY": $ArgumentTypeWrappers
static readonly "ENTITIES": $ArgumentTypeWrappers
static readonly "PLAYER": $ArgumentTypeWrappers
static readonly "PLAYERS": $ArgumentTypeWrappers
static readonly "GAME_PROFILE": $ArgumentTypeWrappers
static readonly "BLOCK_POS": $ArgumentTypeWrappers
static readonly "BLOCK_POS_LOADED": $ArgumentTypeWrappers
static readonly "COLUMN_POS": $ArgumentTypeWrappers
static readonly "VEC3": $ArgumentTypeWrappers
static readonly "VEC2": $ArgumentTypeWrappers
static readonly "VEC3_CENTERED": $ArgumentTypeWrappers
static readonly "VEC2_CENTERED": $ArgumentTypeWrappers
static readonly "BLOCK_STATE": $ArgumentTypeWrappers
static readonly "BLOCK_PREDICATE": $ArgumentTypeWrappers
static readonly "ITEM_STACK": $ArgumentTypeWrappers
static readonly "ITEM_PREDICATE": $ArgumentTypeWrappers
static readonly "COLOR": $ArgumentTypeWrappers
static readonly "COMPONENT": $ArgumentTypeWrappers
static readonly "MESSAGE": $ArgumentTypeWrappers
static readonly "NBT_COMPOUND": $ArgumentTypeWrappers
static readonly "NBT_TAG": $ArgumentTypeWrappers
static readonly "NBT_PATH": $ArgumentTypeWrappers
static readonly "PARTICLE": $ArgumentTypeWrappers
static readonly "ANGLE": $ArgumentTypeWrappers
static readonly "ROTATION": $ArgumentTypeWrappers
static readonly "SWIZZLE": $ArgumentTypeWrappers
static readonly "ITEM_SLOT": $ArgumentTypeWrappers
static readonly "RESOURCE_LOCATION": $ArgumentTypeWrappers
static readonly "ENTITY_ANCHOR": $ArgumentTypeWrappers
static readonly "INT_RANGE": $ArgumentTypeWrappers
static readonly "FLOAT_RANGE": $ArgumentTypeWrappers
static readonly "DIMENSION": $ArgumentTypeWrappers
static readonly "TIME": $ArgumentTypeWrappers
static readonly "UUID": $ArgumentTypeWrappers
static readonly "OBJECTIVE": $ArgumentTypeWrappers


public static "values"(): ($ArgumentTypeWrappers)[]
public static "valueOf"(name: string): $ArgumentTypeWrappers
public "create"(event: $CommandRegistryEventJS$Type): $ArgumentType<(any)>
public "time"(minRequired: integer): $ArgumentTypeWrapper
public "getResult"(context: $CommandContext$Type<($CommandSourceStack$Type)>, input: string): any
public static "printAll"(): void
public static "registry"<T>(event: $CommandRegistryEventJS$Type, reg: $ResourceLocation$Type): $ArgumentTypeWrapper
public static "byName"(name: $ResourceLocation$Type): $ClassWrapper<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArgumentTypeWrappers$Type = (("swizzle") | ("nbt_path") | ("string") | ("color") | ("item_slot") | ("integer") | ("float") | ("uuid") | ("long") | ("resource_location") | ("objective") | ("block_pos_loaded") | ("block_predicate") | ("game_profile") | ("angle") | ("particle") | ("int_range") | ("dimension") | ("nbt_compound") | ("player") | ("double") | ("greedy_string") | ("players") | ("float_range") | ("block_pos") | ("rotation") | ("vec3") | ("vec2") | ("message") | ("nbt_tag") | ("column_pos") | ("vec2_centered") | ("vec3_centered") | ("component") | ("boolean") | ("entities") | ("block_state") | ("item_stack") | ("entity_anchor") | ("time") | ("word") | ("entity") | ("item_predicate")) | ($ArgumentTypeWrappers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArgumentTypeWrappers_ = $ArgumentTypeWrappers$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ClassFileWriter$MHandle" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClassFileWriter$MHandle {

constructor(tag: byte, owner: string, name: string, desc: string)

public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFileWriter$MHandle$Type = ($ClassFileWriter$MHandle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFileWriter$MHandle_ = $ClassFileWriter$MHandle$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$WrappedJS, $WrappedJS$Type} from "packages/dev/latvian/mods/kubejs/util/$WrappedJS"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$OutputFluid, $OutputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$OutputFluid"
import {$FluidLike, $FluidLike$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidLike"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer$Replacement, $OutputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $FluidStackJS implements $WrappedJS, $InputFluid, $OutputFluid {

constructor()

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "matches"(other: $FluidLike$Type): boolean
public static "of"(o: any, amount: long, nbt: $CompoundTag$Type): $FluidStackJS
public static "of"(o: any): $FluidStackJS
public "getId"(): string
public "copy"(): $FluidStackJS
public "withAmount"(amount: long): $FluidStackJS
public "strongEquals"(o: any): boolean
public "removeChance"(): void
public "withNBT"(nbt: $CompoundTag$Type): $FluidStackJS
public static "fromJson"(e: $JsonElement$Type): $FluidStackJS
public "toJson"(): $JsonObject
public "setAmount"(arg0: long): void
public "copy"(arg0: long): $FluidStackJS
public "hasChance"(): boolean
public "withChance"(c: double): $FluidStackJS
public "getAmount"(): long
public "setNbt"(arg0: $CompoundTag$Type): void
public "getNbt"(): $CompoundTag
public "hasTag"(tag: $ResourceLocation$Type): boolean
public "toNBT"(): $CompoundTag
public "getFluidStack"(): $FluidStack
public "getChance"(): double
public "getFluid"(): $Fluid
public "setChance"(c: double): void
public "getTags"(): $Collection<($ResourceLocation)>
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
public "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
public "isEmpty"(): boolean
public "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
public "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement
get "id"(): string
set "amount"(value: long)
get "amount"(): long
set "nbt"(value: $CompoundTag$Type)
get "nbt"(): $CompoundTag
get "fluidStack"(): $FluidStack
get "chance"(): double
get "fluid"(): $Fluid
set "chance"(value: double)
get "tags"(): $Collection<($ResourceLocation)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FluidStackJS$Type = ($Fluid$Type) | ("-") | ({"amount"?: integer, "fluid": Special.Fluid, "nbt"?: object}) | ($FluidStackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FluidStackJS_ = $FluidStackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$BasicCropBlockJS" {
import {$IntegerProperty, $IntegerProperty$Type} from "packages/net/minecraft/world/level/block/state/properties/$IntegerProperty"
import {$CropBlockBuilder, $CropBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$CropBlockBuilder"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$PlantType, $PlantType$Type} from "packages/net/minecraftforge/common/$PlantType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$LevelReader, $LevelReader$Type} from "packages/net/minecraft/world/level/$LevelReader"
import {$CropBlock, $CropBlock$Type} from "packages/net/minecraft/world/level/block/$CropBlock"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$IPlantable, $IPlantable$Type} from "packages/net/minecraftforge/common/$IPlantable"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BasicCropBlockJS extends $CropBlock implements $IPlantable {
static readonly "MAX_AGE": integer
static readonly "AGE": $IntegerProperty
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(builder: $CropBlockBuilder$Type)

public "getPlant"(world: $BlockGetter$Type, pos: $BlockPos$Type): $BlockState
public "getPlantType"(level: $BlockGetter$Type, pos: $BlockPos$Type): $PlantType
public "canSurvive"(blockState: $BlockState$Type, levelReader: $LevelReader$Type, blockPos: $BlockPos$Type): boolean
public "randomTick"(blockState: $BlockState$Type, serverLevel: $ServerLevel$Type, blockPos: $BlockPos$Type, random: $RandomSource$Type): void
public "getShape"(blockState: $BlockState$Type, blockGetter: $BlockGetter$Type, blockPos: $BlockPos$Type, collisionContext: $CollisionContext$Type): $VoxelShape
public "getMaxAge"(): integer
public "growCrops"(level: $Level$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type): void
get "maxAge"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicCropBlockJS$Type = ($BasicCropBlockJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicCropBlockJS_ = $BasicCropBlockJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$CompilerState" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $CompilerState {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompilerState$Type = ($CompilerState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompilerState_ = $CompilerState$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/creativetab/$CreativeTabContentSupplier" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $CreativeTabContentSupplier {

 "getContent"(arg0: boolean): ($ItemStack)[]

(arg0: boolean): ($ItemStack)[]
}

export namespace $CreativeTabContentSupplier {
const DEFAULT: $CreativeTabContentSupplier
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabContentSupplier$Type = ($CreativeTabContentSupplier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabContentSupplier_ = $CreativeTabContentSupplier$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeExceptionJS" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$MutedError, $MutedError$Type} from "packages/dev/latvian/mods/kubejs/util/$MutedError"
import {$IllegalArgumentException, $IllegalArgumentException$Type} from "packages/java/lang/$IllegalArgumentException"

export class $RecipeExceptionJS extends $IllegalArgumentException implements $MutedError {
 "error": boolean

constructor(m: string)
constructor(m: string, cause: $Throwable$Type)

public "toString"(): string
public "error"(): $RecipeExceptionJS
public "isMuted"(): boolean
get "muted"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeExceptionJS$Type = ($RecipeExceptionJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeExceptionJS_ = $RecipeExceptionJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FunctionFactory" {
import {$FunctionFactory$Arg3, $FunctionFactory$Arg3$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg3"
import {$FunctionFactory$Arg2, $FunctionFactory$Arg2$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg2"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$FunctionFactory$FuncSupplier, $FunctionFactory$FuncSupplier$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$FuncSupplier"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory$Arg1, $FunctionFactory$Arg1$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg1"

export class $FunctionFactory extends $Record {

constructor(name: string, minArgs: integer, maxArgs: integer, supplier: $FunctionFactory$FuncSupplier$Type)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(name: string, args: integer, supplier: $FunctionFactory$FuncSupplier$Type): $FunctionFactory
public static "of"(name: string, minArgs: integer, maxArgs: integer, supplier: $FunctionFactory$FuncSupplier$Type): $FunctionFactory
public "create"(args: ($Unit$Type)[]): $Unit
public "supplier"(): $FunctionFactory$FuncSupplier
public static "of0"(name: string, supplier: $Supplier$Type<($Unit$Type)>): $FunctionFactory
public static "of3"(name: string, supplier: $FunctionFactory$Arg3$Type): $FunctionFactory
public "minArgs"(): integer
public "maxArgs"(): integer
public static "of1"(name: string, supplier: $FunctionFactory$Arg1$Type): $FunctionFactory
public static "of2"(name: string, supplier: $FunctionFactory$Arg2$Type): $FunctionFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionFactory$Type = ($FunctionFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionFactory_ = $FunctionFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RegistryComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegistryComponent<T> extends $Record implements $RecipeComponent<(T)> {
static readonly "DYNAMIC": $DynamicRecipeComponent

constructor(registry: $RegistryInfo$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: T): $JsonElement
public "read"(recipe: $RecipeJS$Type, from: any): T
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "registry"(): $RegistryInfo<(T)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(T)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
public "asArray"(): $ArrayRecipeComponent<(T)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(T)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
public "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
public "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
public "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryComponent$Type<T> = ($RegistryComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryComponent_<T> = $RegistryComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/unit/function/$ClampFuncUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Func3Unit, $Func3Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func3Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $ClampFuncUnit extends $Func3Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "c": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type, c: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public static "clamp"(a: double, b: double, c: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClampFuncUnit$Type = ($ClampFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClampFuncUnit_ = $ClampFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$InfixExpression" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $InfixExpression extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(operator: integer, left: $AstNode$Type, right: $AstNode$Type, operatorPos: integer)
constructor(left: $AstNode$Type, right: $AstNode$Type)
constructor(pos: integer, len: integer, left: $AstNode$Type, right: $AstNode$Type)
constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

public "setOperatorPosition"(operatorPosition: integer): void
public "getOperatorPosition"(): integer
public "getRight"(): $AstNode
public "getLeft"(): $AstNode
public "setLeft"(left: $AstNode$Type): void
public "setRight"(right: $AstNode$Type): void
public "getOperator"(): integer
public "hasSideEffects"(): boolean
public "setLeftAndRight"(left: $AstNode$Type, right: $AstNode$Type): void
public "setOperator"(operator: integer): void
set "operatorPosition"(value: integer)
get "operatorPosition"(): integer
get "right"(): $AstNode
get "left"(): $AstNode
set "left"(value: $AstNode$Type)
set "right"(value: $AstNode$Type)
get "operator"(): integer
set "operator"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InfixExpression$Type = ($InfixExpression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InfixExpression_ = $InfixExpression$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$DToA" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DToA {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DToA$Type = ($DToA);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DToA_ = $DToA$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$SpecialEquality" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $SpecialEquality {

 "specialEquals"(o: any, shallow: boolean): boolean
}

export namespace $SpecialEquality {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialEquality$Type = ($SpecialEquality);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialEquality_ = $SpecialEquality$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export interface $ReplacementMatch {

}

export namespace $ReplacementMatch {
const NONE: $ReplacementMatch
function of(o: any): $ReplacementMatch
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReplacementMatch$Type = ($Ingredient$Type) | ($ReplacementMatch);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReplacementMatch_ = $ReplacementMatch$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ModResourceBindings" {
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$Mod, $Mod$Type} from "packages/dev/architectury/platform/$Mod"

export class $ModResourceBindings {

constructor()

public "addBindings"(event: $BindingsEvent$Type): void
public "readBindings"(mod: $Mod$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModResourceBindings$Type = ($ModResourceBindings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModResourceBindings_ = $ModResourceBindings$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$CustomJavaToJsWrappersEvent" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CustomJavaToJsWrapperProvider, $CustomJavaToJsWrapperProvider$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapperProvider"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $CustomJavaToJsWrappersEvent {
readonly "manager": $ScriptManager

constructor(m: $ScriptManager$Type)

public "add"<T>(predicate: $Predicate$Type<(T)>, provider: $CustomJavaToJsWrapperProvider$Type<(T)>): void
public "add"<T>(type: $Class$Type<(T)>, provider: $CustomJavaToJsWrapperProvider$Type<(T)>): void
public "getScriptType"(): $ScriptType
get "scriptType"(): $ScriptType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJavaToJsWrappersEvent$Type = ($CustomJavaToJsWrappersEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJavaToJsWrappersEvent_ = $CustomJavaToJsWrappersEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $KubeJSIngredientSerializer<T extends $KubeJSIngredient> extends $Record implements $IIngredientSerializer<(T)> {

constructor(fromJson: $Function$Type<($JsonObject$Type), (T)>, fromNet: $Function$Type<($FriendlyByteBuf$Type), (T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "write"(buf: $FriendlyByteBuf$Type, ingredient: T): void
public "fromJson"(): $Function<($JsonObject), (T)>
public "fromNet"(): $Function<($FriendlyByteBuf), (T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSIngredientSerializer$Type<T> = ($KubeJSIngredientSerializer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSIngredientSerializer_<T> = $KubeJSIngredientSerializer$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$ChestEventJS" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InventoryEventJS, $InventoryEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$InventoryEventJS"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

/**
 * Invoked when a player opens a chest.
 * 
 * Same as `PlayerEvents.inventoryOpened`, but only for chests.
 */
export class $ChestEventJS extends $InventoryEventJS {

constructor(player: $Player$Type, menu: $AbstractContainerMenu$Type)

/**
 * Gets the chest block.
 */
public "getBlock"(): $BlockContainerJS
/**
 * Gets the chest inventory.
 */
public "getInventory"(): $Container
get "block"(): $BlockContainerJS
get "inventory"(): $Container
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestEventJS$Type = ($ChestEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestEventJS_ = $ChestEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$ConditionContainer" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ConditionContainer {

 "survivesExplosion"(): $ConditionContainer
 "addCondition"(arg0: $JsonObject$Type): $ConditionContainer
 "randomChance"(chance: double): $ConditionContainer
 "randomChanceWithLooting"(chance: double, multiplier: double): $ConditionContainer
 "entityScores"(entity: $LootContext$EntityTarget$Type, scores: $Map$Type<(string), (any)>): $ConditionContainer
 "entityProperties"(entity: $LootContext$EntityTarget$Type, properties: $JsonObject$Type): $ConditionContainer
 "killedByPlayer"(): $ConditionContainer

(): $ConditionContainer
}

export namespace $ConditionContainer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionContainer$Type = ($ConditionContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionContainer_ = $ConditionContainer$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$RectangleObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $RectangleObject extends $BoxObject {
 "color": $Unit
 "texture": $ResourceLocation
 "u0": $Unit
 "v0": $Unit
 "u1": $Unit
 "v1": $Unit
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RectangleObject$Type = ($RectangleObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RectangleObject_ = $RectangleObject$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$SubString" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SubString {

constructor(source: string, start: integer, len: integer)
constructor(str: string)
constructor()

public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubString$Type = ($SubString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubString_ = $SubString$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$IngredientSupplierKJS" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

export interface $IngredientSupplierKJS {

 "kjs$asIngredient"(): $Ingredient
}

export namespace $IngredientSupplierKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientSupplierKJS$Type = ($IngredientSupplierKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientSupplierKJS_ = $IngredientSupplierKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$CustomIngredientAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$CustomIngredientActionCallback, $CustomIngredientActionCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$CustomIngredientActionCallback"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CustomIngredientAction extends $IngredientAction {
static readonly "MAP": $Map<(string), ($CustomIngredientActionCallback)>
readonly "id": string
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor(i: string)

public "transform"(old: $ItemStack$Type, index: integer, container: $CraftingContainer$Type): $ItemStack
public "getType"(): string
public "toJson"(json: $JsonObject$Type): void
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomIngredientAction$Type = ($CustomIngredientAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomIngredientAction_ = $CustomIngredientAction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$CollectionTagWrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$CollectionTag, $CollectionTag$Type} from "packages/net/minecraft/nbt/$CollectionTag"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $CollectionTagWrapper extends $Record implements $CustomJavaToJsWrapper {

constructor(tag: $CollectionTag$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "tag"(): $CollectionTag<(any)>
public "convertJavaToJs"(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CollectionTagWrapper$Type = ($CollectionTagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CollectionTagWrapper_ = $CollectionTagWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents" {
import {$LinkedList, $LinkedList$Type} from "packages/java/util/$LinkedList"
import {$TemporalAmount, $TemporalAmount$Type} from "packages/java/time/temporal/$TemporalAmount"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ScheduledEvents$Callback, $ScheduledEvents$Callback$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$Callback"
import {$AtomicInteger, $AtomicInteger$Type} from "packages/java/util/concurrent/atomic/$AtomicInteger"
import {$ScheduledEvents$ScheduledEvent, $ScheduledEvents$ScheduledEvent$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent"

export class $ScheduledEvents {
readonly "factory": $Supplier<($ScheduledEvents$ScheduledEvent)>
readonly "events": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "futureEvents": $LinkedList<($ScheduledEvents$ScheduledEvent)>
readonly "nextId": $AtomicInteger
 "currentMillis": long
 "currentTick": long

constructor(factory: $Supplier$Type<($ScheduledEvents$ScheduledEvent$Type)>)

public "clear"(id: integer): void
public "tickAll"(nowTicks: long): void
public "schedule"(timer: $TemporalAmount$Type, repeating: boolean, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
public "schedule"(timer: long, ofTicks: boolean, repeating: boolean, callback: $ScheduledEvents$Callback$Type): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$Type = ($ScheduledEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents_ = $ScheduledEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$PaintEventJS" {
import {$Tesselator, $Tesselator$Type} from "packages/com/mojang/blaze3d/vertex/$Tesselator"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$Matrix4f, $Matrix4f$Type} from "packages/org/joml/$Matrix4f"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$VertexFormat, $VertexFormat$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat"
import {$VertexFormat$Mode, $VertexFormat$Mode$Type} from "packages/com/mojang/blaze3d/vertex/$VertexFormat$Mode"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$ShaderInstance, $ShaderInstance$Type} from "packages/net/minecraft/client/renderer/$ShaderInstance"
import {$BufferBuilder, $BufferBuilder$Type} from "packages/com/mojang/blaze3d/vertex/$BufferBuilder"
import {$ClientEventJS, $ClientEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$ClientEventJS"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $PaintEventJS extends $ClientEventJS {
readonly "mc": $Minecraft
readonly "font": $Font
readonly "graphics": $GuiGraphics
readonly "matrices": $PoseStack
readonly "tesselator": $Tesselator
readonly "buffer": $BufferBuilder
readonly "delta": float
readonly "screen": $Screen

constructor(m: $Minecraft$Type, g: $GuiGraphics$Type, d: float, s: $Screen$Type)

public "blend"(enabled: boolean): void
public "scale"(x: float, y: float, z: float): void
public "end"(): void
public "begin"(type: $VertexFormat$Mode$Type, format: $VertexFormat$Type): void
public "multiply"(q: $Quaternionf$Type): void
public "push"(): void
public "pop"(): void
public "setShaderTexture"(tex: $ResourceLocation$Type): void
public "resetShaderColor"(): void
public "translate"(x: double, y: double, z: double): void
public "multiplyWithMatrix"(m: $Matrix4f$Type): void
public "beginQuads"(format: $VertexFormat$Type): void
public "beginQuads"(texture: boolean): void
public "setShaderColor"(r: float, g: float, b: float, a: float): void
public "setPositionColorShader"(): void
public "setPositionColorTextureShader"(): void
public "getMatrix"(): $Matrix4f
public "vertex"(m: $Matrix4f$Type, x: float, y: float, z: float, col: integer): void
public "vertex"(m: $Matrix4f$Type, x: float, y: float, z: float, col: integer, u: float, v: float): void
public "bindTextureForSetup"(tex: $ResourceLocation$Type): void
public "setShaderInstance"(shader: $Supplier$Type<($ShaderInstance$Type)>): void
set "shaderTexture"(value: $ResourceLocation$Type)
get "matrix"(): $Matrix4f
set "shaderInstance"(value: $Supplier$Type<($ShaderInstance$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintEventJS$Type = ($PaintEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintEventJS_ = $PaintEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$SlotMap" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ScriptableObject$Slot, $ScriptableObject$Slot$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$Slot"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ScriptableObject$SlotAccess, $ScriptableObject$SlotAccess$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$SlotAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $SlotMap extends $Iterable<($ScriptableObject$Slot)> {

 "remove"(arg0: any, arg1: integer, arg2: $Context$Type): void
 "get"(arg0: any, arg1: integer, arg2: $ScriptableObject$SlotAccess$Type): $ScriptableObject$Slot
 "isEmpty"(): boolean
 "size"(): integer
 "query"(arg0: any, arg1: integer): $ScriptableObject$Slot
 "addSlot"(arg0: $ScriptableObject$Slot$Type): void
 "iterator"(): $Iterator<($ScriptableObject$Slot)>
 "spliterator"(): $Spliterator<($ScriptableObject$Slot)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $SlotMap {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SlotMap$Type = ($SlotMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SlotMap_ = $SlotMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$ItemWrapper" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FireworksJS, $FireworksJS$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * Various item related helper methods
 */
export interface $ItemWrapper {

}

export namespace $ItemWrapper {
const KJS_BASE_ATTACK_DAMAGE_UUID: $UUID
const KJS_BASE_ATTACK_SPEED_UUID: $UUID
const KJS_ARMOR_MODIFIER_UUID_PER_SLOT: ($UUID)[]
function of(arg0: $ItemStack$Type): $ItemStack
function of(arg0: $ItemStack$Type, count: integer, nbt: $CompoundTag$Type): $ItemStack
function of(arg0: $ItemStack$Type, count: integer): $ItemStack
function of(arg0: $ItemStack$Type, tag: $CompoundTag$Type): $ItemStack
function getId(item: $Item$Type): $ResourceLocation
function exists(id: $ResourceLocation$Type): boolean
function getVariants(item: $ItemStack$Type): $Collection<($ItemStack)>
function getItem(id: $ResourceLocation$Type): $Item
function getList(): $List<($ItemStack)>
function withNBT(arg0: $ItemStack$Type, nbt: $CompoundTag$Type): $ItemStack
function playerHeadFromSkinHash(hash: string): $ItemStack
function fireworks(properties: $Map$Type<(string), (any)>): $FireworksJS
function isItem(o: any): boolean
function getEmpty(): $ItemStack
function getTypeToStackMap(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
function playerHeadFromUrl(url: string): $ItemStack
function playerHead(uuid: $UUID$Type, textureBase64: string): $ItemStack
function playerHead(name: string): $ItemStack
function getTypeList(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemWrapper$Type = ($ItemWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemWrapper_ = $ItemWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$TagWrapper" {
import {$TagEventJS, $TagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagEventJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$Type} from "packages/net/minecraft/tags/$TagLoader$EntryWithSource"

export class $TagWrapper {
readonly "event": $TagEventJS
readonly "id": $ResourceLocation
readonly "entries": $List<($TagLoader$EntryWithSource)>

constructor(e: $TagEventJS$Type, i: $ResourceLocation$Type, t: $List$Type<($TagLoader$EntryWithSource$Type)>)

public "add"(...filters: (any)[]): $TagWrapper
public "remove"(...filters: (any)[]): $TagWrapper
public "toString"(): string
public "removeAll"(): $TagWrapper
public "getObjectIds"(): $List<($ResourceLocation)>
get "objectIds"(): $List<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagWrapper$Type = ($TagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagWrapper_ = $TagWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$SmithingTransformRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $SmithingTransformRecipeSchema {

}

export namespace $SmithingTransformRecipeSchema {
const RESULT: $RecipeKey<($OutputItem)>
const TEMPLATE: $RecipeKey<($InputItem)>
const BASE: $RecipeKey<($InputItem)>
const ADDITION: $RecipeKey<($InputItem)>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmithingTransformRecipeSchema$Type = ($SmithingTransformRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmithingTransformRecipeSchema_ = $SmithingTransformRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$DoLoop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Loop, $Loop$Type} from "packages/dev/latvian/mods/rhino/ast/$Loop"

export class $DoLoop extends $Loop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setCondition"(condition: $AstNode$Type): void
public "setWhilePosition"(whilePosition: integer): void
public "getWhilePosition"(): integer
public "getCondition"(): $AstNode
set "condition"(value: $AstNode$Type)
set "whilePosition"(value: integer)
get "whilePosition"(): integer
get "condition"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoLoop$Type = ($DoLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoLoop_ = $DoLoop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$PickaxeItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HandheldItemBuilder, $HandheldItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PickaxeItemBuilder extends $HandheldItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PickaxeItemBuilder$Type = ($PickaxeItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PickaxeItemBuilder_ = $PickaxeItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$MutableBoolean" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MutableBoolean {
 "value": boolean

constructor(value: boolean)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableBoolean$Type = ($MutableBoolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableBoolean_ = $MutableBoolean$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Func1Unit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"

export class $Func1Unit extends $FuncUnit {
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(factory: $FunctionFactory$Type, a: $Unit$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Func1Unit$Type = ($Func1Unit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Func1Unit_ = $Func1Unit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$WildcardIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $WildcardIngredient extends $KubeJSIngredient {
static "INSTANCE": $WildcardIngredient
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($WildcardIngredient)>
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList


public "test"(stack: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getSerializer"(): $IIngredientSerializer<(any)>
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WildcardIngredient$Type = ($WildcardIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WildcardIngredient_ = $WildcardIngredient$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$NamedSignature" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$MojangMappings$MethodDefSignature, $MojangMappings$MethodDefSignature$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MethodDefSignature"

export class $MojangMappings$NamedSignature extends $Record {

constructor(name: string, signature: $MojangMappings$MethodDefSignature$Type)

public "signature"(): $MojangMappings$MethodDefSignature
public "name"(): string
public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$NamedSignature$Type = ($MojangMappings$NamedSignature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings$NamedSignature_ = $MojangMappings$NamedSignature$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Kit" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$Reader, $Reader$Type} from "packages/java/io/$Reader"

export class $Kit {

constructor()

public static "readStream"(is: $InputStream$Type, initialBufferCapacity: integer): (byte)[]
public static "removeListener"(bag: any, listener: any): any
public static "readReader"(reader: $Reader$Type): string
public static "makeHashKeyFromPair"(key1: any, key2: any): any
public static "codeBug"(msg: string): $RuntimeException
public static "codeBug"(): $RuntimeException
public static "getListener"(bag: any, index: integer): any
public static "addListener"(bag: any, listener: any): any
public static "xDigitToInt"(c: integer, accumulator: integer): integer
public static "classOrNull"(className: string): $Class<(any)>
public static "classOrNull"(loader: $ClassLoader$Type, className: string): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Kit$Type = ($Kit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Kit_ = $Kit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Hashtable$Entry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Hashtable$Entry {


public "value"(): any
public "equals"(o: any): boolean
public "hashCode"(): integer
public "key"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hashtable$Entry$Type = ($Hashtable$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hashtable$Entry_ = $Hashtable$Entry$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$DetectorBlock" {
import {$DetectorBlock$Builder, $DetectorBlock$Builder$Type} from "packages/dev/latvian/mods/kubejs/block/$DetectorBlock$Builder"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $DetectorBlock extends $Block {
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(b: $DetectorBlock$Builder$Type)

/**
 * 
 * @deprecated
 */
public "neighborChanged"(blockState: $BlockState$Type, level: $Level$Type, blockPos: $BlockPos$Type, block: $Block$Type, blockPos2: $BlockPos$Type, bl: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DetectorBlock$Type = ($DetectorBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DetectorBlock_ = $DetectorBlock$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$InventoryAttachment" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"
import {$SimpleContainer, $SimpleContainer$Type} from "packages/net/minecraft/world/$SimpleContainer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockEntityAttachmentType, $BlockEntityAttachmentType$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachmentType"
import {$BlockEntityAttachment, $BlockEntityAttachment$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $InventoryAttachment extends $SimpleContainer implements $BlockEntityAttachment {
static readonly "TYPE": $BlockEntityAttachmentType
readonly "width": integer
readonly "height": integer
readonly "blockEntity": $BlockEntityJS
readonly "inputFilter": $Ingredient

constructor(blockEntity: $BlockEntityJS$Type, width: integer, height: integer, inputFilter: $Ingredient$Type)

public "readAttachment"(tag: $CompoundTag$Type): void
public "writeAttachment"(): $CompoundTag
public "setChanged"(): void
public "stillValid"(player: $Player$Type): boolean
public "canPlaceItem"(i: integer, itemStack: $ItemStack$Type): boolean
public "getHeight"(): integer
public "getWidth"(): integer
public "canAddItem"(itemStack: $ItemStack$Type): boolean
public "onRemove"(newState: $BlockState$Type): void
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type, arg2: integer): boolean
public static "stillValidBlockEntity"(arg0: $BlockEntity$Type, arg1: $Player$Type): boolean
public static "tryClear"(arg0: any): void
get "height"(): integer
get "width"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryAttachment$Type = ($InventoryAttachment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryAttachment_ = $InventoryAttachment$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaConstructor" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$MemberBox, $MemberBox$Type} from "packages/dev/latvian/mods/rhino/$MemberBox"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeJavaConstructor extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(ctor: $MemberBox$Type)

public "toString"(): string
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getFunctionName"(): string
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "functionName"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaConstructor$Type = ($NativeJavaConstructor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaConstructor_ = $NativeJavaConstructor$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$REGlobalData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $REGlobalData {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $REGlobalData$Type = ($REGlobalData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $REGlobalData_ = $REGlobalData$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$WithAlphaFuncUnit" {
import {$Func2Unit, $Func2Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func2Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $WithAlphaFuncUnit extends $Func2Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAlphaFuncUnit$Type = ($WithAlphaFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithAlphaFuncUnit_ = $WithAlphaFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactoryRegistryEvent" {
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeComponentFactory, $RecipeComponentFactory$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeComponentFactory"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeComponentFactoryRegistryEvent {

constructor(map: $Map$Type<(string), ($RecipeComponentFactory$Type)>)

public "register"(name: string, component: $RecipeComponent$Type<(any)>): void
public "registerDynamic"(name: string, component: $DynamicRecipeComponent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentFactoryRegistryEvent$Type = ($RecipeComponentFactoryRegistryEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentFactoryRegistryEvent_ = $RecipeComponentFactoryRegistryEvent$Type;
}}
declare module "packages/dev/latvian/mods/unit/$TernaryUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $TernaryUnit extends $Unit {
readonly "cond": $Unit
readonly "left": $Unit
readonly "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(cond: $Unit$Type, left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TernaryUnit$Type = ($TernaryUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TernaryUnit_ = $TernaryUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $CustomJavaToJsWrapper {

 "convertJavaToJs"(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Class$Type<(any)>): $Scriptable

(arg0: $Context$Type, arg1: $Scriptable$Type, arg2: $Class$Type<(any)>): $Scriptable
}

export namespace $CustomJavaToJsWrapper {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJavaToJsWrapper$Type = ($CustomJavaToJsWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJavaToJsWrapper_ = $CustomJavaToJsWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$NoStages" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"

export class $NoStages extends $Stages {
static readonly "NULL_INSTANCE": $NoStages
readonly "player": $Player


public "clear"(): boolean
public "replace"(stages: $Collection$Type<(string)>): void
public "sync"(): void
public "getAll"(): $Collection<(string)>
public "has"(stage: string): boolean
public "addNoUpdate"(stage: string): boolean
public "removeNoUpdate"(stage: string): boolean
get "all"(): $Collection<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoStages$Type = ($NoStages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoStages_ = $NoStages$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ArrayLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$DestructuringForm, $DestructuringForm$Type} from "packages/dev/latvian/mods/rhino/ast/$DestructuringForm"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ArrayLiteral extends $AstNode implements $DestructuringForm {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getSize"(): integer
public "getElement"(index: integer): $AstNode
public "addElement"(element: $AstNode$Type): void
public "getElements"(): $List<($AstNode)>
public "getDestructuringLength"(): integer
public "setDestructuringLength"(destructuringLength: integer): void
public "setSkipCount"(count: integer): void
public "setIsDestructuring"(destructuring: boolean): void
public "getSkipCount"(): integer
public "isDestructuring"(): boolean
public "setElements"(elements: $List$Type<($AstNode$Type)>): void
get "size"(): integer
get "elements"(): $List<($AstNode)>
get "destructuringLength"(): integer
set "destructuringLength"(value: integer)
set "skipCount"(value: integer)
get "skipCount"(): integer
get "destructuring"(): boolean
set "elements"(value: $List$Type<($AstNode$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayLiteral$Type = ($ArrayLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayLiteral_ = $ArrayLiteral$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ItemFrameEntityKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EntityKJS, $EntityKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$EntityKJS"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export interface $ItemFrameEntityKJS extends $EntityKJS {

 "isFrame"(): boolean
 "getItem"(): $ItemStack
 "getProfile"(): $GameProfile
 "spawn"(): void
 "isPlayer"(): boolean
 "isLiving"(): boolean
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$Type): void
}

export namespace $ItemFrameEntityKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemFrameEntityKJS$Type = ($ItemFrameEntityKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemFrameEntityKJS_ = $ItemFrameEntityKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$RemapForJS" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $RemapForJS extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $RemapForJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemapForJS$Type = ($RemapForJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemapForJS_ = $RemapForJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RegisterRecipeSchemasEvent" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeNamespace, $RecipeNamespace$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RegisterRecipeSchemasEvent extends $Record {

constructor(namespaces: $Map$Type<(string), ($RecipeNamespace$Type)>, mappedRecipes: $Map$Type<(string), ($ResourceLocation$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "register"(id: $ResourceLocation$Type, schema: $RecipeSchema$Type): void
public "namespace"(namespace: string): $RecipeNamespace
public "namespaces"(): $Map<(string), ($RecipeNamespace)>
public "mappedRecipes"(): $Map<(string), ($ResourceLocation)>
public "mapRecipe"(name: string, type: string): void
public "mapRecipe"(name: string, type: $ResourceLocation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegisterRecipeSchemasEvent$Type = ($RegisterRecipeSchemasEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegisterRecipeSchemasEvent_ = $RegisterRecipeSchemasEvent$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$GlobData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GlobData {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobData$Type = ($GlobData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlobData_ = $GlobData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$HideCustomJEIEventJS" {
import {$IIngredientType, $IIngredientType$Type} from "packages/mezz/jei/api/ingredients/$IIngredientType"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$HideJEIEventJS, $HideJEIEventJS$Type} from "packages/dev/latvian/mods/kubejs/integration/forge/jei/$HideJEIEventJS"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"

export class $HideCustomJEIEventJS extends $EventJS {

constructor(r: $IJeiRuntime$Type)

public "get"(s: $IIngredientType$Type<(any)>): $HideJEIEventJS<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HideCustomJEIEventJS$Type = ($HideCustomJEIEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HideCustomJEIEventJS_ = $HideCustomJEIEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptableObject$Slot" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ScriptableObject$Slot {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptableObject$Slot$Type = ($ScriptableObject$Slot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptableObject$Slot_ = $ScriptableObject$Slot$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$FieldOrMethodRef" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $FieldOrMethodRef {


public "getName"(): string
public "equals"(obj: any): boolean
public "hashCode"(): integer
public "getType"(): string
public "getClassName"(): string
get "name"(): string
get "type"(): string
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldOrMethodRef$Type = ($FieldOrMethodRef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldOrMethodRef_ = $FieldOrMethodRef$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeOptional" {
import {$RecipeSchemaType, $RecipeSchemaType$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType"

export interface $RecipeOptional<T> {

 "isDefault"(): boolean
 "getDefaultValue"(arg0: $RecipeSchemaType$Type): T

(): boolean
}

export namespace $RecipeOptional {
const DEFAULT: $RecipeOptional<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeOptional$Type<T> = ($RecipeOptional<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeOptional_<T> = $RecipeOptional$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$TinyMap" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$TinyMap$Entry, $TinyMap$Entry$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap$Entry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TinyMap<K, V> extends $Record {

constructor(entries: ($TinyMap$Entry$Type<(K), (V)>)[])
constructor(map: $TinyMap$Type<(K), (V)>)
constructor(collection: $Collection$Type<($TinyMap$Entry$Type<(K), (V)>)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "entries"(): ($TinyMap$Entry<(K), (V)>)[]
public static "ofMap"<K, V>(map: $Map$Type<(K), (V)>): $TinyMap<(K), (V)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TinyMap$Type<K, V> = ($TinyMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TinyMap_<K, V> = $TinyMap$Type<(K), (V)>;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ModifiableItemKJS" {
import {$Multimap, $Multimap$Type} from "packages/com/google/common/collect/$Multimap"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"

export interface $ModifiableItemKJS {

 "kjs$getAttributeMap"(): $Multimap<($Attribute), ($AttributeModifier)>
 "kjs$getMutableAttributeMap"(): $Multimap<($Attribute), ($AttributeModifier)>
 "kjs$setAttributeMap"(attributes: $Multimap$Type<($Attribute$Type), ($AttributeModifier$Type)>): void
}

export namespace $ModifiableItemKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifiableItemKJS$Type = ($ModifiableItemKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifiableItemKJS_ = $ModifiableItemKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$FunctionNode" {
import {$Name, $Name$Type} from "packages/dev/latvian/mods/rhino/ast/$Name"
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FunctionNode extends $ScriptNode {
static readonly "FUNCTION_STATEMENT": integer
static readonly "FUNCTION_EXPRESSION": integer
static readonly "FUNCTION_EXPRESSION_STATEMENT": integer
static readonly "ARROW_FUNCTION": integer
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer, name: $Name$Type)
constructor(pos: integer)

public "getName"(): string
public "isMethod"(): boolean
public "isParam"(node: $AstNode$Type): boolean
public "getParams"(): $List<($AstNode)>
public "setParams"(params: $List$Type<($AstNode$Type)>): void
public "addFunction"(fnNode: $FunctionNode$Type): integer
public "getBody"(): $AstNode
public "isExpressionClosure"(): boolean
public "setRequiresActivation"(): void
public "setFunctionIsSetterMethod"(): void
public "setFunctionIsNormalMethod"(): void
public "setFunctionIsGetterMethod"(): void
public "setIsExpressionClosure"(isExpressionClosure: boolean): void
public "getResumptionPoints"(): $List<($Node)>
public "setParens"(lp: integer, rp: integer): void
public "setLp"(lp: integer): void
public "setMemberExprNode"(node: $AstNode$Type): void
public "setFunctionType"(type: integer): void
public "addParam"(param: $AstNode$Type): void
public "setRp"(rp: integer): void
public "setIsES6Generator"(): void
public "setIsGenerator"(): void
public "isES6Generator"(): boolean
public "getFunctionType"(): integer
public "getLp"(): integer
public "getRp"(): integer
public "addResumptionPoint"(target: $Node$Type): void
public "getMemberExprNode"(): $AstNode
public "isSetterMethod"(): boolean
public "isGetterMethod"(): boolean
public "isNormalMethod"(): boolean
public "requiresActivation"(): boolean
public "getLiveLocals"(): $Map<($Node), ((integer)[])>
public "addLiveLocals"(node: $Node$Type, locals: (integer)[]): void
public "isGenerator"(): boolean
public "getFunctionName"(): $Name
public "setFunctionName"(name: $Name$Type): void
public "setBody"(body: $AstNode$Type): void
get "name"(): string
get "method"(): boolean
get "params"(): $List<($AstNode)>
set "params"(value: $List$Type<($AstNode$Type)>)
get "body"(): $AstNode
get "expressionClosure"(): boolean
get "resumptionPoints"(): $List<($Node)>
set "lp"(value: integer)
set "memberExprNode"(value: $AstNode$Type)
set "functionType"(value: integer)
set "rp"(value: integer)
get "eS6Generator"(): boolean
get "functionType"(): integer
get "lp"(): integer
get "rp"(): integer
get "memberExprNode"(): $AstNode
get "setterMethod"(): boolean
get "getterMethod"(): boolean
get "normalMethod"(): boolean
get "liveLocals"(): $Map<($Node), ((integer)[])>
get "generator"(): boolean
get "functionName"(): $Name
set "functionName"(value: $Name$Type)
set "body"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionNode$Type = ($FunctionNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionNode_ = $FunctionNode$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Yield" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $Yield extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, value: $AstNode$Type, isStar: boolean)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getValue"(): $AstNode
public "setValue"(expr: $AstNode$Type): void
get "value"(): $AstNode
set "value"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Yield$Type = ($Yield);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Yield_ = $Yield$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$Object2LongEntry" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Object2LongMap$Entry, $Object2LongMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap$Entry"

export class $Object2LongEntry implements $Comparable<($Object2LongEntry)> {
readonly "key": any
readonly "value": long

constructor(k: any, v: long)
constructor(entry: $Object2LongMap$Entry$Type<(any)>)

public "compareTo"(o: $Object2LongEntry$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongEntry$Type = ($Object2LongEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongEntry_ = $Object2LongEntry$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/$IngredientPlatformHelper" {
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"

export interface $IngredientPlatformHelper {

 "regex"(arg0: $Pattern$Type): $Ingredient
 "stack"(ingredient: $Ingredient$Type, count: integer): $InputItem
 "mod"(arg0: string): $Ingredient
 "wildcard"(): $Ingredient
 "or"(arg0: ($Ingredient$Type)[]): $Ingredient
 "subtract"(arg0: $Ingredient$Type, arg1: $Ingredient$Type): $Ingredient
 "and"(arg0: ($Ingredient$Type)[]): $Ingredient
 "tag"(tag: string): $Ingredient
 "isWildcard"(arg0: $Ingredient$Type): boolean
 "creativeTab"(arg0: $CreativeModeTab$Type): $Ingredient
 "custom"(arg0: $Ingredient$Type, arg1: $UUID$Type): $Ingredient
 "custom"(arg0: $Ingredient$Type, arg1: $Predicate$Type<($ItemStack$Type)>): $Ingredient
 "strongNBT"(arg0: $ItemStack$Type): $Ingredient
 "weakNBT"(arg0: $ItemStack$Type): $Ingredient
}

export namespace $IngredientPlatformHelper {
const INSTANCE: $Lazy<($IngredientPlatformHelper)>
function get(): $IngredientPlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientPlatformHelper$Type = ($IngredientPlatformHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientPlatformHelper_ = $IngredientPlatformHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$ItemEvents" {
import {$Extra, $Extra$Type} from "packages/dev/latvian/mods/kubejs/event/$Extra"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $ItemEvents {

}

export namespace $ItemEvents {
const GROUP: $EventGroup
const SUPPORTS_ITEM: $Extra
const MODIFICATION: $EventHandler
const TOOL_TIER_REGISTRY: $EventHandler
const ARMOR_TIER_REGISTRY: $EventHandler
const RIGHT_CLICKED: $EventHandler
const CAN_PICK_UP: $EventHandler
const PICKED_UP: $EventHandler
const DROPPED: $EventHandler
const ENTITY_INTERACTED: $EventHandler
const CRAFTED: $EventHandler
const SMELTED: $EventHandler
const FOOD_EATEN: $EventHandler
const TOOLTIP: $EventHandler
const MODEL_PROPERTIES: $EventHandler
const FIRST_RIGHT_CLICKED: $EventHandler
const FIRST_LEFT_CLICKED: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemEvents$Type = ($ItemEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemEvents_ = $ItemEvents$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$EqOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $EqOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EqOpUnit$Type = ($EqOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EqOpUnit_ = $EqOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Comment" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Token$CommentType, $Token$CommentType$Type} from "packages/dev/latvian/mods/rhino/$Token$CommentType"

export class $Comment extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, type: $Token$CommentType$Type, value: string)

public "getValue"(): string
public "setValue"(commentString: string): void
public "setCommentType"(type: $Token$CommentType$Type): void
public "getCommentType"(): $Token$CommentType
get "value"(): string
set "value"(value: string)
set "commentType"(value: $Token$CommentType$Type)
get "commentType"(): $Token$CommentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Comment$Type = ($Comment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Comment_ = $Comment$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$DisplayClientErrorsMessage" {
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $DisplayClientErrorsMessage extends $BaseS2CMessage {

constructor()

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayClientErrorsMessage$Type = ($DisplayClientErrorsMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisplayClientErrorsMessage_ = $DisplayClientErrorsMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$IDFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $IDFilter extends $Record implements $MobFilter {

constructor(id: $ResourceLocation$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "id"(): $ResourceLocation
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDFilter$Type = ($IDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDFilter_ = $IDFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$SuperBlock" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SuperBlock {


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SuperBlock$Type = ($SuperBlock);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SuperBlock_ = $SuperBlock$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemStackKey" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemStackKey {
static "EMPTY": $ItemStackKey

constructor(item: $Item$Type, tag: $CompoundTag$Type)

public "equals"(obj: any): boolean
public "hashCode"(): integer
public static "of"(stack: $ItemStack$Type): $ItemStackKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackKey$Type = ($ItemStackKey);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackKey_ = $ItemStackKey$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$KubeJSItemStackData" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSItemStackData {
 "chance": double

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSItemStackData$Type = ($KubeJSItemStackData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSItemStackData_ = $KubeJSItemStackData$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/color/$SimpleColorWithAlpha" {
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export class $SimpleColorWithAlpha implements $Color {

constructor(v: integer)

public "toString"(): string
public "createTextColorJS"(): $TextColor
public "getArgbJS"(): integer
public "getRgbJS"(): integer
public "getSerializeJS"(): string
public "getHexJS"(): string
public "getFireworkColorJS"(): integer
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
get "argbJS"(): integer
get "rgbJS"(): integer
get "serializeJS"(): string
get "hexJS"(): string
get "fireworkColorJS"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleColorWithAlpha$Type = ($SimpleColorWithAlpha);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleColorWithAlpha_ = $SimpleColorWithAlpha$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$NetworkEventJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"

/**
 * Invoked when a network packet is received.
 * 
 * Note that the behaviour of this event is depending on the **script type**.
 * 
 * In `server_scripts`, this event is invoked on the server side when a packet is received from a client.
 * 
 * In `client_scripts`, this event is invoked on the client side when a packet is received from the server.
 */
export class $NetworkEventJS extends $PlayerEventJS {

constructor(p: $Player$Type, c: string, d: $CompoundTag$Type)

/**
 * The channel of the packet.
 */
public "getChannel"(): string
/**
 * The data of the packet.
 */
public "getData"(): $CompoundTag
/**
 * The player that sent the packet. Always `Minecraft.player` in `client_scripts`.
 */
public "getEntity"(): $Player
get "channel"(): string
get "data"(): $CompoundTag
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkEventJS$Type = ($NetworkEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkEventJS_ = $NetworkEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$FormattedCharSequence, $FormattedCharSequence$Type} from "packages/net/minecraft/util/$FormattedCharSequence"
import {$Tesselator, $Tesselator$Type} from "packages/com/mojang/blaze3d/vertex/$Tesselator"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$VariableSet, $VariableSet$Type} from "packages/dev/latvian/mods/unit/$VariableSet"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Screen, $Screen$Type} from "packages/net/minecraft/client/gui/screens/$Screen"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Font, $Font$Type} from "packages/net/minecraft/client/gui/$Font"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$PaintEventJS, $PaintEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PaintEventJS"
import {$PoseStack, $PoseStack$Type} from "packages/com/mojang/blaze3d/vertex/$PoseStack"
import {$BufferBuilder, $BufferBuilder$Type} from "packages/com/mojang/blaze3d/vertex/$BufferBuilder"

export class $PaintScreenEventJS extends $PaintEventJS implements $UnitVariables {
readonly "painter": $Painter
readonly "mouseX": integer
readonly "mouseY": integer
readonly "width": integer
readonly "height": integer
readonly "inventory": boolean
readonly "mc": $Minecraft
readonly "font": $Font
readonly "graphics": $GuiGraphics
readonly "matrices": $PoseStack
readonly "tesselator": $Tesselator
readonly "buffer": $BufferBuilder
readonly "delta": float
readonly "screen": $Screen

constructor(m: $Minecraft$Type, s: $Screen$Type, graphics: $GuiGraphics$Type, painter: $Painter$Type, mx: integer, my: integer, d: float)
constructor(m: $Minecraft$Type, graphics: $GuiGraphics$Type, painter: $Painter$Type, d: float)

public "scale"(x: float, y: float): void
public "scale"(scale: float): void
public "text"(text: $Component$Type, x: integer, y: integer, color: integer, shadow: boolean): void
public "translate"(x: double, y: double): void
public "getVariables"(): $VariableSet
public "rawText"(text: $FormattedCharSequence$Type, x: integer, y: integer, color: integer, shadow: boolean): void
public "alignY"(y: float, h: float, alignY: $AlignMode$Type): float
public "rotateDeg"(angle: float): void
public "rotateRad"(angle: float): void
public "alignX"(x: float, w: float, alignX: $AlignMode$Type): float
public "rectangle"(x: float, y: float, z: float, w: float, h: float, color: integer): void
public "rectangle"(x: float, y: float, z: float, w: float, h: float, color: integer, u0: float, v0: float, u1: float, v1: float): void
get "variables"(): $VariableSet
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintScreenEventJS$Type = ($PaintScreenEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintScreenEventJS_ = $PaintScreenEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$PreTagEventJS" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$TagEventJS, $TagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagEventJS"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$PreTagWrapper, $PreTagWrapper$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$PreTagWrapper"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EventExceptionHandler, $EventExceptionHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventExceptionHandler"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PreTagEventJS extends $TagEventJS {
readonly "tags": $Map<($ResourceLocation), ($PreTagWrapper)>
readonly "actions": $List<($Consumer<($TagEventJS)>)>
 "invalid": boolean
static readonly "TAG_EVENT_HANDLER": $EventExceptionHandler
static readonly "SOURCE": string
readonly "registry": $RegistryInfo<(any)>
readonly "vanillaRegistry": $Registry<(any)>
 "totalAdded": integer
 "totalRemoved": integer

constructor(registry: $RegistryInfo$Type<(any)>)

public static "handle"(tagEventHolders: $Map$Type<($ResourceKey$Type<(any)>), ($PreTagEventJS$Type)>): void
public "removeAllTagsFrom"(...ignored: (any)[]): void
public "getElementIds"(): $Set<($ResourceLocation)>
get "elementIds"(): $Set<($ResourceLocation)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PreTagEventJS$Type = ($PreTagEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PreTagEventJS_ = $PreTagEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ParseProblem" {
import {$ParseProblem$Type, $ParseProblem$Type$Type} from "packages/dev/latvian/mods/rhino/ast/$ParseProblem$Type"

export class $ParseProblem {

constructor(type: $ParseProblem$Type$Type, message: string, sourceName: string, offset: integer, length: integer)

public "toString"(): string
public "getLength"(): integer
public "getMessage"(): string
public "setLength"(length: integer): void
public "getType"(): $ParseProblem$Type
public "setType"(type: $ParseProblem$Type$Type): void
public "getSourceName"(): string
public "setMessage"(msg: string): void
public "setSourceName"(name: string): void
public "setFileOffset"(offset: integer): void
public "getFileOffset"(): integer
get "length"(): integer
get "message"(): string
set "length"(value: integer)
get "type"(): $ParseProblem$Type
set "type"(value: $ParseProblem$Type$Type)
get "sourceName"(): string
set "message"(value: string)
set "sourceName"(value: string)
set "fileOffset"(value: integer)
get "fileOffset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParseProblem$Type = ($ParseProblem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParseProblem_ = $ParseProblem$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventResult" {
import {$EventResult$Type, $EventResult$Type$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult$Type"
import {$EventResult as $EventResult$0, $EventResult$Type as $EventResult$0$Type} from "packages/dev/architectury/event/$EventResult"
import {$CompoundEventResult, $CompoundEventResult$Type} from "packages/dev/architectury/event/$CompoundEventResult"

export class $EventResult {
static readonly "PASS": $EventResult


public "type"(): $EventResult$Type
public "value"(): any
public "override"(): boolean
public "error"(): boolean
public "pass"(): boolean
public "interruptTrue"(): boolean
public "interruptDefault"(): boolean
public "arch"(): $EventResult$0
public "interruptFalse"(): boolean
public "archCompound"<T>(): $CompoundEventResult<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventResult$Type = ($EventResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventResult_ = $EventResult$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS$Entry, $ObjectDescJS$Entry$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS$Entry"

export class $ObjectDescJS extends $Record implements $TypeDescJS {

constructor(types: $List$Type<($ObjectDescJS$Entry$Type)>)

public "add"(key: string, value: $TypeDescJS$Type, optional: boolean): $ObjectDescJS
public "add"(key: string, value: $TypeDescJS$Type): $ObjectDescJS
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "types"(): $List<($ObjectDescJS$Entry)>
public "build"(builder: $StringBuilder$Type): void
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "build"(): string
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectDescJS$Type = ($ObjectDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectDescJS_ = $ObjectDescJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$WithPersistentData" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MessageSenderKJS, $MessageSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS"

export interface $WithPersistentData extends $MessageSenderKJS {

 "getPersistentData"(): $CompoundTag
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
}

export namespace $WithPersistentData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithPersistentData$Type = ($WithPersistentData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithPersistentData_ = $WithPersistentData$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SimpleMappingRecipeComponent<T> extends $MappingRecipeComponent<(T)> {

constructor(parent: $RecipeComponent$Type<(T)>, mappings: any)

public "componentType"(): string
public static "to"(o: any, mappings: $Map$Type<(string), (string)>): any
public static "from"(parentOutput: $JsonElement$Type, mappings: $Map$Type<(string), (string)>): $JsonElement
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleMappingRecipeComponent$Type<T> = ($SimpleMappingRecipeComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleMappingRecipeComponent_<T> = $SimpleMappingRecipeComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$IdeErrorReporter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"

export interface $IdeErrorReporter extends $ErrorReporter {

 "error"(arg0: string, arg1: string, arg2: integer, arg3: integer): void
 "warning"(arg0: string, arg1: string, arg2: integer, arg3: integer): void
 "error"(arg0: $Context$Type, arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): void
 "warning"(arg0: string, arg1: string, arg2: integer, arg3: string, arg4: integer): void
 "runtimeError"(arg0: $Context$Type, arg1: string, arg2: string, arg3: integer, arg4: string, arg5: integer): $EvaluatorException
}

export namespace $IdeErrorReporter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdeErrorReporter$Type = ($IdeErrorReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdeErrorReporter_ = $IdeErrorReporter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/desc/$OrDescJS" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ObjectDescJS, $ObjectDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$ObjectDescJS"

export class $OrDescJS extends $Record implements $TypeDescJS {

constructor(types: ($TypeDescJS$Type)[])

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "types"(): ($TypeDescJS)[]
public "build"(builder: $StringBuilder$Type): void
public "or"(type: $TypeDescJS$Type): $TypeDescJS
public static "object"(init: integer): $ObjectDescJS
public static "object"(): $ObjectDescJS
public "build"(): string
public "asArray"(): $TypeDescJS
public static "any"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "asMap"(): $TypeDescJS
public "asMap"(key: $TypeDescJS$Type): $TypeDescJS
public static "fixedArray"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
public "withGenerics"(...types: ($TypeDescJS$Type)[]): $TypeDescJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OrDescJS$Type = ($OrDescJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OrDescJS_ = $OrDescJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$JsonRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $JsonRecipeSchema extends $RecipeSchema {
static readonly "SCHEMA": $JsonRecipeSchema
static readonly "DEFAULT_UNIQUE_ID_FUNCTION": $Function<($RecipeJS), (string)>
readonly "recipeType": $Class<(any)>
readonly "factory": $Supplier<(any)>
readonly "keys": ($RecipeKey<(any)>)[]
 "uniqueIdFunction": $Function<($RecipeJS), (string)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonRecipeSchema$Type = ($JsonRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonRecipeSchema_ = $JsonRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Node" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$Comment, $Comment$Type} from "packages/dev/latvian/mods/rhino/ast/$Comment"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $Node implements $Iterable<($Node)> {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(nodeType: integer)
constructor(nodeType: integer, child: $Node$Type)
constructor(nodeType: integer, left: $Node$Type, right: $Node$Type)
constructor(nodeType: integer, line: integer)
constructor(nodeType: integer, left: $Node$Type, mid: $Node$Type, right: $Node$Type)
constructor(nodeType: integer, left: $Node$Type, mid: $Node$Type, right: $Node$Type, line: integer)
constructor(nodeType: integer, left: $Node$Type, right: $Node$Type, line: integer)
constructor(nodeType: integer, child: $Node$Type, line: integer)

public "toString"(): string
public "getDouble"(): double
public static "newString"(str: string): $Node
public static "newString"(type: integer, str: string): $Node
public "iterator"(): $Iterator<($Node)>
public "getType"(): integer
public "setDouble"(number: double): void
public static "newTarget"(): $Node
public "getString"(): string
public "setType"(type: integer): $Node
public "getNext"(): $Node
public "replaceChild"(child: $Node$Type, newChild: $Node$Type): void
public "hasConsistentReturnUsage"(): boolean
public "hasChildren"(): boolean
public "setLineno"(lineno: integer): void
public "getLineno"(): integer
public "setString"(s: string): void
public "addChildToBack"(child: $Node$Type): void
public "putProp"(propType: integer, prop: any): void
public "setJsDocNode"(jsdocNode: $Comment$Type): void
public "hasSideEffects"(): boolean
public "addChildToFront"(child: $Node$Type): void
public static "newNumber"(number: double): $Node
public "getJsDocNode"(): $Comment
public "getLastSibling"(): $Node
public "addChildrenToBack"(children: $Node$Type): void
public "replaceChildAfter"(prevChild: $Node$Type, newChild: $Node$Type): void
public "getJsDoc"(): string
public "removeProp"(propType: integer): void
public "getChildBefore"(child: $Node$Type): $Node
public "addChildrenToFront"(children: $Node$Type): void
public "getExistingIntProp"(propType: integer): integer
public "addChildBefore"(newChild: $Node$Type, node: $Node$Type): void
public "getProp"(propType: integer): any
public "addChildAfter"(newChild: $Node$Type, node: $Node$Type): void
public "putIntProp"(propType: integer, prop: integer): void
public "setScope"(s: $Scope$Type): void
public "labelId"(labelId: integer): void
public "labelId"(): integer
public "resetTargets"(): void
public "removeChildren"(): void
public "getLastChild"(): $Node
public "removeChild"(child: $Node$Type): void
public "getFirstChild"(): $Node
public "getIntProp"(propType: integer, defaultValue: integer): integer
public "getScope"(): $Scope
public "spliterator"(): $Spliterator<($Node)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$Node>;
get "double"(): double
get "type"(): integer
set "double"(value: double)
get "string"(): string
set "type"(value: integer)
get "next"(): $Node
set "lineno"(value: integer)
get "lineno"(): integer
set "string"(value: string)
set "jsDocNode"(value: $Comment$Type)
get "jsDocNode"(): $Comment
get "lastSibling"(): $Node
get "jsDoc"(): string
set "scope"(value: $Scope$Type)
get "lastChild"(): $Node
get "firstChild"(): $Node
get "scope"(): $Scope
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Node$Type = ($Node);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Node_ = $Node$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$IntRange" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$NumberComponent$LongRange, $NumberComponent$LongRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$LongRange"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$NumberComponent, $NumberComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NumberComponent$FloatRange, $NumberComponent$FloatRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$FloatRange"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$NumberComponent$DoubleRange, $NumberComponent$DoubleRange$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$NumberComponent$DoubleRange"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NumberComponent$IntRange extends $Record implements $NumberComponent<(integer)> {

constructor(min: integer, max: integer)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "min"(): integer
public "min"(min: integer): $NumberComponent$IntRange
public "max"(): integer
public "max"(max: integer): $NumberComponent$IntRange
public "write"(recipe: $RecipeJS$Type, value: integer): $JsonPrimitive
public "componentClass"(): $Class<(any)>
public "componentType"(): string
public static "doubleRange"(min: double, max: double): $NumberComponent$DoubleRange
public static "floatRange"(min: float, max: float): $NumberComponent$FloatRange
public static "intRange"(min: integer, max: integer): $NumberComponent$IntRange
public static "longRange"(min: long, max: long): $NumberComponent$LongRange
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(integer)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(integer)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(integer), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(integer), (O)>
public "asArray"(): $ArrayRecipeComponent<(integer)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (integer)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(integer)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(integer)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(integer)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(integer)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(integer)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: integer, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: integer, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(integer)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(integer)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (integer)>)>
public "checkEmpty"(key: $RecipeKey$Type<(integer)>, value: integer): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: integer, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): integer
public "replaceInput"(recipe: $RecipeJS$Type, original: integer, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): integer
public "checkValueHasChanged"(oldValue: integer, newValue: integer): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(integer)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NumberComponent$IntRange$Type = ($NumberComponent$IntRange);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NumberComponent$IntRange_ = $NumberComponent$IntRange$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemCraftedEventJS" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

/**
 * Invoked when a player crafts an item.
 */
export class $ItemCraftedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, crafted: $ItemStack$Type, container: $Container$Type)

/**
 * The item that was crafted.
 */
public "getItem"(): $ItemStack
/**
 * The inventory that the item was crafted in.
 */
public "getInventory"(): $InventoryKJS
/**
 * The player that crafted the item.
 */
public "getEntity"(): $Player
get "item"(): $ItemStack
get "inventory"(): $InventoryKJS
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemCraftedEventJS$Type = ($ItemCraftedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemCraftedEventJS_ = $ItemCraftedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockTintFunction, $BlockTintFunction$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction"
import {$BlockItemBuilder, $BlockItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockItemBuilder"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$BlockExplodedCallbackJS, $BlockExplodedCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockExplodedCallbackJS"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DataJsonGenerator, $DataJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$DataJsonGenerator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockStateRotateCallbackJS, $BlockStateRotateCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateRotateCallbackJS"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"
import {$EntityFallenOnBlockCallbackJS, $EntityFallenOnBlockCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$EntityFallenOnBlockCallbackJS"
import {$BlockStateMirrorCallbackJS, $BlockStateMirrorCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateMirrorCallbackJS"
import {$BlockRightClickedEventJS, $BlockRightClickedEventJS$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockRightClickedEventJS"
import {$AfterEntityFallenOnBlockCallbackJS, $AfterEntityFallenOnBlockCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$AfterEntityFallenOnBlockCallbackJS"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$NoteBlockInstrument, $NoteBlockInstrument$Type} from "packages/net/minecraft/world/level/block/state/properties/$NoteBlockInstrument"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BlockStateModifyPlacementCallbackJS, $BlockStateModifyPlacementCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyPlacementCallbackJS"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Property, $Property$Type} from "packages/net/minecraft/world/level/block/state/properties/$Property"
import {$EntitySteppedOnBlockCallbackJS, $EntitySteppedOnBlockCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$EntitySteppedOnBlockCallbackJS"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyCallbackJS"
import {$CanBeReplacedCallbackJS, $CanBeReplacedCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$CanBeReplacedCallbackJS"

export class $BlockBuilder extends $BuilderBase<($Block)> {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createProperties"(): $BlockBehaviour$Properties
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double): $BlockBuilder
/**
 * Set the shape of the block.
 */
public "box"(x0: double, y0: double, z0: double, x1: double, y1: double, z1: double, scale16: boolean): $BlockBuilder
/**
 * Set the color of a specific layer of the block.
 */
public "color"(index: integer, color: $BlockTintFunction$Type): $BlockBuilder
/**
 * Set the color of a specific layer of the block.
 */
public "color"(color: $BlockTintFunction$Type): $BlockBuilder
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$Type): $BuilderBase<($Block)>
/**
 * Tags both the block and the item with the given tag.
 */
public "tag"(tag: $ResourceLocation$Type): $BlockBuilder
/**
 * Modifies the block's item representation.
 */
public "item"(i: $Consumer$Type<($BlockItemBuilder$Type)>): $BlockBuilder
/**
 * Add a blockstate property to the block.
 * 
 * For example, facing, lit, etc.
 */
public "property"(property: $Property$Type<(any)>): $BlockBuilder
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "generateDataJsons"(generator: $DataJsonGenerator$Type): void
/**
 * Note block instrument.
 */
public "instrument"(i: $NoteBlockInstrument$Type): $BlockBuilder
/**
 * Set how this block reacts after an explosion. Note the block has already been destroyed at this point
 */
public "exploded"(callbackJS: $Consumer$Type<($BlockExplodedCallbackJS$Type)>): $BlockBuilder
public "createAdditionalObjects"(): void
/**
 * Sets the light level of the block. Defaults to 0 (no light).
 */
public "lightLevel"(light: float): $BlockBuilder
/**
 * Set the callback used for right-clicking on the block
 */
public "rightClick"(callbackJS: $Consumer$Type<($BlockRightClickedEventJS$Type)>): $BlockBuilder
/**
 * Sets the render type of the block. Can be `cutout`, `cutout_mipped`, `translucent`, or `basic`.
 */
public "renderType"(l: string): $BlockBuilder
public "transformObject"(obj: $Block$Type): $Block
/**
 * Sets the opacity of the block. Opaque blocks do not let light through.
 */
public "opaque"(o: boolean): $BlockBuilder
/**
 * Makes mobs not spawn on the block.
 */
public "noValidSpawns"(b: boolean): $BlockBuilder
/**
 * Makes the block suffocating.
 */
public "suffocating"(b: boolean): $BlockBuilder
/**
 * Makes the block view blocking.
 */
public "viewBlocking"(b: boolean): $BlockBuilder
/**
 * Makes the block a redstone conductor.
 */
public "redstoneConductor"(b: boolean): $BlockBuilder
/**
 * Sets the block should be a full block or not, like cactus or doors.
 */
public "fullBlock"(f: boolean): $BlockBuilder
/**
 * Set how slippery the block is.
 */
public "slipperiness"(f: float): $BlockBuilder
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(): $BlockBuilder
/**
 * Makes the block require a tool to have drops when broken.
 */
public "requiresTool"(f: boolean): $BlockBuilder
/**
 * Makes the block not collide with entities.
 */
public "noCollision"(): $BlockBuilder
public "woodSoundType"(): $BlockBuilder
public "noSoundType"(): $BlockBuilder
public "gravelSoundType"(): $BlockBuilder
/**
 * Texture the block on all sides with the same texture.
 */
public "textureAll"(tex: string): $BlockBuilder
public "stoneSoundType"(): $BlockBuilder
public "grassSoundType"(): $BlockBuilder
/**
 * Set the block to have no corresponding item.
 */
public "noItem"(): $BlockBuilder
public static "createShape"(boxes: $List$Type<($AABB$Type)>): $VoxelShape
public "cropSoundType"(): $BlockBuilder
public "glassSoundType"(): $BlockBuilder
/**
 * 
 * @deprecated
 */
public "setWaterlogged"(waterlogged: boolean): $BlockBuilder
/**
 * Sets the block's map color dynamically per block state. If unset, defaults to NONE.
 */
public "dynamicMapColor"(m: $Function$Type<($BlockState$Type), (any)>): $BlockBuilder
public "sandSoundType"(): $BlockBuilder
/**
 * Helper method for setting the render type of the block to `translucent` correctly.
 */
public "defaultTranslucent"(): $BlockBuilder
/**
 * Tags the block with the given tag.
 */
public "tagBlock"(tag: $ResourceLocation$Type): $BlockBuilder
/**
 * Set what happens when an entity steps on the block
 * This is called every tick for every entity standing on the block, so be careful what you do here.
 */
public "steppedOn"(callbackJS: $Consumer$Type<($EntitySteppedOnBlockCallbackJS$Type)>): $BlockBuilder
/**
 * Tags the item with the given tag.
 */
public "tagItem"(tag: $ResourceLocation$Type): $BlockBuilder
/**
 * Set how this block bounces/moves entities that land on top of this. Do not use this to modify the block, use fallOn instead!
 * Use ctx.bounce(height) or ctx.setVelocity(x, y, z) to change the entities velocity.
 */
public "afterFallenOn"(callbackJS: $Consumer$Type<($AfterEntityFallenOnBlockCallbackJS$Type)>): $BlockBuilder
/**
 * Tags both the block and the item with the given tag.
 */
public "tagBoth"(tag: $ResourceLocation$Type): $BlockBuilder
/**
 * Clears all drops for the block.
 */
public "noDrops"(): $BlockBuilder
/**
 * Set what happens when an entity falls on the block. Do not use this for moving them, use bounce instead!
 */
public "fallenOn"(callbackJS: $Consumer$Type<($EntityFallenOnBlockCallbackJS$Type)>): $BlockBuilder
/**
 * Set if the block can be replaced by something else.
 */
public "canBeReplaced"(callbackJS: $Predicate$Type<($CanBeReplacedCallbackJS$Type)>): $BlockBuilder
/**
 * Bounces entities that land on this block by bounciness * their fall velocity.
 * Do not make bounciness negative, as that is a recipe for a long and laggy trip to the void
 */
public "bounciness"(bounciness: float): $BlockBuilder
/**
 * Checks if the block can be waterlogged.
 */
public "canBeWaterlogged"(): boolean
/**
 * 
 * @deprecated
 */
public "getWaterlogged"(): boolean
/**
 * Set the callback used for determining how the block is mirrored
 */
public "mirrorState"(callbackJS: $Consumer$Type<($BlockStateMirrorCallbackJS$Type)>): $BlockBuilder
/**
 * Set the callback used for determining how the block rotates
 */
public "rotateState"(callbackJS: $Consumer$Type<($BlockStateRotateCallbackJS$Type)>): $BlockBuilder
/**
 * Sets the hardness of the block. Defaults to 1.5.
 * 
 * Setting this to -1 will make the block unbreakable like bedrock.
 */
public "hardness"(h: float): $BlockBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
/**
 * Texture a specific side of the block.
 */
public "textureSide"(direction: $Direction$Type, tex: string): $BlockBuilder
/**
 * Makes the block unbreakable.
 */
public "unbreakable"(): $BlockBuilder
/**
 * Makes the block transparent.
 */
public "transparent"(b: boolean): $BlockBuilder
/**
 * Texture a specific texture key of the block.
 */
public "texture"(id: string, tex: string): $BlockBuilder
/**
 * Makes the block not be solid.
 */
public "notSolid"(): $BlockBuilder
/**
 * Set how high you can jump on the block.
 */
public "jumpFactor"(f: float): $BlockBuilder
/**
 * Set how fast you can walk on the block.
 * 
 * Any value above 1 will make you walk insanely fast as your speed is multiplied by this value each tick.
 * 
 * Recommended values are between 0.1 and 1, useful for mimicking soul sand or ice.
 */
public "speedFactor"(f: float): $BlockBuilder
/**
 * Sets the block's sound type. Defaults to wood.
 */
public "soundType"(m: $SoundType$Type): $BlockBuilder
/**
 * Sets random tick callback for this black.
 */
public "randomTick"(randomTickCallback: $Consumer$Type<($RandomTickCallbackJS$Type)>): $BlockBuilder
/**
 * Makes the block can be waterlogged.
 */
public "waterlogged"(): $BlockBuilder
/**
 * Helper method for setting the render type of the block to `cutout` correctly.
 */
public "defaultCutout"(): $BlockBuilder
/**
 * Set the callback for determining the blocks state when placed.
 */
public "placementState"(callbackJS: $Consumer$Type<($BlockStateModifyPlacementCallbackJS$Type)>): $BlockBuilder
/**
 * Set the block's model.
 */
public "model"(m: string): $BlockBuilder
/**
 * Set the default state of the block.
 */
public "defaultState"(callbackJS: $Consumer$Type<($BlockStateModifyCallbackJS$Type)>): $BlockBuilder
/**
 * Creates a Block Entity for this block
 */
public "blockEntity"(callback: $Consumer$Type<($BlockEntityInfo$Type)>): $BlockBuilder
public "material"(material: string): $BlockBuilder
/**
 * Sets the block's map color. Defaults to NONE.
 */
public "mapColor"(m: $MapColor$Type): $BlockBuilder
/**
 * Sets the blast resistance of the block. Defaults to 3.
 */
public "resistance"(r: float): $BlockBuilder
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilder$Type = ($BlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBuilder_ = $BlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ConsoleLine" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$LogType, $LogType$Type} from "packages/dev/latvian/mods/kubejs/util/$LogType"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ConsoleLine$SourceLine, $ConsoleLine$SourceLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine$SourceLine"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ConsoleLine {
static readonly "EMPTY_ARRAY": ($ConsoleLine)[]
readonly "console": $ConsoleJS
readonly "timestamp": long
 "message": string
 "type": $LogType
 "group": string
 "sourceLines": $Collection<($ConsoleLine$SourceLine)>
 "externalFile": $Path
 "stackTrace": $List<(string)>

constructor(console: $ConsoleJS$Type, timestamp: long, message: string)
constructor(buf: $FriendlyByteBuf$Type)

public "toString"(): string
public "getText"(): string
public "withSourceLine"(source: string, line: integer): $ConsoleLine
public static "writeToNet"(buf: $FriendlyByteBuf$Type, line: $ConsoleLine$Type): void
public "withExternalFile"(path: $Path$Type): $ConsoleLine
get "text"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleLine$Type = ($ConsoleLine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleLine_ = $ConsoleLine$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ParseProblem$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ParseProblem$Type extends $Enum<($ParseProblem$Type)> {
static readonly "Error": $ParseProblem$Type
static readonly "Warning": $ParseProblem$Type


public static "values"(): ($ParseProblem$Type)[]
public static "valueOf"(name: string): $ParseProblem$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ParseProblem$Type$Type = (("warning") | ("error")) | ($ParseProblem$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ParseProblem$Type_ = $ParseProblem$Type$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$KubeJSRecipeEventHandler" {
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/dev/architectury/registry/registries/$DeferredRegister"

export class $KubeJSRecipeEventHandler {
static readonly "REGISTER": $DeferredRegister<($RecipeSerializer<(any)>)>
static "SHAPED": $Supplier<($RecipeSerializer<(any)>)>
static "SHAPELESS": $Supplier<($RecipeSerializer<(any)>)>

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSRecipeEventHandler$Type = ($KubeJSRecipeEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSRecipeEventHandler_ = $KubeJSRecipeEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJSON" {
import {$Remapper, $Remapper$Type} from "packages/dev/latvian/mods/rhino/util/$Remapper"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeJSON extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getClassName"(): string
public static "parse"(cx: $Context$Type, scope: $Scriptable$Type, jtext: string, reviver: $Callable$Type): any
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public static "stringify"(value: any, replacer: any, space: any, cx: $Context$Type): string
public static "stringify0"(cx: $Context$Type, remapper: $Remapper$Type, v: any): $JsonElement
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJSON$Type = ($NativeJSON);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJSON_ = $NativeJSON$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$StartupEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"

export class $StartupEventJS extends $EventJS {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StartupEventJS$Type = ($StartupEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StartupEventJS_ = $StartupEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaArray" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NativeJavaObject, $NativeJavaObject$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaObject"
import {$SymbolScriptable, $SymbolScriptable$Type} from "packages/dev/latvian/mods/rhino/$SymbolScriptable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $NativeJavaArray extends $NativeJavaObject implements $SymbolScriptable {

constructor(scope: $Scriptable$Type, array: any, cx: $Context$Type)

public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, id: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, id: string, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public static "wrap"(scope: $Scriptable$Type, array: any, cx: $Context$Type): $NativeJavaArray
public "delete"(cx: $Context$Type, key: $Symbol$Type): void
public "getDefaultValue"(cx: $Context$Type, hint: $Class$Type<(any)>): any
public "unwrap"(): any
public "getClassName"(): string
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, id: string, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "getIds"(cx: $Context$Type): (any)[]
public "hasInstance"(cx: $Context$Type, value: $Scriptable$Type): boolean
public "getPrototype"(cx: $Context$Type): $Scriptable
public "put"(arg0: $Context$Type, arg1: $Symbol$Type, arg2: $Scriptable$Type, arg3: any): void
public static "unwrapped"(o: any): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaArray$Type = ($NativeJavaArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaArray_ = $NativeJavaArray$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$EmbeddedSlotMap" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ScriptableObject$Slot, $ScriptableObject$Slot$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$Slot"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SlotMap, $SlotMap$Type} from "packages/dev/latvian/mods/rhino/$SlotMap"
import {$ScriptableObject$SlotAccess, $ScriptableObject$SlotAccess$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject$SlotAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export class $EmbeddedSlotMap implements $SlotMap {

constructor()

public "remove"(key: any, index: integer, cx: $Context$Type): void
public "get"(key: any, index: integer, accessType: $ScriptableObject$SlotAccess$Type): $ScriptableObject$Slot
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $Iterator<($ScriptableObject$Slot)>
public "query"(key: any, index: integer): $ScriptableObject$Slot
public "addSlot"(newSlot: $ScriptableObject$Slot$Type): void
public "spliterator"(): $Spliterator<($ScriptableObject$Slot)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$ScriptableObject$Slot>;
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmbeddedSlotMap$Type = ($EmbeddedSlotMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmbeddedSlotMap_ = $EmbeddedSlotMap$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$GiftLootEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$LootEventJS, $LootEventJS$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootEventJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GiftLootEventJS extends $LootEventJS {

constructor(c: $Map$Type<($ResourceLocation$Type), ($JsonElement$Type)>)

public "getType"(): string
public "getDirectory"(): string
public "addGift"(id: $ResourceLocation$Type, b: $Consumer$Type<($LootBuilder$Type)>): void
get "type"(): string
get "directory"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GiftLootEventJS$Type = ($GiftLootEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GiftLootEventJS_ = $GiftLootEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityEventCallback" {
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"

export interface $BlockEntityEventCallback {

 "accept"(arg0: $BlockEntityJS$Type, arg1: integer): void

(arg0: $BlockEntityJS$Type, arg1: integer): void
}

export namespace $BlockEntityEventCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityEventCallback$Type = ($BlockEntityEventCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityEventCallback_ = $BlockEntityEventCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$ShapedRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $ShapedRecipeSchema {

}

export namespace $ShapedRecipeSchema {
const RESULT: $RecipeKey<($OutputItem)>
const PATTERN: $RecipeKey<((string)[])>
const KEY: $RecipeKey<($TinyMap<(character), ($InputItem)>)>
const KJS_MIRROR: $RecipeKey<(boolean)>
const KJS_SHRINK: $RecipeKey<(boolean)>
const INGREDIENTS: $RecipeKey<((($InputItem)[])[])>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedRecipeSchema$Type = ($ShapedRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedRecipeSchema_ = $ShapedRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeBoolean" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeBoolean extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getDefaultValue"(cx: $Context$Type, typeHint: $Class$Type<(any)>): any
public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeBoolean$Type = ($NativeBoolean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeBoolean_ = $NativeBoolean$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$RECompiled" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $RECompiled {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RECompiled$Type = ($RECompiled);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RECompiled_ = $RECompiled$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$LineObject" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ScreenPainterObject, $ScreenPainterObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenPainterObject"

export class $LineObject extends $ScreenPainterObject {
 "color": $Unit
 "x2": $Unit
 "y2": $Unit
 "size": $Unit
 "length": $Unit
 "rotation": $Unit
 "offset": $Unit
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LineObject$Type = ($LineObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LineObject_ = $LineObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$DisplayServerErrorsMessage" {
import {$ConsoleLine, $ConsoleLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $DisplayServerErrorsMessage extends $BaseS2CMessage {

constructor(type: $ScriptType$Type, errors: $List$Type<($ConsoleLine$Type)>, warnings: $List$Type<($ConsoleLine$Type)>)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DisplayServerErrorsMessage$Type = ($DisplayServerErrorsMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DisplayServerErrorsMessage_ = $DisplayServerErrorsMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptPack" {
import {$ScriptFile, $ScriptFile$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptFile"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"
import {$ScriptPackInfo, $ScriptPackInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPackInfo"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptPack {
readonly "manager": $ScriptManager
readonly "info": $ScriptPackInfo
readonly "scripts": $List<($ScriptFile)>
 "scope": $Scriptable

constructor(m: $ScriptManager$Type, i: $ScriptPackInfo$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptPack$Type = ($ScriptPack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptPack_ = $ScriptPack$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$ModOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $ModOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModOpUnit$Type = ($ModOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModOpUnit_ = $ModOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$BuiltinKubeJSForgeClientPlugin" {
import {$BuiltinKubeJSClientPlugin, $BuiltinKubeJSClientPlugin$Type} from "packages/dev/latvian/mods/kubejs/client/$BuiltinKubeJSClientPlugin"

export class $BuiltinKubeJSForgeClientPlugin extends $BuiltinKubeJSClientPlugin {

constructor()

public "clientInit"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuiltinKubeJSForgeClientPlugin$Type = ($BuiltinKubeJSForgeClientPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuiltinKubeJSForgeClientPlugin_ = $BuiltinKubeJSForgeClientPlugin$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$RegexIDFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $RegexIDFilter extends $Record implements $BiomeFilter {

constructor(pattern: $Pattern$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "pattern"(): $Pattern
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegexIDFilter$Type = ($RegexIDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegexIDFilter_ = $RegexIDFilter$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$MulOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MulOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MulOpUnit$Type = ($MulOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MulOpUnit_ = $MulOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$BitNotOpUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnaryOpUnit, $UnaryOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$UnaryOpUnit"

export class $BitNotOpUnit extends $UnaryOpUnit {
readonly "symbol": $UnitSymbol
 "unit": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(unit: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BitNotOpUnit$Type = ($BitNotOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BitNotOpUnit_ = $BitNotOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemBuilder$UseCallback" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"

export interface $ItemBuilder$UseCallback {

 "use"(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): boolean

(arg0: $Level$Type, arg1: $Player$Type, arg2: $InteractionHand$Type): boolean
}

export namespace $ItemBuilder$UseCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemBuilder$UseCallback$Type = ($ItemBuilder$UseCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemBuilder$UseCallback_ = $ItemBuilder$UseCallback$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$StairBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $StairBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StairBlockBuilder$Type = ($StairBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StairBlockBuilder_ = $StairBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ConstantPool" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ConstantPool {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantPool$Type = ($ConstantPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstantPool_ = $ConstantPool$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement" {
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer$Replacement, $OutputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $OutputReplacement {

 "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement
 "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
}

export namespace $OutputReplacement {
function of(o: any): $OutputReplacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputReplacement$Type = ($OutputItem$Type) | ($OutputReplacement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputReplacement_ = $OutputReplacement$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptRuntime" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RegExp, $RegExp$Type} from "packages/dev/latvian/mods/rhino/regexp/$RegExp"
import {$IdEnumeration, $IdEnumeration$Type} from "packages/dev/latvian/mods/rhino/$IdEnumeration"
import {$JavaScriptException, $JavaScriptException$Type} from "packages/dev/latvian/mods/rhino/$JavaScriptException"
import {$Date, $Date$Type} from "packages/java/util/$Date"
import {$ScriptRuntime$MessageProvider, $ScriptRuntime$MessageProvider$Type} from "packages/dev/latvian/mods/rhino/$ScriptRuntime$MessageProvider"
import {$NativeFunction, $NativeFunction$Type} from "packages/dev/latvian/mods/rhino/$NativeFunction"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$TopLevel$Builtins, $TopLevel$Builtins$Type} from "packages/dev/latvian/mods/rhino/$TopLevel$Builtins"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$EcmaError, $EcmaError$Type} from "packages/dev/latvian/mods/rhino/$EcmaError"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Ref, $Ref$Type} from "packages/dev/latvian/mods/rhino/$Ref"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$ScriptableObject, $ScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject"

export class $ScriptRuntime {
static readonly "EMPTY_OBJECTS": (any)[]
static readonly "EMPTY_STRINGS": (string)[]
static readonly "BooleanClass": $Class<(boolean)>
static readonly "ByteClass": $Class<(byte)>
static readonly "CharacterClass": $Class<(character)>
static readonly "ClassClass": $Class<($Class)>
static readonly "DoubleClass": $Class<(double)>
static readonly "FloatClass": $Class<(float)>
static readonly "IntegerClass": $Class<(integer)>
static readonly "LongClass": $Class<(long)>
static readonly "NumberClass": $Class<(number)>
static readonly "ObjectClass": $Class<(any)>
static readonly "ShortClass": $Class<(short)>
static readonly "StringClass": $Class<(string)>
static readonly "DateClass": $Class<($Date)>
static readonly "ContextClass": $Class<(any)>
static readonly "FunctionClass": $Class<($Function)>
static readonly "ScriptableObjectClass": $Class<($ScriptableObject)>
static readonly "ScriptableClass": $Class<($Scriptable)>
static readonly "NaN": double
static readonly "NaNobj": double
static readonly "negativeZero": double
static readonly "zeroObj": double
static readonly "negativeZeroObj": double
static readonly "ENUMERATE_KEYS": integer
static readonly "ENUMERATE_VALUES": integer
static readonly "ENUMERATE_ARRAY": integer
static readonly "ENUMERATE_KEYS_NO_ITERATOR": integer
static readonly "ENUMERATE_VALUES_NO_ITERATOR": integer
static readonly "ENUMERATE_ARRAY_NO_ITERATOR": integer
static readonly "ENUMERATE_VALUES_IN_ORDER": integer
static readonly "messageProvider": $ScriptRuntime$MessageProvider


public static "name"(cx: $Context$Type, scope: $Scriptable$Type, name: string): any
public static "add"(cx: $Context$Type, val1: any, val2: any): any
public static "add"(cx: $Context$Type, val1: any, val2: charseq): charseq
public static "add"(cx: $Context$Type, val1: charseq, val2: any): charseq
public static "toString"(cx: $Context$Type, val: any): string
public static "toString"(cx: $Context$Type, val: double): string
public static "toString"(cx: $Context$Type, args: (any)[], index: integer): string
public static "isPrimitive"(obj: any): boolean
public static "getMessage"(messageId: string, arg1: (any)[]): string
public static "in"(cx: $Context$Type, a: any, b: any): boolean
public static "delete"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, id: any, isName: boolean): any
public static "wrapException"(cx: $Context$Type, scope: $Scriptable$Type, t: $Throwable$Type): $Scriptable
public static "setName"(cx: $Context$Type, scope: $Scriptable$Type, bound: $Scriptable$Type, value: any, id: string): any
public static "isNaN"(n: any): boolean
public static "eq"(cx: $Context$Type, x: any, y: any): boolean
public static "bind"(cx: $Context$Type, scope: $Scriptable$Type, id: string): $Scriptable
public static "toBoolean"(cx: $Context$Type, val: any): boolean
public static "getObjectElem"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, elem: any): any
public static "getObjectElem"(cx: $Context$Type, obj: $Scriptable$Type, elem: any): any
public static "jsDelegatesTo"(cx: $Context$Type, lhs: $Scriptable$Type, rhs: $Scriptable$Type): boolean
public static "typeError0"(cx: $Context$Type, messageId: string): $EcmaError
public static "shallowEq"(cx: $Context$Type, x: any, y: any): boolean
public static "isObject"(value: any): boolean
public static "constructError"(cx: $Context$Type, error: string, message: string): $EcmaError
public static "constructError"(cx: $Context$Type, error: string, message: string, lineNumberDelta: integer): $EcmaError
public static "constructError"(cx: $Context$Type, error: string, message: string, sourceName: string, lineNumber: integer, lineSource: string, columnNumber: integer): $EcmaError
public static "instanceOf"(cx: $Context$Type, a: any, b: any): boolean
public static "initSafeStandardObjects"(cx: $Context$Type, scope: $ScriptableObject$Type, sealed: boolean): $ScriptableObject
public static "toUint16"(cx: $Context$Type, val: any): character
public static "toInteger"(d: double): double
public static "toInteger"(cx: $Context$Type, val: any): double
public static "toInteger"(cx: $Context$Type, args: (any)[], index: integer): double
public static "toUint32"(cx: $Context$Type, val: any): long
public static "toUint32"(d: double): long
public static "toCharSequence"(cx: $Context$Type, val: any): charseq
public static "initStandardObjects"(cx: $Context$Type, scope: $ScriptableObject$Type, sealed: boolean): $ScriptableObject
public static "initFunction"(cx: $Context$Type, scope: $Scriptable$Type, arg2: $NativeFunction$Type, type: integer, fromEvalCode: boolean): void
public static "typeError2"(cx: $Context$Type, messageId: string, arg1: any, arg2: any): $EcmaError
public static "getMessage4"(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any): string
public static "getMessage3"(messageId: string, arg1: any, arg2: any, arg3: any): string
public static "getMessage0"(messageId: string): string
public static "getMessage2"(messageId: string, arg1: any, arg2: any): string
public static "same"(cx: $Context$Type, x: any, y: any): boolean
public static "setFunctionProtoAndParent"(cx: $Context$Type, scope: $Scriptable$Type, fn: $BaseFunction$Type, es6GeneratorFunction: boolean): void
public static "setFunctionProtoAndParent"(cx: $Context$Type, scope: $Scriptable$Type, fn: $BaseFunction$Type): void
public static "rangeError"(cx: $Context$Type, message: string): $EcmaError
public static "getValueFunctionAndThis"(cx: $Context$Type, value: any): $Callable
public static "getPropFunctionAndThis"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, property: string): $Callable
public static "getLibraryScopeOrNull"(scope: $Scriptable$Type, cx: $Context$Type): $ScriptableObject
public static "isJSWhitespaceOrLineTerminator"(c: integer): boolean
public static "createArrowFunctionActivation"(cx: $Context$Type, scope: $Scriptable$Type, funObj: $NativeFunction$Type, args: (any)[], isStrict: boolean): $Scriptable
public static "exitActivationFunction"(cx: $Context$Type): void
public static "createFunctionActivation"(cx: $Context$Type, scope: $Scriptable$Type, funObj: $NativeFunction$Type, args: (any)[], isStrict: boolean): $Scriptable
public static "getNameFunctionAndThis"(cx: $Context$Type, scope: $Scriptable$Type, name: string): $Callable
public static "getElemFunctionAndThis"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, elem: any): $Callable
public static "getObjectPropOptional"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, property: string): any
public static "getObjectPropNoWarn"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, property: string): any
public static "setObjectProtoAndParent"(cx: $Context$Type, scope: $Scriptable$Type, object: $ScriptableObject$Type): void
public static "getTemplateLiteralCallSite"(cx: $Context$Type, scope: $Scriptable$Type, strings: (any)[], index: integer): $Scriptable
public static "enterActivationFunction"(cx: $Context$Type, scope: $Scriptable$Type): void
public static "notFunctionError"(cx: $Context$Type, obj: any, value: any, propertyName: string): $RuntimeException
public static "notFunctionError"(cx: $Context$Type, value: any): $RuntimeException
public static "notFunctionError"(cx: $Context$Type, value: any, messageHelper: any): $RuntimeException
public static "typeError1"(cx: $Context$Type, messageId: string, arg1: any): $EcmaError
public static "toIterator"(cx: $Context$Type, scope: $Scriptable$Type, obj: $Scriptable$Type, keyOnly: boolean): $Scriptable
public static "applyOrCall"(cx: $Context$Type, scope: $Scriptable$Type, isApply: boolean, thisObj: $Scriptable$Type, args: (any)[]): any
public static "toObjectOrNull"(cx: $Context$Type, obj: any, scope: $Scriptable$Type): $Scriptable
/**
 * 
 * @deprecated
 */
public static "toObjectOrNull"(cx: $Context$Type, obj: any): $Scriptable
public static "getMessage1"(messageId: string, arg1: any): string
public static "callIterator"(cx: $Context$Type, scope: $Scriptable$Type, obj: any): any
public static "wrapNumber"(x: double): number
public static "toLength"(cx: $Context$Type, args: (any)[], index: integer): long
public static "sameZero"(cx: $Context$Type, x: any, y: any): boolean
public static "isRhinoRuntimeType"(cl: $Class$Type<(any)>): boolean
public static "isJSLineTerminator"(c: integer): boolean
public static "errorWithClassName"(msg: string, val: any, cx: $Context$Type): $RuntimeException
public static "padArguments"(args: (any)[], count: integer): (any)[]
public static "numberToString"(cx: $Context$Type, d: double, base: integer): string
public static "undefReadError"(cx: $Context$Type, object: any, id: any): $RuntimeException
public static "setObjectElem"(cx: $Context$Type, obj: $Scriptable$Type, elem: any, value: any): any
public static "setObjectElem"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, elem: any, value: any): any
public static "newBuiltinObject"(cx: $Context$Type, scope: $Scriptable$Type, type: $TopLevel$Builtins$Type, args: (any)[]): $Scriptable
public static "undefWriteError"(cx: $Context$Type, object: any, id: any, value: any): $RuntimeException
public static "indexFromString"(str: string): long
public static "getObjectIndex"(cx: $Context$Type, obj: $Scriptable$Type, index: integer): any
public static "getObjectIndex"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, dblIndex: double): any
public static "setObjectIndex"(cx: $Context$Type, obj: $Scriptable$Type, index: integer, value: any): any
public static "setObjectIndex"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, dblIndex: double, value: any): any
public static "deleteObjectElem"(cx: $Context$Type, target: $Scriptable$Type, elem: any): boolean
public static "testUint32String"(str: string): long
public static "getTopLevelProp"(cx: $Context$Type, scope: $Scriptable$Type, id: string): any
public static "setObjectProp"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, property: string, value: any): any
public static "setObjectProp"(cx: $Context$Type, obj: $Scriptable$Type, property: string, value: any): any
public static "getObjectProp"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, property: string): any
public static "getObjectProp"(cx: $Context$Type, obj: $Scriptable$Type, property: string): any
public static "refDel"(cx: $Context$Type, ref: $Ref$Type): any
public static "hasObjectElem"(cx: $Context$Type, target: $Scriptable$Type, elem: any): boolean
public static "refSet"(cx: $Context$Type, scope: $Scriptable$Type, ref: $Ref$Type, value: any): any
public static "notFoundError"(cx: $Context$Type, object: $Scriptable$Type, property: string): $RuntimeException
public static "specialRef"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, specialProperty: string): $Ref
public static "strictSetName"(cx: $Context$Type, scope: $Scriptable$Type, bound: $Scriptable$Type, value: any, id: string): any
public static "setConst"(cx: $Context$Type, bound: $Scriptable$Type, value: any, id: string): any
public static "refGet"(cx: $Context$Type, ref: $Ref$Type): any
public static "enumInit"(cx: $Context$Type, scope: $Scriptable$Type, value: any, enumType: integer): $IdEnumeration
public static "getArrayElements"(cx: $Context$Type, object: $Scriptable$Type): (any)[]
public static "callRef"(cx: $Context$Type, thisObj: $Scriptable$Type, arg2: $Callable$Type, args: (any)[]): $Ref
public static "evalSpecial"(cx: $Context$Type, scope: $Scriptable$Type, thisArg: any, args: (any)[], filename: string, lineNumber: integer): any
public static "isIteratorDone"(cx: $Context$Type, result: any): boolean
public static "undefCallError"(cx: $Context$Type, object: any, id: any): $RuntimeException
public static "newSpecial"(cx: $Context$Type, scope: $Scriptable$Type, fun: any, args: (any)[], callType: integer): any
public static "callSpecial"(cx: $Context$Type, scope: $Scriptable$Type, fun: $Callable$Type, thisObj: $Scriptable$Type, args: (any)[], callerThis: $Scriptable$Type, callType: integer, filename: string, lineNumber: integer): any
public static "initScript"(cx: $Context$Type, scope: $Scriptable$Type, funObj: $NativeFunction$Type, thisObj: $Scriptable$Type, evalScript: boolean): void
public static "cmp_LT"(cx: $Context$Type, val1: any, val2: any): boolean
public static "cmp_LE"(cx: $Context$Type, val1: any, val2: any): boolean
public static "typeofName"(cx: $Context$Type, scope: $Scriptable$Type, id: string): $MemberType
public static "refIncrDecr"(cx: $Context$Type, scope: $Scriptable$Type, ref: $Ref$Type, incrDecrMask: integer): any
public static "nameIncrDecr"(cx: $Context$Type, scopeChain: $Scriptable$Type, id: string, incrDecrMask: integer): any
public static "propIncrDecr"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, id: string, incrDecrMask: integer): any
public static "elemIncrDecr"(cx: $Context$Type, obj: any, index: any, scope: $Scriptable$Type, incrDecrMask: integer): any
public static "newArrayLiteral"(cx: $Context$Type, scope: $Scriptable$Type, objects: (any)[], skipIndices: (integer)[]): $Scriptable
public static "newCatchScope"(cx: $Context$Type, scope: $Scriptable$Type, t: $Throwable$Type, lastCatchScope: $Scriptable$Type, exceptionName: string): $Scriptable
public static "leaveWith"(scope: $Scriptable$Type): $Scriptable
public static "enterDotQuery"(value: any, scope: $Scriptable$Type, cx: $Context$Type): $Scriptable
public static "enterWith"(cx: $Context$Type, scope: $Scriptable$Type, obj: any): $Scriptable
public static "leaveDotQuery"(scope: $Scriptable$Type): $Scriptable
public static "updateDotQuery"(value: boolean, scope: $Scriptable$Type): any
public static "wrapRegExp"(cx: $Context$Type, scope: $Scriptable$Type, compiled: any): $Scriptable
public static "newObjectLiteral"(cx: $Context$Type, scope: $Scriptable$Type, propertyIds: (any)[], propertyValues: (any)[], getterSetters: (integer)[]): $Scriptable
public static "setRegExpProxy"(cx: $Context$Type, proxy: $RegExp$Type): void
public static "typeError3"(cx: $Context$Type, messageId: string, arg1: string, arg2: string, arg3: string): $EcmaError
public static "isArrayObject"(obj: any): boolean
public static "throwCustomError"(cx: $Context$Type, scope: $Scriptable$Type, constructorName: string, message: string): $JavaScriptException
public static "storeUint32Result"(cx: $Context$Type, value: long): void
public static "throwError"(cx: $Context$Type, scope: $Scriptable$Type, message: string): $JavaScriptException
public static "lastUint32Result"(cx: $Context$Type): long
public static "escapeString"(s: string): string
public static "escapeString"(s: string, escapeQuote: character): string
public static "typeError"(cx: $Context$Type, message: string): $EcmaError
public static "toInt32"(cx: $Context$Type, val: any): integer
public static "toInt32"(cx: $Context$Type, args: (any)[], index: integer): integer
public static "toInt32"(d: double): integer
public static "toNumber"(cx: $Context$Type, args: (any)[], index: integer): double
public static "toNumber"(cx: $Context$Type, s: string): double
public static "toNumber"(cx: $Context$Type, val: any): double
public static "toPrimitive"(cx: $Context$Type, val: any): any
public static "toPrimitive"(cx: $Context$Type, val: any, typeHint: $Class$Type<(any)>): any
public static "toObject"(cx: $Context$Type, scope: $Scriptable$Type, val: any): $Scriptable
public static "typeErrorThrower"(cx: $Context$Type): $BaseFunction
public static "newObject"(fun: any, cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public static "newObject"(cx: $Context$Type, scope: $Scriptable$Type, constructorName: string, args: (any)[]): $Scriptable
public static "typeof"(cx: $Context$Type, value: any): $MemberType
public static "setBuiltinProtoAndParent"(cx: $Context$Type, scope: $Scriptable$Type, object: $ScriptableObject$Type, type: $TopLevel$Builtins$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptRuntime$Type = ($ScriptRuntime);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptRuntime_ = $ScriptRuntime$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$TimeComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TimeComponent extends $Record implements $RecipeComponent<(long)> {
static readonly "TICKS": $TimeComponent
static readonly "SECONDS": $TimeComponent
static readonly "MINUTES": $TimeComponent
static readonly "DYNAMIC": $DynamicRecipeComponent

constructor(name: string, scale: long)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "scale"(): long
public "write"(recipe: $RecipeJS$Type, value: long): $JsonElement
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(long)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(long)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(long), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(long), (O)>
public "asArray"(): $ArrayRecipeComponent<(long)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (long)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(long)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(long)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(long)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: long, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: long, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(long)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(long)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (long)>)>
public "checkEmpty"(key: $RecipeKey$Type<(long)>, value: long): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: long, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): long
public "replaceInput"(recipe: $RecipeJS$Type, original: long, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): long
public "checkValueHasChanged"(oldValue: long, newValue: long): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(long)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeComponent$Type = ($TimeComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeComponent_ = $TimeComponent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$MapColorHelper" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$MapColor, $MapColor$Type} from "packages/net/minecraft/world/level/material/$MapColor"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapColorHelper extends $Record implements $Function<($BlockState), ($MapColor)> {
static readonly "NAME_MAP": $Map<(string), ($MapColorHelper)>
static readonly "ID_MAP": $Map<(integer), ($MapColorHelper)>
static readonly "NONE": $MapColorHelper

constructor(id: integer, name: string, color: $MapColor$Type, rgb: $Vector3f$Type)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "apply"(blockState: $BlockState$Type): $MapColor
public static "of"(o: any): $MapColor
public "id"(): integer
public static "reverse"(c: $MapColor$Type): $MapColorHelper
public "color"(): $MapColor
public static "findClosest"(rgbi: integer): $MapColorHelper
public "rgb"(): $Vector3f
public static "identity"<T>(): $Function<($BlockState), ($BlockState)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), ($MapColor)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<($BlockState), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapColorHelper$Type = (string) | (number) | ($MapColorHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapColorHelper_ = $MapColorHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$IDFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $IDFilter implements $RecipeFilter {
readonly "id": $ResourceLocation

constructor(i: $ResourceLocation$Type)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDFilter$Type = ($IDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDFilter_ = $IDFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventExit" {
import {$EventResult, $EventResult$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $EventExit extends $Exception {
readonly "result": $EventResult

constructor(result: $EventResult$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventExit$Type = ($EventExit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventExit_ = $EventExit$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$SqFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SqFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SqFuncUnit$Type = ($SqFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SqFuncUnit_ = $SqFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$EmptyFluidStackJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FluidStack, $FluidStack$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$FluidStackJS, $FluidStackJS$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidStackJS"

export class $EmptyFluidStackJS extends $FluidStackJS {
static readonly "INSTANCE": $EmptyFluidStackJS

constructor()

public "equals"(o: any): boolean
public "toString"(): string
public "getId"(): string
public "strongEquals"(o: any): boolean
public "setAmount"(amount: long): void
public "copy"(amount: long): $FluidStackJS
public "hasChance"(): boolean
public "getAmount"(): long
public "setNbt"(nbt: $CompoundTag$Type): void
public "getNbt"(): $CompoundTag
public "getFluidStack"(): $FluidStack
public "getChance"(): double
public "isEmpty"(): boolean
public "getFluid"(): $Fluid
public "setChance"(c: double): void
get "id"(): string
set "amount"(value: long)
get "amount"(): long
set "nbt"(value: $CompoundTag$Type)
get "nbt"(): $CompoundTag
get "fluidStack"(): $FluidStack
get "chance"(): double
get "empty"(): boolean
get "fluid"(): $Fluid
set "chance"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyFluidStackJS$Type = ($EmptyFluidStackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyFluidStackJS_ = $EmptyFluidStackJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ArrowFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $ArrowFunction extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(cx: $Context$Type, scope: $Scriptable$Type, targetFunction: $Callable$Type, boundThis: $Scriptable$Type)

public "toString"(): string
public "getLength"(): integer
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "hasInstance"(cx: $Context$Type, instance: $Scriptable$Type): boolean
public "getArity"(): integer
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrowFunction$Type = ($ArrowFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrowFunction_ = $ArrowFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$NativeRegExpCtor" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeRegExpCtor extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getLength"(): integer
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "getFunctionName"(): string
public "getArity"(): integer
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "functionName"(): string
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeRegExpCtor$Type = ($NativeRegExpCtor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeRegExpCtor_ = $NativeRegExpCtor$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeCall" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeCall extends $IdScriptableObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "defineAttributesForArguments"(cx: $Context$Type): void
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeCall$Type = ($NativeCall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeCall_ = $NativeCall$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$ConstantFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"

export class $ConstantFilter extends $Record implements $RecipeFilter {
static readonly "TRUE": $ConstantFilter
static readonly "FALSE": $ConstantFilter

constructor(filter: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(r: $RecipeKJS$Type): boolean
public "filter"(): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantFilter$Type = ($ConstantFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstantFilter_ = $ConstantFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$Remapper" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export interface $Remapper {

 "getUnmappedClass"(from: string): string
 "getMappedField"(from: $Class$Type<(any)>, field: $Field$Type): string
 "getMappedMethod"(from: $Class$Type<(any)>, method: $Method$Type): string
 "getMappedClass"(from: $Class$Type<(any)>): string
}

export namespace $Remapper {
function getTypeName(type: string): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Remapper$Type = ($Remapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Remapper_ = $Remapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/$KubeJSScreen" {
import {$KubeJSMenu, $KubeJSMenu$Type} from "packages/dev/latvian/mods/kubejs/gui/$KubeJSMenu"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$NarratableEntry, $NarratableEntry$Type} from "packages/net/minecraft/client/gui/narration/$NarratableEntry"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$AbstractContainerScreen, $AbstractContainerScreen$Type} from "packages/net/minecraft/client/gui/screens/inventory/$AbstractContainerScreen"
import {$GuiEventListener, $GuiEventListener$Type} from "packages/net/minecraft/client/gui/components/events/$GuiEventListener"
import {$Screen$DeferredTooltipRendering, $Screen$DeferredTooltipRendering$Type} from "packages/net/minecraft/client/gui/screens/$Screen$DeferredTooltipRendering"
import {$Renderable, $Renderable$Type} from "packages/net/minecraft/client/gui/components/$Renderable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Inventory, $Inventory$Type} from "packages/net/minecraft/world/entity/player/$Inventory"
import {$MenuAccess, $MenuAccess$Type} from "packages/net/minecraft/client/gui/screens/inventory/$MenuAccess"

export class $KubeJSScreen extends $AbstractContainerScreen<($KubeJSMenu)> implements $MenuAccess<($KubeJSMenu)> {
readonly "containerRows": integer
static readonly "INVENTORY_LOCATION": $ResourceLocation
static readonly "SLOT_ITEM_BLIT_OFFSET": integer
 "imageWidth": integer
 "hoveredSlot": $Slot
 "leftPos": integer
 "topPos": integer
static readonly "BACKGROUND_LOCATION": $ResourceLocation
 "title": $Component
readonly "children": $List<($GuiEventListener)>
readonly "narratables": $List<($NarratableEntry)>
 "width": integer
 "height": integer
readonly "renderables": $List<($Renderable)>
 "deferredTooltipRendering": $Screen$DeferredTooltipRendering

constructor(menu: $KubeJSMenu$Type, inventory: $Inventory$Type, component: $Component$Type)

public "render"(guiGraphics: $GuiGraphics$Type, i: integer, j: integer, f: float): void
public "getMenu"(): $KubeJSMenu
get "menu"(): $KubeJSMenu
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSScreen$Type = ($KubeJSScreen);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSScreen_ = $KubeJSScreen$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$DynamicFunction$Callback" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $DynamicFunction$Callback {

 "call"(arg0: (any)[]): any

(arg0: (any)[]): any
}

export namespace $DynamicFunction$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DynamicFunction$Callback$Type = ($DynamicFunction$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DynamicFunction$Callback_ = $DynamicFunction$Callback$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$Copyable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Copyable {

 "copy"(): $Copyable

(): $Copyable
}

export namespace $Copyable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Copyable$Type = ($Copyable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Copyable_ = $Copyable$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$CompoundTagWrapper" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$CustomJavaToJsWrapper, $CustomJavaToJsWrapper$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapper"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $CompoundTagWrapper extends $Record implements $CustomJavaToJsWrapper {

constructor(tag: $CompoundTag$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "tag"(): $CompoundTag
public "convertJavaToJs"(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>): $Scriptable
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompoundTagWrapper$Type = ($CompoundTagWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompoundTagWrapper_ = $CompoundTagWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$EvaluatorException" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export class $EvaluatorException extends $RhinoException {

constructor(cx: $Context$Type, detail: string)
constructor(cx: $Context$Type, detail: string, sourceName: string, lineNumber: integer)
constructor(cx: $Context$Type, detail: string, sourceName: string, lineNumber: integer, lineSource: string, columnNumber: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EvaluatorException$Type = ($EvaluatorException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EvaluatorException_ = $EvaluatorException$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$AstRoot" {
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Comment, $Comment$Type} from "packages/dev/latvian/mods/rhino/ast/$Comment"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $AstRoot extends $ScriptNode {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer)

public "setComments"(comments: $SortedSet$Type<($Comment$Type)>): void
public "getComments"(): $SortedSet<($Comment)>
public "addComment"(comment: $Comment$Type): void
set "comments"(value: $SortedSet$Type<($Comment$Type)>)
get "comments"(): $SortedSet<($Comment)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AstRoot$Type = ($AstRoot);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AstRoot_ = $AstRoot$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$BasicItemJS$Builder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BasicItemJS$Builder extends $ItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicItemJS$Builder$Type = ($BasicItemJS$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicItemJS$Builder_ = $BasicItemJS$Builder$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$MinFuncUnit" {
import {$Func2Unit, $Func2Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func2Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MinFuncUnit extends $Func2Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MinFuncUnit$Type = ($MinFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MinFuncUnit_ = $MinFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Parser" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"
import {$AstRoot, $AstRoot$Type} from "packages/dev/latvian/mods/rhino/ast/$AstRoot"

export class $Parser {
static readonly "ARGC_LIMIT": integer
static readonly "CLEAR_TI_MASK": integer
static readonly "TI_AFTER_EOL": integer
static readonly "TI_CHECK_LABEL": integer

constructor(cx: $Context$Type, compilerEnv: $CompilerEnvirons$Type)
constructor(cx: $Context$Type, compilerEnv: $CompilerEnvirons$Type, errorReporter: $ErrorReporter$Type)
constructor(cx: $Context$Type)

public "parse"(sourceString: string, sourceURI: string, lineno: integer): $AstRoot
public "eof"(): boolean
public "setDefaultUseStrictDirective"(useStrict: boolean): void
public "inUseStrictDirective"(): boolean
set "defaultUseStrictDirective"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Parser$Type = ($Parser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Parser_ = $Parser$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$TickTemporalUnit" {
import {$TemporalUnit, $TemporalUnit$Type} from "packages/java/time/temporal/$TemporalUnit"
import {$Temporal, $Temporal$Type} from "packages/java/time/temporal/$Temporal"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"

export class $TickTemporalUnit implements $TemporalUnit {
static readonly "INSTANCE": $TickTemporalUnit
static readonly "DURATION": $Duration

constructor()

public "toString"(): string
public "between"(temporal1Inclusive: $Temporal$Type, temporal2Exclusive: $Temporal$Type): long
public "isDurationEstimated"(): boolean
public "getDuration"(): $Duration
public "addTo"<R extends $Temporal>(temporal: R, amount: long): R
public "isTimeBased"(): boolean
public "isDateBased"(): boolean
public "isSupportedBy"(arg0: $Temporal$Type): boolean
get "durationEstimated"(): boolean
get "duration"(): $Duration
get "timeBased"(): boolean
get "dateBased"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickTemporalUnit$Type = ($TickTemporalUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickTemporalUnit_ = $TickTemporalUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/platform/$BoilerHeaterHelper" {
import {$BoilerHeaterHandlerEvent$BoilerHeaterCallback, $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type} from "packages/dev/latvian/mods/kubejs/create/events/$BoilerHeaterHandlerEvent$BoilerHeaterCallback"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BoilerHeaterHelper {

constructor()

public static "registerHeaterPlatform"(block: $Block$Type, onUpdate: $BoilerHeaterHandlerEvent$BoilerHeaterCallback$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoilerHeaterHelper$Type = ($BoilerHeaterHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoilerHeaterHelper_ = $BoilerHeaterHelper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$IfStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $IfStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getElseKeyWordInlineComment"(): $AstNode
public "setElseKeyWordInlineComment"(elseKeyWordInlineComment: $AstNode$Type): void
public "setParens"(lp: integer, rp: integer): void
public "setCondition"(condition: $AstNode$Type): void
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "setThenPart"(thenPart: $AstNode$Type): void
public "setElsePart"(elsePart: $AstNode$Type): void
public "setElsePosition"(elsePosition: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "getThenPart"(): $AstNode
public "getElsePart"(): $AstNode
public "getElsePosition"(): integer
public "getCondition"(): $AstNode
get "elseKeyWordInlineComment"(): $AstNode
set "elseKeyWordInlineComment"(value: $AstNode$Type)
set "condition"(value: $AstNode$Type)
set "lp"(value: integer)
set "rp"(value: integer)
set "thenPart"(value: $AstNode$Type)
set "elsePart"(value: $AstNode$Type)
set "elsePosition"(value: integer)
get "lp"(): integer
get "rp"(): integer
get "thenPart"(): $AstNode
get "elsePart"(): $AstNode
get "elsePosition"(): integer
get "condition"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IfStatement$Type = ($IfStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IfStatement_ = $IfStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$TagLoaderKJS" {
import {$ServerScriptManager, $ServerScriptManager$Type} from "packages/dev/latvian/mods/kubejs/server/$ServerScriptManager"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$TagLoader$EntryWithSource, $TagLoader$EntryWithSource$Type} from "packages/net/minecraft/tags/$TagLoader$EntryWithSource"

export interface $TagLoaderKJS<T> {

 "kjs$setRegistry"(arg0: $Registry$Type<(T)>): void
 "kjs$customTags"(ssm: $ServerScriptManager$Type, map: $Map$Type<($ResourceLocation$Type), ($List$Type<($TagLoader$EntryWithSource$Type)>)>): void
 "kjs$getRegistry"(): $Registry<(T)>
}

export namespace $TagLoaderKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagLoaderKJS$Type<T> = ($TagLoaderKJS<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagLoaderKJS_<T> = $TagLoaderKJS$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$GtOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $GtOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GtOpUnit$Type = ($GtOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GtOpUnit_ = $GtOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Name" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"

export class $Name extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, name: string)
constructor(pos: integer, len: integer, name: string)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "length"(): integer
public "toString"(): string
public "getIdentifier"(): string
public "getDefiningScope"(): $Scope
public "setIdentifier"(identifier: string): void
public "setScope"(s: $Scope$Type): void
public "isLocalName"(): boolean
public "getScope"(): $Scope
get "identifier"(): string
get "definingScope"(): $Scope
set "identifier"(value: string)
set "scope"(value: $Scope$Type)
get "localName"(): boolean
get "scope"(): $Scope
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Name$Type = ($Name);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Name_ = $Name$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$MethodDefSignature" {
import {$MojangMappings$TypeDef, $MojangMappings$TypeDef$Type} from "packages/dev/latvian/mods/rhino/mod/util/$MojangMappings$TypeDef"

export class $MojangMappings$MethodDefSignature {
readonly "types": ($MojangMappings$TypeDef)[]
 "occurrences": integer
 "index": integer

constructor(...types: ($MojangMappings$TypeDef$Type)[])

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(other: $MojangMappings$MethodDefSignature$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MojangMappings$MethodDefSignature$Type = ($MojangMappings$MethodDefSignature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MojangMappings$MethodDefSignature_ = $MojangMappings$MethodDefSignature$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$JavaWrapper" {
import {$ScriptManager, $ScriptManager$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptManager"
import {$ConsoleJS, $ConsoleJS$Type} from "packages/dev/latvian/mods/kubejs/util/$ConsoleJS"

/**
 * Methods for working with Java classes. Reflection my beloved 
 */
export class $JavaWrapper {

constructor(manager: $ScriptManager$Type)

/**
 * Loads the specified class, and throws error if class it not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
public "loadClass"(className: string): any
/**
 * Creates a custom ConsoleJS instance for you to use to, well, log stuff
 */
public "createConsole"(name: string): $ConsoleJS
/**
 * Loads the specified class, and returns null if class is not found or allowed.
 * The returned object can have public static methods and fields accessed directly from it.
 * Constructors can be used with the new keyword.
 */
public "tryLoadClass"(className: string): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaWrapper$Type = ($JavaWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaWrapper_ = $JavaWrapper$Type;
}}
declare module "packages/dev/latvian/mods/rhino/annotations/$JSStaticFunction" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JSStaticFunction extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JSStaticFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSStaticFunction$Type = ($JSStaticFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSStaticFunction_ = $JSStaticFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$PlayerEvents" {
import {$Extra, $Extra$Type} from "packages/dev/latvian/mods/kubejs/event/$Extra"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $PlayerEvents {

}

export namespace $PlayerEvents {
const SUPPORTS_MENU_TYPE: $Extra
const GROUP: $EventGroup
const LOGGED_IN: $EventHandler
const LOGGED_OUT: $EventHandler
const RESPAWNED: $EventHandler
const TICK: $EventHandler
const CHAT: $EventHandler
const DECORATE_CHAT: $EventHandler
const ADVANCEMENT: $EventHandler
const INVENTORY_OPENED: $EventHandler
const INVENTORY_CLOSED: $EventHandler
const INVENTORY_CHANGED: $EventHandler
const CHEST_OPENED: $EventHandler
const CHEST_CLOSED: $EventHandler
function transformMenuType(o: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerEvents$Type = ($PlayerEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerEvents_ = $PlayerEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/data/$ExportablePackResources" {
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$Type} from "packages/net/minecraft/server/packs/$PackResources$ResourceOutput"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$Type} from "packages/net/minecraft/server/packs/metadata/$MetadataSectionSerializer"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$PackResources, $PackResources$Type} from "packages/net/minecraft/server/packs/$PackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export interface $ExportablePackResources extends $PackResources {

 "export"(arg0: $Path$Type): void
 "close"(): void
 "getResource"(arg0: $PackType$Type, arg1: $ResourceLocation$Type): $IoSupplier<($InputStream)>
 "listResources"(arg0: $PackType$Type, arg1: string, arg2: string, arg3: $PackResources$ResourceOutput$Type): void
 "getRootResource"(...arg0: (string)[]): $IoSupplier<($InputStream)>
 "isBuiltin"(): boolean
 "packId"(): string
 "getMetadataSection"<T>(arg0: $MetadataSectionSerializer$Type<(T)>): T
 "getNamespaces"(arg0: $PackType$Type): $Set<(string)>
 "isHidden"(): boolean
 "getChildren"(): $Collection<($PackResources)>
}

export namespace $ExportablePackResources {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExportablePackResources$Type = ($ExportablePackResources);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExportablePackResources_ = $ExportablePackResources$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder$Boots" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorItemBuilder$Boots extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "armorTier": $MutableArmorTier
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Boots$Type = ($ArmorItemBuilder$Boots);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Boots_ = $ArmorItemBuilder$Boots$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer$Replacement" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$OutputReplacementTransformer, $OutputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $OutputReplacementTransformer$Replacement extends $Record implements $OutputReplacement {

constructor(arg0: $OutputReplacement$Type, transformer: $OutputReplacementTransformer$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "transformer"(): $OutputReplacementTransformer
public "with"(): $OutputReplacement
public "replaceOutput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $OutputReplacement$Type): any
public static "of"(o: any): $OutputReplacement
public "transform"(transformer: $OutputReplacementTransformer$Type): $OutputReplacementTransformer$Replacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputReplacementTransformer$Replacement$Type = ($OutputReplacementTransformer$Replacement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputReplacementTransformer$Replacement_ = $OutputReplacementTransformer$Replacement$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ElementGet" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ElementGet extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(target: $AstNode$Type, element: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getTarget"(): $AstNode
public "setTarget"(target: $AstNode$Type): void
public "getElement"(): $AstNode
public "setElement"(element: $AstNode$Type): void
public "setParens"(lb: integer, rb: integer): void
public "getLb"(): integer
public "setLb"(lb: integer): void
public "setRb"(rb: integer): void
public "getRb"(): integer
get "target"(): $AstNode
set "target"(value: $AstNode$Type)
get "element"(): $AstNode
set "element"(value: $AstNode$Type)
get "lb"(): integer
set "lb"(value: integer)
set "rb"(value: integer)
get "rb"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ElementGet$Type = ($ElementGet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ElementGet_ = $ElementGet$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/data/$GeneratedResourcePack" {
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$Type} from "packages/net/minecraft/server/packs/$PackResources$ResourceOutput"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$Type} from "packages/net/minecraft/server/packs/metadata/$MetadataSectionSerializer"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ExportablePackResources, $ExportablePackResources$Type} from "packages/dev/latvian/mods/kubejs/script/data/$ExportablePackResources"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"
import {$PackResources, $PackResources$Type} from "packages/net/minecraft/server/packs/$PackResources"
import {$GeneratedData, $GeneratedData$Type} from "packages/dev/latvian/mods/kubejs/script/data/$GeneratedData"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $GeneratedResourcePack implements $ExportablePackResources {

constructor(t: $PackType$Type)

public "close"(): void
public "generate"(map: $Map$Type<($ResourceLocation$Type), ($GeneratedData$Type)>): void
public "export"(root: $Path$Type): void
public "getResource"(type: $PackType$Type, location: $ResourceLocation$Type): $IoSupplier<($InputStream)>
public "getRootResource"(...path: (string)[]): $GeneratedData
public "listResources"(type: $PackType$Type, namespace: string, path: string, visitor: $PackResources$ResourceOutput$Type): void
public "getGenerated"(): $Map<($ResourceLocation), ($GeneratedData)>
public static "scanForInvalidFiles"(pathName: string, path: $Path$Type): void
public "isBuiltin"(): boolean
public "packId"(): string
public "getMetadataSection"<T>(serializer: $MetadataSectionSerializer$Type<(T)>): T
public "getNamespaces"(type: $PackType$Type): $Set<(string)>
public "isHidden"(): boolean
public "getChildren"(): $Collection<($PackResources)>
get "generated"(): $Map<($ResourceLocation), ($GeneratedData)>
get "builtin"(): boolean
get "hidden"(): boolean
get "children"(): $Collection<($PackResources)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedResourcePack$Type = ($GeneratedResourcePack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedResourcePack_ = $GeneratedResourcePack$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeSymbol" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"

export class $NativeSymbol extends $IdScriptableObject implements $Symbol {
static readonly "CLASS_NAME": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(s: $NativeSymbol$Type)

public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "equals"(x: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "init"(cx: $Context$Type, scope: $Scriptable$Type, sealed: boolean): void
public "getClassName"(): string
public static "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $NativeSymbol
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "isSymbol"(): boolean
public "getTypeOf"(): $MemberType
get "className"(): string
get "symbol"(): boolean
get "typeOf"(): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeSymbol$Type = ($NativeSymbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeSymbol_ = $NativeSymbol$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Log1pFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $Log1pFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Log1pFuncUnit$Type = ($Log1pFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Log1pFuncUnit_ = $Log1pFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Interpreter" {
import {$Icode, $Icode$Type} from "packages/dev/latvian/mods/rhino/$Icode"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Evaluator, $Evaluator$Type} from "packages/dev/latvian/mods/rhino/$Evaluator"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ScriptStackElement, $ScriptStackElement$Type} from "packages/dev/latvian/mods/rhino/$ScriptStackElement"
import {$CompilerEnvirons, $CompilerEnvirons$Type} from "packages/dev/latvian/mods/rhino/$CompilerEnvirons"
import {$ScriptNode, $ScriptNode$Type} from "packages/dev/latvian/mods/rhino/ast/$ScriptNode"
import {$Script, $Script$Type} from "packages/dev/latvian/mods/rhino/$Script"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$RhinoException, $RhinoException$Type} from "packages/dev/latvian/mods/rhino/$RhinoException"

export class $Interpreter extends $Icode implements $Evaluator {

constructor()

public "compile"(compilerEnv: $CompilerEnvirons$Type, tree: $ScriptNode$Type, returnFunction: boolean, cx: $Context$Type): any
public "createFunctionObject"(cx: $Context$Type, scope: $Scriptable$Type, bytecode: any, staticSecurityDomain: any): $Function
public "getScriptStackElements"(ex: $RhinoException$Type): (($ScriptStackElement)[])[]
public "getScriptStack"(ex: $RhinoException$Type): $List<(string)>
public static "resumeGenerator"(cx: $Context$Type, scope: $Scriptable$Type, operation: integer, savedState: any, value: any): any
public "captureStackInfo"(cx: $Context$Type, ex: $RhinoException$Type): void
public "getPatchedStack"(ex: $RhinoException$Type, nativeStackTrace: string): string
public "getSourcePositionFromStack"(cx: $Context$Type, linep: (integer)[]): string
public "createScriptObject"(bytecode: any, staticSecurityDomain: any): $Script
public "setEvalScriptFlag"(script: $Script$Type): void
set "evalScriptFlag"(value: $Script$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Interpreter$Type = ($Interpreter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Interpreter_ = $Interpreter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$TryStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$CatchClause, $CatchClause$Type} from "packages/dev/latvian/mods/rhino/ast/$CatchClause"
import {$List, $List$Type} from "packages/java/util/$List"

export class $TryStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setTryBlock"(tryBlock: $AstNode$Type): void
public "setFinallyBlock"(finallyBlock: $AstNode$Type): void
public "setCatchClauses"(catchClauses: $List$Type<($CatchClause$Type)>): void
public "setFinallyPosition"(finallyPosition: integer): void
public "getFinallyPosition"(): integer
public "addCatchClause"(clause: $CatchClause$Type): void
public "getCatchClauses"(): $List<($CatchClause)>
public "getTryBlock"(): $AstNode
public "getFinallyBlock"(): $AstNode
set "tryBlock"(value: $AstNode$Type)
set "finallyBlock"(value: $AstNode$Type)
set "catchClauses"(value: $List$Type<($CatchClause$Type)>)
set "finallyPosition"(value: integer)
get "finallyPosition"(): integer
get "catchClauses"(): $List<($CatchClause)>
get "tryBlock"(): $AstNode
get "finallyBlock"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TryStatement$Type = ($TryStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TryStatement_ = $TryStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$FoodEatenEventJS" {
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EntityEventJS, $EntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * Invoked when an entity eats food.
 */
export class $FoodEatenEventJS extends $EntityEventJS {

constructor(e: $LivingEntity$Type, is: $ItemStack$Type)

/**
 * The food that was eaten.
 */
public "getItem"(): $ItemStack
/**
 * The entity that ate the food.
 */
public "getEntity"(): $Entity
get "item"(): $ItemStack
get "entity"(): $Entity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FoodEatenEventJS$Type = ($FoodEatenEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FoodEatenEventJS_ = $FoodEatenEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachmentHolder" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BlockEntityAttachment$Factory, $BlockEntityAttachment$Factory$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityAttachment$Factory"

export class $BlockEntityAttachmentHolder extends $Record {

constructor(index: integer, factory: $BlockEntityAttachment$Factory$Type)

public "index"(): integer
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "factory"(): $BlockEntityAttachment$Factory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityAttachmentHolder$Type = ($BlockEntityAttachmentHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityAttachmentHolder_ = $BlockEntityAttachmentHolder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$RemapPrefixForJS" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $RemapPrefixForJS extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $RemapPrefixForJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemapPrefixForJS$Type = ($RemapPrefixForJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemapPrefixForJS_ = $RemapPrefixForJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/forge/$KubeJSCreateForge" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSCreateForge {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSCreateForge$Type = ($KubeJSCreateForge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSCreateForge_ = $KubeJSCreateForge$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemTooltipEventJS$StaticTooltipHandler" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ItemTooltipEventJS$StaticTooltipHandler {

 "tooltip"(arg0: $ItemStack$Type, arg1: boolean, arg2: $List$Type<($Component$Type)>): void

(arg0: $ItemStack$Type, arg1: boolean, arg2: $List$Type<($Component$Type)>): void
}

export namespace $ItemTooltipEventJS$StaticTooltipHandler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemTooltipEventJS$StaticTooltipHandler$Type = ($ItemTooltipEventJS$StaticTooltipHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemTooltipEventJS$StaticTooltipHandler_ = $ItemTooltipEventJS$StaticTooltipHandler$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$ConsumeAction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConsumeAction extends $IngredientAction {
static readonly "FACTORY_MAP": $Map<(string), ($Function<($JsonObject), ($IngredientAction)>)>
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor()

public "transform"(old: $ItemStack$Type, index: integer, container: $CraftingContainer$Type): $ItemStack
public "getType"(): string
get "type"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsumeAction$Type = ($ConsumeAction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsumeAction_ = $ConsumeAction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$WrapFactory" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $WrapFactory {

constructor()

public "wrap"(cx: $Context$Type, scope: $Scriptable$Type, obj: any, staticType: $Class$Type<(any)>): any
public "wrapNewObject"(scope: $Scriptable$Type, obj: any, cx: $Context$Type): $Scriptable
public "wrapJavaClass"(cx: $Context$Type, scope: $Scriptable$Type, javaClass: $Class$Type<(any)>): $Scriptable
public "wrapAsJavaObject"(cx: $Context$Type, scope: $Scriptable$Type, javaObject: any, staticType: $Class$Type<(any)>): $Scriptable
public "setJavaPrimitiveWrap"(value: boolean): void
public "isJavaPrimitiveWrap"(): boolean
set "javaPrimitiveWrap"(value: boolean)
get "javaPrimitiveWrap"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrapFactory$Type = ($WrapFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrapFactory_ = $WrapFactory$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$RotationAxis" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Vector3f, $Vector3f$Type} from "packages/org/joml/$Vector3f"
import {$Quaternionf, $Quaternionf$Type} from "packages/org/joml/$Quaternionf"

export class $RotationAxis extends $Enum<($RotationAxis)> {
static readonly "XN": $RotationAxis
static readonly "XP": $RotationAxis
static readonly "YN": $RotationAxis
static readonly "YP": $RotationAxis
static readonly "ZN": $RotationAxis
static readonly "ZP": $RotationAxis
readonly "vec": $Vector3f


public static "values"(): ($RotationAxis)[]
public static "valueOf"(name: string): $RotationAxis
public "deg"(f: float): $Quaternionf
public "rad"(f: float): $Quaternionf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RotationAxis$Type = (("zn") | ("yn") | ("xn") | ("zp") | ("yp") | ("xp")) | ($RotationAxis);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RotationAxis_ = $RotationAxis$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/typings/$Param" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $Param extends $Annotation {

 "name"(): string
 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $Param {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Param$Type = ($Param);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Param_ = $Param$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/$RecipeForgeHelper" {
import {$RecipePlatformHelper, $RecipePlatformHelper$Type} from "packages/dev/latvian/mods/kubejs/platform/$RecipePlatformHelper"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"

export class $RecipeForgeHelper implements $RecipePlatformHelper {
static readonly "FORGE_CONDITIONAL": string

constructor()

public "fromJson"(serializer: $RecipeSerializer$Type<(any)>, id: $ResourceLocation$Type, json: $JsonObject$Type): $Recipe<(any)>
public "getCustomIngredient"(object: $JsonObject$Type): $Ingredient
public "pingNewRecipes"(map: $Map$Type<($RecipeType$Type<(any)>), ($Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>)>): void
public "processConditions"(recipeManager: $RecipeManager$Type, json: $JsonObject$Type): boolean
public "createRecipeContext"(resources: $ReloadableServerResources$Type): any
public "checkConditions"(json: $JsonObject$Type): $JsonObject
public static "get"(): $RecipePlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeForgeHelper$Type = ($RecipeForgeHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeForgeHelper_ = $RecipeForgeHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$BasicBlockJS$Builder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $BasicBlockJS$Builder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicBlockJS$Builder$Type = ($BasicBlockJS$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicBlockJS$Builder_ = $BasicBlockJS$Builder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$RhinoProperties" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $RhinoProperties extends $Enum<($RhinoProperties)> {
static readonly "INSTANCE": $RhinoProperties


public static "values"(): ($RhinoProperties)[]
public static "valueOf"(name: string): $RhinoProperties
public static "isDev"(): boolean
public static "getGameDir"(): $Path
public static "openResource"(path: string): $InputStream
get "dev"(): boolean
get "gameDir"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RhinoProperties$Type = (("instance")) | ($RhinoProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RhinoProperties_ = $RhinoProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$CustomStatBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $CustomStatBuilder extends $BuilderBase<($ResourceLocation)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomStatBuilder$Type = ($CustomStatBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomStatBuilder_ = $CustomStatBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IteratorLikeIterable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $IteratorLikeIterable implements $Iterable<(any)>, $Closeable {

constructor(cx: $Context$Type, scope: $Scriptable$Type, target: any)

public "close"(): void
public "spliterator"(): $Spliterator<(any)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IteratorLikeIterable$Type = ($IteratorLikeIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IteratorLikeIterable_ = $IteratorLikeIterable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ConsoleJS" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConsoleLine, $ConsoleLine$Type} from "packages/dev/latvian/mods/kubejs/script/$ConsoleLine"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$LogType, $LogType$Type} from "packages/dev/latvian/mods/kubejs/util/$LogType"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Logger, $Logger$Type} from "packages/org/slf4j/$Logger"

export class $ConsoleJS {
static "STARTUP": $ConsoleJS
static "SERVER": $ConsoleJS
static "CLIENT": $ConsoleJS
readonly "scriptType": $ScriptType

constructor(m: $ScriptType$Type, log: $Logger$Type)

public "group"(): void
public "log"(...message: (any)[]): void
public "flush"(sync: boolean): void
public "info"(message: any): $ConsoleLine
public "getLogger"(): $Logger
public "trace"(): void
public "debug"(message: any): $ConsoleLine
public "error"(message: string, error: $Throwable$Type, exitPattern: $Pattern$Type): $ConsoleLine
public "error"(message: string, throwable: $Throwable$Type): $ConsoleLine
public "error"(message: any): $ConsoleLine
public "warn"(message: string, error: $Throwable$Type): $ConsoleLine
public "warn"(message: string, error: $Throwable$Type, exitPattern: $Pattern$Type): $ConsoleLine
public "warn"(message: any): $ConsoleLine
public "groupEnd"(): void
public "writeToFile"(type: $LogType$Type, line: string): void
public "writeToFile"(type: $LogType$Type, timestamp: long, line: string): void
public "resetFile"(): void
public "errorsComponent"(command: string): $Component
public "printObject"(o: any, tree: boolean): void
public "printObject"(o: any): void
public "handleError"(line: $ConsoleLine$Type, error: $Throwable$Type, exitPattern: $Pattern$Type, print: boolean): void
public static "getCurrent"(cx: $Context$Type): $ConsoleJS
public static "getCurrent"(def: $ConsoleJS$Type): $ConsoleJS
public "setMuted"(m: boolean): void
public "getMuted"(): boolean
public "setDebugEnabled"(m: boolean): void
public "errorf"(message: string, ...args: (any)[]): $ConsoleLine
public "shouldPrintDebug"(): boolean
public "debugf"(message: string, ...args: (any)[]): $ConsoleLine
public "warnf"(message: string, ...args: (any)[]): $ConsoleLine
public "setWriteToFile"(m: boolean): void
public "getDebugEnabled"(): boolean
public "getWriteToFile"(): boolean
public "infof"(message: string, ...args: (any)[]): $ConsoleLine
public "printClass"(className: string): void
public "printClass"(className: string, tree: boolean): void
public "getScriptLine"(): integer
public "setCapturingErrors"(enabled: boolean): void
get "logger"(): $Logger
set "muted"(value: boolean)
get "muted"(): boolean
set "debugEnabled"(value: boolean)
get "debugEnabled"(): boolean
get "scriptLine"(): integer
set "capturingErrors"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsoleJS$Type = ($ConsoleJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsoleJS_ = $ConsoleJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Token$CommentType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Token$CommentType extends $Enum<($Token$CommentType)> {
static readonly "LINE": $Token$CommentType
static readonly "BLOCK_COMMENT": $Token$CommentType
static readonly "JSDOC": $Token$CommentType
static readonly "HTML": $Token$CommentType


public static "values"(): ($Token$CommentType)[]
public static "valueOf"(name: string): $Token$CommentType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Token$CommentType$Type = (("jsdoc") | ("line") | ("block_comment") | ("html")) | ($Token$CommentType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Token$CommentType_ = $Token$CommentType$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$AndFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $AndFilter extends $Record implements $BiomeFilter {

constructor(list: $List$Type<($BiomeFilter$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "list"(): $List<($BiomeFilter)>
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndFilter$Type = ($AndFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndFilter_ = $AndFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$Label" {
import {$Jump, $Jump$Type} from "packages/dev/latvian/mods/rhino/ast/$Jump"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $Label extends $Jump {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, name: string)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getName"(): string
public "toString"(): string
public "setName"(name: string): void
get "name"(): string
set "name"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Label$Type = ($Label);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Label_ = $Label$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$NBTSerializable" {
import {$Tag, $Tag$Type} from "packages/net/minecraft/nbt/$Tag"

export interface $NBTSerializable {

 "toNBT"(): $Tag

(): $Tag
}

export namespace $NBTSerializable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTSerializable$Type = ($NBTSerializable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTSerializable_ = $NBTSerializable$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$FieldAndMethods" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$NativeJavaMethod, $NativeJavaMethod$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaMethod"

export class $FieldAndMethods extends $NativeJavaMethod {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getDefaultValue"(cx: $Context$Type, hint: $Class$Type<(any)>): any
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldAndMethods$Type = ($FieldAndMethods);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldAndMethods_ = $FieldAndMethods$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$StackTraceCollector" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$PrintStream, $PrintStream$Type} from "packages/java/io/$PrintStream"

export class $StackTraceCollector extends $PrintStream {

constructor(stackTrace: $Collection$Type<(string)>, exitPattern: $Pattern$Type, reduce: $Function$Type<(string), (string)>)

public "println"(x: string): void
public "println"(x: any): void
public "print"(s: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackTraceCollector$Type = ($StackTraceCollector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackTraceCollector_ = $StackTraceCollector$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$MutedError" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $MutedError {

 "isMuted"(): boolean
}

export namespace $MutedError {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutedError$Type = ($MutedError);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutedError_ = $MutedError$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$ProcessingRecipeSchema$ProcessingRecipeJS" {
import {$InputFluid, $InputFluid$Type} from "packages/dev/latvian/mods/kubejs/fluid/$InputFluid"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export class $ProcessingRecipeSchema$ProcessingRecipeJS extends $RecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "inputFluidHasPriority"(from: any): boolean
public "inputItemHasPriority"(from: any): boolean
public "superheated"(): $RecipeJS
public "heated"(): $RecipeJS
public "heatLevel"(arg0: string): $RecipeJS
public "readInputFluid"(from: any): $InputFluid
public "writeInputFluid"(value: $InputFluid$Type): $JsonElement
public "readOutputItem"(from: any): $OutputItem
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipeSchema$ProcessingRecipeJS$Type = ($ProcessingRecipeSchema$ProcessingRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProcessingRecipeSchema$ProcessingRecipeJS_ = $ProcessingRecipeSchema$ProcessingRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$MemberBox" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MemberBox {


public "toString"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MemberBox$Type = ($MemberBox);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MemberBox_ = $MemberBox$Type;
}}
declare module "packages/dev/latvian/mods/rhino/v8dtoa/$DoubleConversion" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $DoubleConversion {


public static "doubleToInt32"(x: double): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleConversion$Type = ($DoubleConversion);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleConversion_ = $DoubleConversion$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$BasicBlockJS" {
import {$LevelAccessor, $LevelAccessor$Type} from "packages/net/minecraft/world/level/$LevelAccessor"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$BlockBehaviour$Properties, $BlockBehaviour$Properties$Type} from "packages/net/minecraft/world/level/block/state/$BlockBehaviour$Properties"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$SimpleWaterloggedBlock, $SimpleWaterloggedBlock$Type} from "packages/net/minecraft/world/level/block/$SimpleWaterloggedBlock"
import {$IdMapper, $IdMapper$Type} from "packages/net/minecraft/core/$IdMapper"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MutableComponent, $MutableComponent$Type} from "packages/net/minecraft/network/chat/$MutableComponent"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$BlockGetter, $BlockGetter$Type} from "packages/net/minecraft/world/level/$BlockGetter"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$BlockHitResult, $BlockHitResult$Type} from "packages/net/minecraft/world/phys/$BlockHitResult"
import {$RandomSource, $RandomSource$Type} from "packages/net/minecraft/util/$RandomSource"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$VoxelShape, $VoxelShape$Type} from "packages/net/minecraft/world/phys/shapes/$VoxelShape"
import {$CollisionContext, $CollisionContext$Type} from "packages/net/minecraft/world/phys/shapes/$CollisionContext"
import {$InteractionResult, $InteractionResult$Type} from "packages/net/minecraft/world/$InteractionResult"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockKJS, $BlockKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$BlockKJS"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"

export class $BasicBlockJS extends $Block implements $BlockKJS, $SimpleWaterloggedBlock {
readonly "blockBuilder": $BlockBuilder
readonly "shape": $VoxelShape
/**
 * 
 * @deprecated
 */
static readonly "BLOCK_STATE_REGISTRY": $IdMapper<($BlockState)>
static readonly "UPDATE_NEIGHBORS": integer
static readonly "UPDATE_CLIENTS": integer
static readonly "UPDATE_INVISIBLE": integer
static readonly "UPDATE_IMMEDIATE": integer
static readonly "UPDATE_KNOWN_SHAPE": integer
static readonly "UPDATE_SUPPRESS_DROPS": integer
static readonly "UPDATE_MOVE_BY_PISTON": integer
static readonly "UPDATE_NONE": integer
static readonly "UPDATE_ALL": integer
static readonly "UPDATE_ALL_IMMEDIATE": integer
static readonly "INDESTRUCTIBLE": float
static readonly "INSTANT": float
static readonly "UPDATE_LIMIT": integer
 "descriptionId": string
 "properties": $BlockBehaviour$Properties
 "drops": $ResourceLocation

constructor(p: $BlockBuilder$Type)

public "isRandomlyTicking"(state: $BlockState$Type): boolean
public "propagatesSkylightDown"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): boolean
public "wasExploded"(level: $Level$Type, blockPos: $BlockPos$Type, explosion: $Explosion$Type): void
public "getStateForPlacement"(context: $BlockPlaceContext$Type): $BlockState
public "setPlacedBy"(level: $Level$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type, livingEntity: $LivingEntity$Type, itemStack: $ItemStack$Type): void
public "getName"(): $MutableComponent
public "getBlockBuilder"(): $BlockBuilder
public "updateEntityAfterFallOn"(blockGetter: $BlockGetter$Type, entity: $Entity$Type): void
public "stepOn"(level: $Level$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type, entity: $Entity$Type): void
public "fallOn"(level: $Level$Type, blockState: $BlockState$Type, blockPos: $BlockPos$Type, entity: $Entity$Type, f: float): void
/**
 * 
 * @deprecated
 */
public "skipRendering"(state: $BlockState$Type, state2: $BlockState$Type, direction: $Direction$Type): boolean
/**
 * 
 * @deprecated
 */
public "updateShape"(state: $BlockState$Type, facing: $Direction$Type, facingState: $BlockState$Type, world: $LevelAccessor$Type, pos: $BlockPos$Type, facingPos: $BlockPos$Type): $BlockState
public "use"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, player: $Player$Type, hand: $InteractionHand$Type, hit: $BlockHitResult$Type): $InteractionResult
public "onRemove"(state: $BlockState$Type, level: $Level$Type, pos: $BlockPos$Type, newState: $BlockState$Type, bl: boolean): void
/**
 * 
 * @deprecated
 */
public "getFluidState"(state: $BlockState$Type): $FluidState
public "canBeReplaced"(blockState: $BlockState$Type, context: $BlockPlaceContext$Type): boolean
public "rotate"(blockState: $BlockState$Type, rotation: $Rotation$Type): $BlockState
public "mirror"(blockState: $BlockState$Type, mirror: $Mirror$Type): $BlockState
/**
 * 
 * @deprecated
 */
public "getShadeBrightness"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type): float
/**
 * 
 * @deprecated
 */
public "getVisualShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, ctx: $CollisionContext$Type): $VoxelShape
/**
 * 
 * @deprecated
 */
public "randomTick"(state: $BlockState$Type, level: $ServerLevel$Type, pos: $BlockPos$Type, random: $RandomSource$Type): void
/**
 * 
 * @deprecated
 */
public "getShape"(state: $BlockState$Type, level: $BlockGetter$Type, pos: $BlockPos$Type, context: $CollisionContext$Type): $VoxelShape
public "getPickupSound"(): $Optional<($SoundEvent)>
public "canPlaceLiquid"(blockGetter: $BlockGetter$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type, fluid: $Fluid$Type): boolean
public "placeLiquid"(levelAccessor: $LevelAccessor$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type, fluidState: $FluidState$Type): boolean
public "pickupBlock"(levelAccessor: $LevelAccessor$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type): $ItemStack
public "setNameKey"(key: string): void
public "setBlockBuilder"(b: $BlockBuilder$Type): void
public "setIsRandomlyTicking"(v: boolean): void
public "setHasCollision"(v: boolean): void
public "setExplosionResistance"(v: float): void
public "setRandomTickCallback"(callback: $Consumer$Type<($RandomTickCallbackJS$Type)>): void
public "getIdLocation"(): $ResourceLocation
public "getId"(): string
public "setSpeedFactor"(v: float): void
public "setJumpFactor"(v: float): void
public "setSoundType"(v: $SoundType$Type): void
public "setFriction"(v: float): void
public "getTypeData"(): $CompoundTag
public "getPickupSound"(arg0: $BlockState$Type): $Optional<($SoundEvent)>
get "name"(): $MutableComponent
get "blockBuilder"(): $BlockBuilder
get "pickupSound"(): $Optional<($SoundEvent)>
set "nameKey"(value: string)
set "blockBuilder"(value: $BlockBuilder$Type)
set "hasCollision"(value: boolean)
set "explosionResistance"(value: float)
set "randomTickCallback"(value: $Consumer$Type<($RandomTickCallbackJS$Type)>)
get "idLocation"(): $ResourceLocation
get "id"(): string
set "speedFactor"(value: float)
set "jumpFactor"(value: float)
set "soundType"(value: $SoundType$Type)
set "friction"(value: float)
get "typeData"(): $CompoundTag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicBlockJS$Type = ($BasicBlockJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicBlockJS_ = $BasicBlockJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$TagKeyComponent" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$TagKey, $TagKey$Type} from "packages/net/minecraft/tags/$TagKey"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TagKeyComponent<T> extends $Record implements $RecipeComponent<($TagKey<(T)>)> {
static readonly "BLOCK": $RecipeComponent<($TagKey<($Block)>)>
static readonly "ITEM": $RecipeComponent<($TagKey<($Item)>)>
static readonly "ENTITY_TYPE": $RecipeComponent<($TagKey<($EntityType<(any)>)>)>
static readonly "BIOME": $RecipeComponent<($TagKey<($Biome)>)>
static readonly "FLUID": $RecipeComponent<($TagKey<($Fluid)>)>
static readonly "DYNAMIC": $DynamicRecipeComponent

constructor(registry: $ResourceKey$Type<(any)>, registryType: $Class$Type<(any)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: $TagKey$Type<(T)>): $JsonPrimitive
public "registryType"(): $Class<(any)>
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "registry"(): $ResourceKey<(any)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($TagKey<(T)>)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($TagKey<(T)>)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($TagKey<(T)>), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($TagKey<(T)>), (O)>
public "asArray"(): $ArrayRecipeComponent<($TagKey<(T)>)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($TagKey<(T)>)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($TagKey<(T)>)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($TagKey<(T)>)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TagKey$Type<(T)>)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TagKey$Type<(T)>)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TagKey$Type<(T)>)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: $TagKey$Type<(T)>, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $TagKey$Type<(T)>, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<($TagKey<(T)>)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($TagKey<(T)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($TagKey<(T)>)>)>
public "checkEmpty"(key: $RecipeKey$Type<($TagKey$Type<(T)>)>, value: $TagKey$Type<(T)>): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: $TagKey$Type<(T)>, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $TagKey<(T)>
public "replaceInput"(recipe: $RecipeJS$Type, original: $TagKey$Type<(T)>, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $TagKey<(T)>
public "checkValueHasChanged"(oldValue: $TagKey$Type<(T)>, newValue: $TagKey$Type<(T)>): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($TagKey<(T)>)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagKeyComponent$Type<T> = ($TagKeyComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagKeyComponent_<T> = $TagKeyComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$KubeJSPlugins" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KubeJSPlugin, $KubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSPlugin"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClassFilter, $ClassFilter$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassFilter"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$Mod, $Mod$Type} from "packages/dev/architectury/platform/$Mod"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $KubeJSPlugins {

constructor()

public static "load"(mods: $List$Type<($Mod$Type)>, loadClientPlugins: boolean): void
public static "getAll"(): $List<($KubeJSPlugin)>
public static "addSidedBindings"(event: $BindingsEvent$Type): void
public static "createClassFilter"(type: $ScriptType$Type): $ClassFilter
public static "forEachPlugin"(callback: $Consumer$Type<($KubeJSPlugin$Type)>): void
public static "forEachPlugin"<T>(instance: T, callback: $BiConsumer$Type<($KubeJSPlugin$Type), (T)>): void
get "all"(): $List<($KubeJSPlugin)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSPlugins$Type = ($KubeJSPlugins);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSPlugins_ = $KubeJSPlugins$Type;
}}
declare module "packages/dev/latvian/mods/unit/$UnitContext" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $UnitContext {
static readonly "DEFAULT": $UnitContext
readonly "constants": $Map<(string), ($Unit)>

constructor()

public "isDebug"(): boolean
public "parse"(input: string): $Unit
public "sub"(): $UnitContext
public "addConstant"(s: string, u: $Unit$Type): void
public "getFunctionFactory"(name: string): $FunctionFactory
public "createStream"(input: string): $UnitTokenStream
public "pushDebug"(): void
public "popDebug"(): void
public "addFunction"(factory: $FunctionFactory$Type): void
public "debugInfo"(s: string, values: $Collection$Type<(any)>): void
public "debugInfo"(s: string): void
get "debug"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnitContext$Type = ($UnitContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnitContext_ = $UnitContext$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$ExplosionEventJS$After" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ExplosionEventJS, $ExplosionEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$ExplosionEventJS"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"

/**
 * Invoked right after an explosion happens.
 */
export class $ExplosionEventJS$After extends $ExplosionEventJS {

constructor(level: $Level$Type, explosion: $Explosion$Type, affectedEntities: $List$Type<($Entity$Type)>)

/**
 * Gets a list of all blocks affected by the explosion.
 */
public "getAffectedBlocks"(): $List<($BlockContainerJS)>
/**
 * Remove a block from the list of affected blocks.
 */
public "removeAffectedBlock"(block: $BlockContainerJS$Type): void
/**
 * Remove all blocks from the list of affected blocks.
 */
public "removeAllAffectedBlocks"(): void
/**
 * Remove an entity from the list of affected entities.
 */
public "removeAffectedEntity"(entity: $Entity$Type): void
/**
 * Remove all entities from the list of affected entities.
 */
public "removeAllAffectedEntities"(): void
/**
 * Remove all knockback from all affected *players*.
 */
public "removeKnockback"(): void
/**
 * Gets a list of all entities affected by the explosion.
 */
public "getAffectedEntities"(): $EntityArrayList
get "affectedBlocks"(): $List<($BlockContainerJS)>
get "affectedEntities"(): $EntityArrayList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEventJS$After$Type = ($ExplosionEventJS$After);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEventJS$After_ = $ExplosionEventJS$After$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$AndOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $AndOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndOpUnit$Type = ($AndOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndOpUnit_ = $AndOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$AtanFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $AtanFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AtanFuncUnit$Type = ($AtanFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AtanFuncUnit_ = $AtanFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey" {
import {$RecipeOptional, $RecipeOptional$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeOptional"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"

export class $RecipeKey<T> {
readonly "component": $RecipeComponent<(T)>
readonly "name": string
readonly "names": $Set<(string)>
 "preferred": string
 "optional": $RecipeOptional<(T)>
 "excluded": boolean
 "noBuilders": boolean
 "allowEmpty": boolean
 "alwaysWrite": boolean

constructor(component: $RecipeComponent$Type<(T)>, name: string)

public "toString"(): string
public "hashCode"(): integer
public "optional"(): boolean
public "optional"(value: $RecipeOptional$Type<(T)>): $RecipeKey<(T)>
public "optional"(value: T): $RecipeKey<(T)>
public "alt"(...names: (string)[]): $RecipeKey<(T)>
public "alt"(name: string): $RecipeKey<(T)>
public "allowEmpty"(): $RecipeKey<(T)>
public "exclude"(): $RecipeKey<(T)>
public "noBuilders"(): $RecipeKey<(T)>
public "alwaysWrite"(): $RecipeKey<(T)>
public "defaultOptional"(): $RecipeKey<(T)>
public "preferred"(name: string): $RecipeKey<(T)>
public "includeInAutoConstructors"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeKey$Type<T> = ($RecipeKey<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeKey_<T> = $RecipeKey$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/unit/token/$FunctionUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $FunctionUnitToken extends $Record implements $UnitToken {

constructor(name: string, args: $List$Type<($UnitToken$Type)>)

public "name"(): string
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "args"(): $List<($UnitToken)>
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionUnitToken$Type = ($FunctionUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionUnitToken_ = $FunctionUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$SwordItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$HandheldItemBuilder, $HandheldItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$HandheldItemBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SwordItemBuilder extends $HandheldItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwordItemBuilder$Type = ($SwordItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SwordItemBuilder_ = $SwordItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/loot/$ConditionalFunction" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ConditionContainer, $ConditionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$ConditionContainer"
import {$JsonArray, $JsonArray$Type} from "packages/com/google/gson/$JsonArray"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FunctionContainer, $FunctionContainer$Type} from "packages/dev/latvian/mods/kubejs/loot/$FunctionContainer"
import {$CopyNameFunction$NameSource, $CopyNameFunction$NameSource$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$CopyNameFunction$NameSource"
import {$NumberProvider, $NumberProvider$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$NumberProvider"
import {$LootContext$EntityTarget, $LootContext$EntityTarget$Type} from "packages/net/minecraft/world/level/storage/loot/$LootContext$EntityTarget"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ConditionalFunction implements $FunctionContainer, $ConditionContainer {
 "function": $JsonObject
 "conditions": $JsonArray

constructor()

public "name"(name: $Component$Type): $FunctionContainer
public "name"(name: $Component$Type, entity: $LootContext$EntityTarget$Type): $FunctionContainer
public "count"(count: $NumberProvider$Type): $FunctionContainer
public "damage"(damage: $NumberProvider$Type): $FunctionContainer
public "nbt"(tag: $CompoundTag$Type): $FunctionContainer
public "addConditionalFunction"(func: $Consumer$Type<($ConditionalFunction$Type)>): $FunctionContainer
public "furnaceSmelt"(): $FunctionContainer
public "copyName"(source: $CopyNameFunction$NameSource$Type): $FunctionContainer
public "lootingEnchant"(count: $NumberProvider$Type, limit: integer): $FunctionContainer
public "enchantWithLevels"(levels: $NumberProvider$Type, treasure: boolean): $FunctionContainer
public "enchantRandomly"(enchantments: ($ResourceLocation$Type)[]): $FunctionContainer
public "lootTable"(table: $ResourceLocation$Type, seed: long): $FunctionContainer
public "survivesExplosion"(): $ConditionContainer
public "randomChance"(chance: double): $ConditionContainer
public "randomChanceWithLooting"(chance: double, multiplier: double): $ConditionContainer
public "entityScores"(entity: $LootContext$EntityTarget$Type, scores: $Map$Type<(string), (any)>): $ConditionContainer
public "entityProperties"(entity: $LootContext$EntityTarget$Type, properties: $JsonObject$Type): $ConditionContainer
public "killedByPlayer"(): $ConditionContainer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConditionalFunction$Type = ($ConditionalFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConditionalFunction_ = $ConditionalFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/color/$NoColor" {
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export class $NoColor implements $Color {

constructor()

public "createTextColorJS"(): $TextColor
public "getArgbJS"(): integer
public "getRgbJS"(): integer
public "getSerializeJS"(): string
public "getHexJS"(): string
public "getFireworkColorJS"(): integer
public "specialEquals"(o: any, shallow: boolean): boolean
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
get "argbJS"(): integer
get "rgbJS"(): integer
get "serializeJS"(): string
get "hexJS"(): string
get "fireworkColorJS"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NoColor$Type = ($NoColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NoColor_ = $NoColor$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$SeedItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$BlockItemBuilder, $BlockItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockItemBuilder"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SeedItemBuilder extends $BlockItemBuilder {
 "blockBuilder": $BlockBuilder
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "getTranslationKeyGroup"(): string
get "translationKeyGroup"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SeedItemBuilder$Type = ($SeedItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SeedItemBuilder_ = $SeedItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ArrayComprehension" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$ArrayComprehensionLoop, $ArrayComprehensionLoop$Type} from "packages/dev/latvian/mods/rhino/ast/$ArrayComprehensionLoop"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"

export class $ArrayComprehension extends $Scope {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setResult"(result: $AstNode$Type): void
public "getFilter"(): $AstNode
public "setFilter"(filter: $AstNode$Type): void
public "getResult"(): $AstNode
public "setIfPosition"(ifPosition: integer): void
public "setFilterRp"(rp: integer): void
public "setLoops"(loops: $List$Type<($ArrayComprehensionLoop$Type)>): void
public "setFilterLp"(lp: integer): void
public "getFilterLp"(): integer
public "getIfPosition"(): integer
public "getFilterRp"(): integer
public "getLoops"(): $List<($ArrayComprehensionLoop)>
public "addLoop"(acl: $ArrayComprehensionLoop$Type): void
set "result"(value: $AstNode$Type)
get "filter"(): $AstNode
set "filter"(value: $AstNode$Type)
get "result"(): $AstNode
set "ifPosition"(value: integer)
set "filterRp"(value: integer)
set "loops"(value: $List$Type<($ArrayComprehensionLoop$Type)>)
set "filterLp"(value: integer)
get "filterLp"(): integer
get "ifPosition"(): integer
get "filterRp"(): integer
get "loops"(): $List<($ArrayComprehensionLoop)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayComprehension$Type = ($ArrayComprehension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayComprehension_ = $ArrayComprehension$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/command/$CommandRegistryEventJS" {
import {$ClassWrapper, $ClassWrapper$Type} from "packages/dev/latvian/mods/kubejs/util/$ClassWrapper"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$LiteralCommandNode, $LiteralCommandNode$Type} from "packages/com/mojang/brigadier/tree/$LiteralCommandNode"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$LiteralArgumentBuilder, $LiteralArgumentBuilder$Type} from "packages/com/mojang/brigadier/builder/$LiteralArgumentBuilder"
import {$ArgumentTypeWrappers, $ArgumentTypeWrappers$Type} from "packages/dev/latvian/mods/kubejs/command/$ArgumentTypeWrappers"
import {$CommandBuildContext, $CommandBuildContext$Type} from "packages/net/minecraft/commands/$CommandBuildContext"
import {$Commands$CommandSelection, $Commands$CommandSelection$Type} from "packages/net/minecraft/commands/$Commands$CommandSelection"
import {$CommandDispatcher, $CommandDispatcher$Type} from "packages/com/mojang/brigadier/$CommandDispatcher"
import {$Commands, $Commands$Type} from "packages/net/minecraft/commands/$Commands"
import {$SharedSuggestionProvider, $SharedSuggestionProvider$Type} from "packages/net/minecraft/commands/$SharedSuggestionProvider"

export class $CommandRegistryEventJS extends $EventJS {
readonly "dispatcher": $CommandDispatcher<($CommandSourceStack)>
readonly "context": $CommandBuildContext
readonly "selection": $Commands$CommandSelection

constructor(dispatcher: $CommandDispatcher$Type<($CommandSourceStack$Type)>, context: $CommandBuildContext$Type, selection: $Commands$CommandSelection$Type)

public "register"(command: $LiteralArgumentBuilder$Type<($CommandSourceStack$Type)>): $LiteralCommandNode<($CommandSourceStack)>
public "getCommands"(): $ClassWrapper<($Commands)>
public "getArguments"(): $ClassWrapper<($ArgumentTypeWrappers)>
public "getBuiltinSuggestions"(): $ClassWrapper<($SharedSuggestionProvider)>
public "isForMultiPlayer"(): boolean
public "isForSinglePlayer"(): boolean
public "getRegistry"(): $CommandBuildContext
get "commands"(): $ClassWrapper<($Commands)>
get "arguments"(): $ClassWrapper<($ArgumentTypeWrappers)>
get "builtinSuggestions"(): $ClassWrapper<($SharedSuggestionProvider)>
get "forMultiPlayer"(): boolean
get "forSinglePlayer"(): boolean
get "registry"(): $CommandBuildContext
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandRegistryEventJS$Type = ($CommandRegistryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandRegistryEventJS_ = $CommandRegistryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$OutputFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $OutputFilter implements $RecipeFilter {

constructor(match: $ReplacementMatch$Type)

public "toString"(): string
public "test"(r: $RecipeKJS$Type): boolean
public static "of"(cx: $Context$Type, o: any): $RecipeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public "negate"(): $Predicate<($RecipeKJS)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
public static "isEqual"<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OutputFilter$Type = ($OutputFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OutputFilter_ = $OutputFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$KubeJSRuleTests" {
import {$AnyMatchRuleTest, $AnyMatchRuleTest$Type} from "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AnyMatchRuleTest"
import {$RuleTestType, $RuleTestType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTestType"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$InvertRuleTest, $InvertRuleTest$Type} from "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$InvertRuleTest"
import {$AllMatchRuleTest, $AllMatchRuleTest$Type} from "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AllMatchRuleTest"
import {$DeferredRegister, $DeferredRegister$Type} from "packages/dev/architectury/registry/registries/$DeferredRegister"
import {$AlwaysFalseRuleTest, $AlwaysFalseRuleTest$Type} from "packages/dev/latvian/mods/kubejs/level/gen/ruletest/$AlwaysFalseRuleTest"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"

export interface $KubeJSRuleTests {

}

export namespace $KubeJSRuleTests {
const RULE_TEST_TYPES: $DeferredRegister<($RuleTestType<(any)>)>
const INVERT: $RuleTestType<($InvertRuleTest)>
const ALWAYS_FALSE: $RuleTestType<($AlwaysFalseRuleTest)>
const ALL_MATCH: $RuleTestType<($AllMatchRuleTest)>
const ANY_MATCH: $RuleTestType<($AnyMatchRuleTest)>
function register<P>(id: string, codec: $Codec$Type<(P)>): $RuleTestType<(P)>
function init(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSRuleTests$Type = ($KubeJSRuleTests);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSRuleTests_ = $KubeJSRuleTests$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Script" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $Script {

 "exec"(arg0: $Context$Type, arg1: $Scriptable$Type): any

(arg0: $Context$Type, arg1: $Scriptable$Type): any
}

export namespace $Script {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Script$Type = ($Script);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Script_ = $Script$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$InterfaceAdapter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $InterfaceAdapter {


public "invoke"(cx: $Context$Type, target: any, topScope: $Scriptable$Type, thisObject: any, method: $Method$Type, args: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterfaceAdapter$Type = ($InterfaceAdapter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterfaceAdapter_ = $InterfaceAdapter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$NotificationToast$ToastIcon" {
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"

export interface $NotificationToast$ToastIcon {

 "draw"(arg0: $Minecraft$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: integer): void

(arg0: $Minecraft$Type, arg1: $GuiGraphics$Type, arg2: integer, arg3: integer, arg4: integer): void
}

export namespace $NotificationToast$ToastIcon {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToast$ToastIcon$Type = ($NotificationToast$ToastIcon);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotificationToast$ToastIcon_ = $NotificationToast$ToastIcon$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ModelGenerator$Element" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$ModelGenerator$Face, $ModelGenerator$Face$Type} from "packages/dev/latvian/mods/kubejs/client/$ModelGenerator$Face"
import {$AABB, $AABB$Type} from "packages/net/minecraft/world/phys/$AABB"

export class $ModelGenerator$Element {

constructor()

public "box"(b: $AABB$Type): $ModelGenerator$Element
public "toJson"(): $JsonObject
public "face"(direction: $Direction$Type, consumer: $Consumer$Type<($ModelGenerator$Face$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Element$Type = ($ModelGenerator$Element);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator$Element_ = $ModelGenerator$Element$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$CompostableRecipesEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemLike, $ItemLike$Type} from "packages/net/minecraft/world/level/$ItemLike"
import {$Object2FloatMap, $Object2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap"

export class $CompostableRecipesEventJS extends $EventJS {
static "originalMap": $Object2FloatMap<($ItemLike)>

constructor()

public "add"(ingredient: $Ingredient$Type, f: float): void
public "remove"(ingredient: $Ingredient$Type): void
public "removeAll"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompostableRecipesEventJS$Type = ($CompostableRecipesEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompostableRecipesEventJS_ = $CompostableRecipesEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$DefaultErrorReporter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ErrorReporter, $ErrorReporter$Type} from "packages/dev/latvian/mods/rhino/$ErrorReporter"
import {$EvaluatorException, $EvaluatorException$Type} from "packages/dev/latvian/mods/rhino/$EvaluatorException"

export class $DefaultErrorReporter implements $ErrorReporter {


public "error"(cx: $Context$Type, message: string, sourceURI: string, line: integer, lineText: string, lineOffset: integer): void
public "warning"(message: string, sourceURI: string, line: integer, lineText: string, lineOffset: integer): void
public "runtimeError"(cx: $Context$Type, message: string, sourceURI: string, line: integer, lineText: string, lineOffset: integer): $EvaluatorException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultErrorReporter$Type = ($DefaultErrorReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultErrorReporter_ = $DefaultErrorReporter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$WhileLoop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Loop, $Loop$Type} from "packages/dev/latvian/mods/rhino/ast/$Loop"

export class $WhileLoop extends $Loop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setCondition"(condition: $AstNode$Type): void
public "getCondition"(): $AstNode
set "condition"(value: $AstNode$Type)
get "condition"(): $AstNode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WhileLoop$Type = ($WhileLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WhileLoop_ = $WhileLoop$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/$ChangeListener" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ChangeListener<T> {

 "onChanged"(arg0: T): void

(arg0: T): void
}

export namespace $ChangeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChangeListener$Type<T> = ($ChangeListener<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChangeListener_<T> = $ChangeListener$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyPlacementCallbackJS" {
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$FluidState, $FluidState$Type} from "packages/net/minecraft/world/level/material/$FluidState"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyCallbackJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockPlaceContext, $BlockPlaceContext$Type} from "packages/net/minecraft/world/item/context/$BlockPlaceContext"

export class $BlockStateModifyPlacementCallbackJS extends $BlockStateModifyCallbackJS {
readonly "context": $BlockPlaceContext
readonly "minecraftBlock": $Block
 "block": $BlockContainerJS

constructor(context: $BlockPlaceContext$Type, block: $Block$Type)

/**
 * Gets the level
 */
public "getLevel"(): $Level
/**
 * Gets the item being placed
 */
public "getItem"(): $ItemStack
/**
 * Get the horizontal rotation of the player
 */
public "getRotation"(): float
/**
 * Gets the position in the block-space of where it was clicked
 */
public "getClickLocation"(): $Vec3
/**
 * Gets the facing direction of the clicked block face
 */
public "getClickedFace"(): $Direction
/**
 * Checks if the block currently occupying the position this is being placed in is the same block type.
 * Used for things like candles, where multiple can be in the same block-space.
 */
public "isReplacingSelf"(): boolean
/**
 * Checks if the position clicked has a specified fluid there
 */
public "isClickedPosIn"(fluid: $Fluid$Type): boolean
/**
 * Gets the clicked position in world
 */
public "getClickedPos"(): $BlockPos
/**
 * Gets the clicked block
 */
public "getClickedBlock"(): $BlockContainerJS
/**
 * Gets the hand that is placing the block
 */
public "getHand"(): $InteractionHand
/**
 * Gets the player placing the block, if available
 */
public "getPlayer"(): $Player
/**
 * Returns if the block being placed thinks it can be placed here. This is used for replacement checks, like placing blocks in water or tall grass
 */
public "canPlace"(): boolean
/**
 * Checks if this block is in water
 */
public "isInWater"(): boolean
/**
 * Set if this block is waterlogged or not
 */
public "waterlogged"(waterlogged: boolean): $BlockStateModifyPlacementCallbackJS
/**
 * Set this block as waterlogged if it is in water
 */
public "waterlogged"(): $BlockStateModifyPlacementCallbackJS
/**
 * Returns if the hit posiiton in the block-space is inside the 1x1x1 cube of the block
 */
public "isInside"(): boolean
/**
 * Gets an array of all directions, ordered by which the player is looking closest to
 */
public "getNearestLookingDirections"(): ($Direction)[]
/**
 * Gets the direction closes to where the player is currently looking
 */
public "getNearestLookingDirection"(): $Direction
/**
 * Gets the vertical direction (UP/DOWN) closest to where the player is currently looking
 */
public "getNearestLookingVerticalDirection"(): $Direction
/**
 * Returns if the block being placed is replacing the block clicked
 */
public "replacingClickedOnBlock"(): boolean
/**
 * Returns if the player is using the 'secondary' function of this item. Basically checks if they are holding shift
 */
public "isSecondaryUseActive"(): boolean
/**
 * Gets the FluidSate at the clicked position
 */
public "getFluidStateAtClickedPos"(): $FluidState
/**
 * Gets the nearest horizontal direction to where the player is looking. NORTH if there is no player
 */
public "getHorizontalDirection"(): $Direction
get "level"(): $Level
get "item"(): $ItemStack
get "rotation"(): float
get "clickLocation"(): $Vec3
get "clickedFace"(): $Direction
get "replacingSelf"(): boolean
get "clickedPos"(): $BlockPos
get "clickedBlock"(): $BlockContainerJS
get "hand"(): $InteractionHand
get "player"(): $Player
get "inWater"(): boolean
get "inside"(): boolean
get "nearestLookingDirections"(): ($Direction)[]
get "nearestLookingDirection"(): $Direction
get "nearestLookingVerticalDirection"(): $Direction
get "secondaryUseActive"(): boolean
get "fluidStateAtClickedPos"(): $FluidState
get "horizontalDirection"(): $Direction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateModifyPlacementCallbackJS$Type = ($BlockStateModifyPlacementCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateModifyPlacementCallbackJS_ = $BlockStateModifyPlacementCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$LangEventJS$Key" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"

export class $LangEventJS$Key extends $Record {

constructor(namespace: string, lang: string, key: string)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): string
public "lang"(): string
public "namespace"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangEventJS$Key$Type = ($LangEventJS$Key);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LangEventJS$Key_ = $LangEventJS$Key$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$BuilderBase" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$LangEventJS, $LangEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/$LangEventJS"
import {$DataJsonGenerator, $DataJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$DataJsonGenerator"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $BuilderBase<T> implements $Supplier<(T)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "get"(): T
public "toString"(): string
/**
 * Sets the display name for this object, e.g. `Stone`.
 * 
 * This will be overridden by a lang file if it exists.
 */
public "displayName"(name: $Component$Type): $BuilderBase<(T)>
/**
 * Adds a tag to this object, e.g. `minecraft:stone`.
 */
public "tag"(tag: $ResourceLocation$Type): $BuilderBase<(T)>
public "createObject"(): T
public "generateLang"(lang: $LangEventJS$Type): void
public "generateAssetJsons"(generator: $AssetJsonGenerator$Type): void
public "generateDataJsons"(generator: $DataJsonGenerator$Type): void
public "createAdditionalObjects"(): void
public "transformObject"(obj: T): T
/**
 * Makes displayName() override language files.
 */
public "formattedDisplayName"(): $BuilderBase<(T)>
/**
 * Combined method of formattedDisplayName().displayName(name).
 */
public "formattedDisplayName"(name: $Component$Type): $BuilderBase<(T)>
public "getTranslationKeyGroup"(): string
public "getBuilderTranslationKey"(): string
public "getRegistryType"(): $RegistryInfo<(any)>
/**
 * Sets the translation key for this object, e.g. `block.minecraft.stone`.
 */
public "translationKey"(key: string): $BuilderBase<(T)>
public "newID"(pre: string, post: string): $ResourceLocation
get "translationKeyGroup"(): string
get "builderTranslationKey"(): string
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuilderBase$Type<T> = ($BuilderBase<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuilderBase_<T> = $BuilderBase$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$EmptyStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $EmptyStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor()
constructor(pos: integer)
constructor(pos: integer, len: integer)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyStatement$Type = ($EmptyStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyStatement_ = $EmptyStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateRotateCallbackJS" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyCallbackJS"

export class $BlockStateRotateCallbackJS extends $BlockStateModifyCallbackJS {

constructor(state: $BlockState$Type, rotation: $Rotation$Type)

/**
 * Rotates the specified direction
 */
public "rotate"(dir: $Direction$Type): $Direction
/**
 * Get the Rotation that this block is being rotated by
 */
public "getRotation"(): $Rotation
get "rotation"(): $Rotation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateRotateCallbackJS$Type = ($BlockStateRotateCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateRotateCallbackJS_ = $BlockStateRotateCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeString" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Wrapper, $Wrapper$Type} from "packages/dev/latvian/mods/rhino/$Wrapper"

export class $NativeString extends $IdScriptableObject implements $Wrapper {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "toString"(): string
public "unwrap"(): any
public "getAttributes"(cx: $Context$Type, index: integer): integer
public "getClassName"(): string
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "toCharSequence"(): charseq
public "getTypeOf"(): $MemberType
public static "unwrapped"(o: any): any
get "className"(): string
get "typeOf"(): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeString$Type = ($NativeString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeString_ = $NativeString$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$JEISubtypesEventJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$JEISubtypesEventJS$Interpreter, $JEISubtypesEventJS$Interpreter$Type} from "packages/dev/latvian/mods/kubejs/integration/forge/jei/$JEISubtypesEventJS$Interpreter"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ISubtypeRegistration, $ISubtypeRegistration$Type} from "packages/mezz/jei/api/registration/$ISubtypeRegistration"

export class $JEISubtypesEventJS extends $EventJS {

constructor(r: $ISubtypeRegistration$Type)

public "useNBTKey"(items: $Ingredient$Type, key: string): void
public "useNBT"(items: $Ingredient$Type): void
public "registerInterpreter"(item: $Item$Type, interpreter: $JEISubtypesEventJS$Interpreter$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEISubtypesEventJS$Type = ($JEISubtypesEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEISubtypesEventJS_ = $JEISubtypesEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemStackJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ItemStackJS {

}

export namespace $ItemStackJS {
const PARSE_CACHE: $Map<(string), ($ItemStack)>
const EMPTY_ARRAY: ($ItemStack)[]
const CACHED_ITEM_TYPE_LIST: $Lazy<($List<(string)>)>
const CACHED_ITEM_MAP: $Lazy<($Map<($ResourceLocation), ($Collection<($ItemStack)>)>)>
const CACHED_ITEM_LIST: $Lazy<($List<($ItemStack)>)>
function of(o: any): $ItemStack
function parse(s: string): $ItemStack
function getList(): $List<($ItemStack)>
function resultFromRecipeJson(json: $JsonElement$Type): $ItemStack
function getTypeToStacks(): $Map<($ResourceLocation), ($Collection<($ItemStack)>)>
function toItemString(object: any): string
function clearAllCaches(): void
function getRawItem(cx: $Context$Type, o: any): $Item
function getTypeList(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemStackJS$Type = ($ItemStackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemStackJS_ = $ItemStackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorItemBuilder extends $ItemBuilder {
readonly "armorType": $ArmorItem$Type
 "armorTier": $MutableArmorTier
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean


public "modifyTier"(callback: $Consumer$Type<($MutableArmorTier$Type)>): $ArmorItemBuilder
public "tier"(t: $ArmorMaterial$Type): $ArmorItemBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Type = ($ArmorItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder_ = $ArmorItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$ShapedRecipeSchema$ShapedRecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ShapedRecipeSchema$ShapedRecipeJS extends $RecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "noShrink"(): $RecipeJS
public "noMirror"(): $RecipeJS
public "afterLoaded"(): void
public "getSerializationTypeFunction"(): $RecipeTypeFunction
get "serializationTypeFunction"(): $RecipeTypeFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedRecipeSchema$ShapedRecipeJS$Type = ($ShapedRecipeSchema$ShapedRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedRecipeSchema$ShapedRecipeJS_ = $ShapedRecipeSchema$ShapedRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ByteCode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ByteCode {

}

export namespace $ByteCode {
const NOP: integer
const ACONST_NULL: integer
const ICONST_M1: integer
const ICONST_0: integer
const ICONST_1: integer
const ICONST_2: integer
const ICONST_3: integer
const ICONST_4: integer
const ICONST_5: integer
const LCONST_0: integer
const LCONST_1: integer
const FCONST_0: integer
const FCONST_1: integer
const FCONST_2: integer
const DCONST_0: integer
const DCONST_1: integer
const BIPUSH: integer
const SIPUSH: integer
const LDC: integer
const LDC_W: integer
const LDC2_W: integer
const ILOAD: integer
const LLOAD: integer
const FLOAD: integer
const DLOAD: integer
const ALOAD: integer
const ILOAD_0: integer
const ILOAD_1: integer
const ILOAD_2: integer
const ILOAD_3: integer
const LLOAD_0: integer
const LLOAD_1: integer
const LLOAD_2: integer
const LLOAD_3: integer
const FLOAD_0: integer
const FLOAD_1: integer
const FLOAD_2: integer
const FLOAD_3: integer
const DLOAD_0: integer
const DLOAD_1: integer
const DLOAD_2: integer
const DLOAD_3: integer
const ALOAD_0: integer
const ALOAD_1: integer
const ALOAD_2: integer
const ALOAD_3: integer
const IALOAD: integer
const LALOAD: integer
const FALOAD: integer
const DALOAD: integer
const AALOAD: integer
const BALOAD: integer
const CALOAD: integer
const SALOAD: integer
const ISTORE: integer
const LSTORE: integer
const FSTORE: integer
const DSTORE: integer
const ASTORE: integer
const ISTORE_0: integer
const ISTORE_1: integer
const ISTORE_2: integer
const ISTORE_3: integer
const LSTORE_0: integer
const LSTORE_1: integer
const LSTORE_2: integer
const LSTORE_3: integer
const FSTORE_0: integer
const FSTORE_1: integer
const FSTORE_2: integer
const FSTORE_3: integer
const DSTORE_0: integer
const DSTORE_1: integer
const DSTORE_2: integer
const DSTORE_3: integer
const ASTORE_0: integer
const ASTORE_1: integer
const ASTORE_2: integer
const ASTORE_3: integer
const IASTORE: integer
const LASTORE: integer
const FASTORE: integer
const DASTORE: integer
const AASTORE: integer
const BASTORE: integer
const CASTORE: integer
const SASTORE: integer
const POP: integer
const POP2: integer
const DUP: integer
const DUP_X1: integer
const DUP_X2: integer
const DUP2: integer
const DUP2_X1: integer
const DUP2_X2: integer
const SWAP: integer
const IADD: integer
const LADD: integer
const FADD: integer
const DADD: integer
const ISUB: integer
const LSUB: integer
const FSUB: integer
const DSUB: integer
const IMUL: integer
const LMUL: integer
const FMUL: integer
const DMUL: integer
const IDIV: integer
const LDIV: integer
const FDIV: integer
const DDIV: integer
const IREM: integer
const LREM: integer
const FREM: integer
const DREM: integer
const INEG: integer
const LNEG: integer
const FNEG: integer
const DNEG: integer
const ISHL: integer
const LSHL: integer
const ISHR: integer
const LSHR: integer
const IUSHR: integer
const LUSHR: integer
const IAND: integer
const LAND: integer
const IOR: integer
const LOR: integer
const IXOR: integer
const LXOR: integer
const IINC: integer
const I2L: integer
const I2F: integer
const I2D: integer
const L2I: integer
const L2F: integer
const L2D: integer
const F2I: integer
const F2L: integer
const F2D: integer
const D2I: integer
const D2L: integer
const D2F: integer
const I2B: integer
const I2C: integer
const I2S: integer
const LCMP: integer
const FCMPL: integer
const FCMPG: integer
const DCMPL: integer
const DCMPG: integer
const IFEQ: integer
const IFNE: integer
const IFLT: integer
const IFGE: integer
const IFGT: integer
const IFLE: integer
const IF_ICMPEQ: integer
const IF_ICMPNE: integer
const IF_ICMPLT: integer
const IF_ICMPGE: integer
const IF_ICMPGT: integer
const IF_ICMPLE: integer
const IF_ACMPEQ: integer
const IF_ACMPNE: integer
const GOTO: integer
const JSR: integer
const RET: integer
const TABLESWITCH: integer
const LOOKUPSWITCH: integer
const IRETURN: integer
const LRETURN: integer
const FRETURN: integer
const DRETURN: integer
const ARETURN: integer
const RETURN: integer
const GETSTATIC: integer
const PUTSTATIC: integer
const GETFIELD: integer
const PUTFIELD: integer
const INVOKEVIRTUAL: integer
const INVOKESPECIAL: integer
const INVOKESTATIC: integer
const INVOKEINTERFACE: integer
const INVOKEDYNAMIC: integer
const NEW: integer
const NEWARRAY: integer
const ANEWARRAY: integer
const ARRAYLENGTH: integer
const ATHROW: integer
const CHECKCAST: integer
const INSTANCEOF: integer
const MONITORENTER: integer
const MONITOREXIT: integer
const WIDE: integer
const MULTIANEWARRAY: integer
const IFNULL: integer
const IFNONNULL: integer
const GOTO_W: integer
const JSR_W: integer
const BREAKPOINT: integer
const IMPDEP1: integer
const IMPDEP2: integer
const T_BOOLEAN: byte
const T_CHAR: byte
const T_FLOAT: byte
const T_DOUBLE: byte
const T_BYTE: byte
const T_SHORT: byte
const T_INT: byte
const T_LONG: byte
const MH_GETFIELD: byte
const MH_GETSTATIC: byte
const MH_PUTFIELD: byte
const MH_PUTSTATIC: byte
const MH_INVOKEVIRTUAL: byte
const MH_INVOKESTATIC: byte
const MH_INVOKESPECIAL: byte
const MH_NEWINVOKESPECIAL: byte
const MH_INVOKEINTERFACE: byte
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteCode$Type = ($ByteCode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteCode_ = $ByteCode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$NotificationMessage" {
import {$NotificationBuilder, $NotificationBuilder$Type} from "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $NotificationMessage extends $BaseS2CMessage {

constructor(notification: $NotificationBuilder$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationMessage$Type = ($NotificationMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotificationMessage_ = $NotificationMessage$Type;
}}
declare module "packages/dev/latvian/mods/rhino/annotations/$JSSetter" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JSSetter extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JSSetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSSetter$Type = ($JSSetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSSetter_ = $JSSetter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$UtilsJS$TryIO" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $UtilsJS$TryIO {

 "run"(): void

(): void
}

export namespace $UtilsJS$TryIO {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsJS$TryIO$Type = ($UtilsJS$TryIO);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UtilsJS$TryIO_ = $UtilsJS$TryIO$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArrayRecipeComponent<T> extends $Record implements $RecipeComponent<((T)[])> {

constructor(component: $RecipeComponent$Type<(T)>, canWriteSelf: boolean, arrayClass: $Class$Type<(any)>, emptyArray: (T)[])

public "add"(array: (T)[], value: T): (T)[]
public "remove"(array: (T)[], index: integer): (T)[]
public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "newArray"(length: integer): (T)[]
public "componentType"(): string
public "addAll"(array: (T)[], ...values: (T)[]): (T)[]
public "component"(): $RecipeComponent<(T)>
public "write"(recipe: $RecipeJS$Type, value: (T)[]): $JsonElement
public "arrayClass"(): $Class<(any)>
public "emptyArray"(): (T)[]
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: (T)[], match: $ReplacementMatch$Type): boolean
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: (T)[], match: $ReplacementMatch$Type): boolean
public "replaceOutput"(recipe: $RecipeJS$Type, original: (T)[], match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): (T)[]
public "replaceInput"(recipe: $RecipeJS$Type, original: (T)[], match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): (T)[]
public "canWriteSelf"(): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<((T)[])>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<((T)[])>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<((T)[]), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<((T)[]), (O)>
public "asArray"(): $ArrayRecipeComponent<((T)[])>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ((T)[])>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<((T)[])>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<((T)[])>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<((T)[])>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<((T)[])>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<((T)[])>, map: $Map$Type<(any), (any)>): void
public "orSelf"(): $RecipeComponent<((T)[])>
public "asArrayOrSelf"(): $ArrayRecipeComponent<((T)[])>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ((T)[])>)>
public "checkEmpty"(key: $RecipeKey$Type<((T)[])>, value: (T)[]): string
public "checkValueHasChanged"(oldValue: (T)[], newValue: (T)[]): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<((T)[])>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayRecipeComponent$Type<T> = ($ArrayRecipeComponent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayRecipeComponent_<T> = $ArrayRecipeComponent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$ClientPlayerKJS" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$NotificationBuilder, $NotificationBuilder$Type} from "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$GameProfile, $GameProfile$Type} from "packages/com/mojang/authlib/$GameProfile"
import {$AbstractContainerMenu, $AbstractContainerMenu$Type} from "packages/net/minecraft/world/inventory/$AbstractContainerMenu"
import {$EntityPotionEffectsJS, $EntityPotionEffectsJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$EntityPotionEffectsJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$EntityArrayList, $EntityArrayList$Type} from "packages/dev/latvian/mods/kubejs/player/$EntityArrayList"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$KubeJSInventoryListener, $KubeJSInventoryListener$Type} from "packages/dev/latvian/mods/kubejs/player/$KubeJSInventoryListener"
import {$PlayerStatsJS, $PlayerStatsJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerStatsJS"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$EquipmentSlot, $EquipmentSlot$Type} from "packages/net/minecraft/world/entity/$EquipmentSlot"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier$Operation, $AttributeModifier$Operation$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier$Operation"
import {$PlayerKJS, $PlayerKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$PlayerKJS"

export interface $ClientPlayerKJS extends $PlayerKJS {

 "isMiningBlock"(): boolean
 "getStats"(): $PlayerStatsJS
 "paint"(tag: $CompoundTag$Type): void
 "notify"(notification: $NotificationBuilder$Type): void
 "sendData"(channel: string, data: $CompoundTag$Type): void
 "isSelf"(): boolean
 "getInventory"(): $InventoryKJS
 "getStages"(): $Stages
 "isFake"(): boolean
 "getProfile"(): $GameProfile
 "give"(item: $ItemStack$Type): void
 "setMouseItem"(item: $ItemStack$Type): void
 "getMouseItem"(): $ItemStack
 "spawn"(): void
 "addFood"(f: integer, m: float): void
 "giveInHand"(item: $ItemStack$Type): void
 "getFoodLevel"(): integer
 "isPlayer"(): boolean
 "notify"(title: $Component$Type, text: $Component$Type): void
 "addXP"(xp: integer): void
 "addXPLevels"(l: integer): void
 "getSaturation"(): float
 "setXpLevel"(l: integer): void
 "addExhaustion"(exhaustion: float): void
 "getXp"(): integer
 "setSaturation"(saturation: float): void
 "setXp"(xp: integer): void
 "getXpLevel"(): integer
 "setFoodLevel"(foodLevel: integer): void
 "setStatusMessage"(message: $Component$Type): void
 "getCraftingGrid"(): $InventoryKJS
 "getInventoryChangeListener"(): $KubeJSInventoryListener
 "sendInventoryUpdate"(): void
 "getSelectedSlot"(): integer
 "setSelectedSlot"(index: integer): void
 "boostElytraFlight"(): void
 "getOpenInventory"(): $AbstractContainerMenu
 "addItemCooldown"(item: $Item$Type, ticks: integer): void
 "foodEaten"(is: $ItemStack$Type): void
 "setMaxHealth"(hp: float): void
 "isUndead"(): boolean
 "isLiving"(): boolean
 "getEquipment"(slot: $EquipmentSlot$Type): $ItemStack
 "setEquipment"(slot: $EquipmentSlot$Type, item: $ItemStack$Type): void
 "swing"(): void
 "swing"(hand: $InteractionHand$Type): void
 "setOffHandItem"(item: $ItemStack$Type): void
 "getOffHandItem"(): $ItemStack
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "damageHeldItem"(hand: $InteractionHand$Type, amount: integer): void
 "damageHeldItem"(): void
 "setHeldItem"(hand: $InteractionHand$Type, item: $ItemStack$Type): void
 "getHeldItem"(hand: $InteractionHand$Type): $ItemStack
 "rayTrace"(): $RayTraceResultJS
 "getHeadArmorItem"(): $ItemStack
 "getTotalMovementSpeed"(): double
 "getDefaultMovementSpeed"(): double
 "getReachDistance"(): double
 "getPotionEffects"(): $EntityPotionEffectsJS
 "setMovementSpeedAddition"(speed: double): void
 "isHoldingInAnyHand"(i: $Ingredient$Type): boolean
 "setLegsArmorItem"(item: $ItemStack$Type): void
 "setFeetArmorItem"(item: $ItemStack$Type): void
 "setHeadArmorItem"(item: $ItemStack$Type): void
 "getMainHandItem"(): $ItemStack
 "getLegsArmorItem"(): $ItemStack
 "removeAttribute"(attribute: $Attribute$Type, identifier: string): void
 "setDefaultMovementSpeed"(speed: double): void
 "damageEquipment"(slot: $EquipmentSlot$Type): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer): void
 "damageEquipment"(slot: $EquipmentSlot$Type, amount: integer, onBroken: $Consumer$Type<($ItemStack$Type)>): void
 "getAttributeBaseValue"(attribute: $Attribute$Type): double
 "setChestArmorItem"(item: $ItemStack$Type): void
 "getFeetArmorItem"(): $ItemStack
 "getAttributeTotalValue"(attribute: $Attribute$Type): double
 "modifyAttribute"(attribute: $Attribute$Type, identifier: string, d: double, operation: $AttributeModifier$Operation$Type): void
 "setMainHandItem"(item: $ItemStack$Type): void
 "getChestArmorItem"(): $ItemStack
 "canEntityBeSeen"(entity: $LivingEntity$Type): boolean
 "setAttributeBaseValue"(attribute: $Attribute$Type, value: double): void
 "setTotalMovementSpeedMultiplier"(speed: double): void
 "setDefaultMovementSpeedMultiplier"(speed: double): void
 "sendData"(channel: string): void
 "getData"(): $AttachedData<($Player)>
 "rayTrace"(distance: double): $RayTraceResultJS
 "rayTrace"(distance: double, fluids: boolean): $RayTraceResultJS
 "getServer"(): $MinecraftServer
 "setX"(x: double): void
 "isFrame"(): boolean
 "isMonster"(): boolean
 "getType"(): string
 "setPosition"(x: double, y: double, z: double): void
 "setPosition"(block: $BlockContainerJS$Type): void
 "getItem"(): $ItemStack
 "getLevel"(): $Level
 "isAnimal"(): boolean
 "setRotation"(yaw: float, pitch: float): void
 "getTeamId"(): string
 "teleportTo"(dimension: $ResourceLocation$Type, x: double, y: double, z: double, yaw: float, pitch: float): void
 "getPassengers"(): $EntityArrayList
 "setMotionX"(x: double): void
 "setMotionY"(y: double): void
 "setMotionZ"(z: double): void
 "getMotionZ"(): double
 "getMotionX"(): double
 "setY"(y: double): void
 "getMotionY"(): double
 "setZ"(z: double): void
 "setNbt"(nbt: $CompoundTag$Type): void
 "attack"(hp: float): void
 "playSound"(id: $SoundEvent$Type, volume: float, pitch: float): void
 "playSound"(id: $SoundEvent$Type): void
 "getDistance"(x: double, y: double, z: double): double
 "getDistance"(pos: $BlockPos$Type): double
 "getDistanceSq"(pos: $BlockPos$Type): double
 "mergeNbt"(tag: $CompoundTag$Type): $Entity
 "getBlock"(): $BlockContainerJS
 "getNbt"(): $CompoundTag
 "getFacing"(): $Direction
 "getScriptType"(): $ScriptType
 "runCommandSilent"(command: string): integer
 "isWaterCreature"(): boolean
 "isOnScoreboardTeam"(teamId: string): boolean
 "isPeacefulCreature"(): boolean
 "setPositionAndRotation"(x: double, y: double, z: double, yaw: float, pitch: float): void
 "isAmbientCreature"(): boolean
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
 "getPersistentData"(): $CompoundTag

(): boolean
}

export namespace $ClientPlayerKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientPlayerKJS$Type = ($ClientPlayerKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientPlayerKJS_ = $ClientPlayerKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"

export interface $MessageSenderKJS {

 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component
}

export namespace $MessageSenderKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSenderKJS$Type = ($MessageSenderKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageSenderKJS_ = $MessageSenderKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchemaType" {
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeNamespace, $RecipeNamespace$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeNamespace"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $RecipeSchemaType {
readonly "namespace": $RecipeNamespace
readonly "id": $ResourceLocation
readonly "schema": $RecipeSchema
 "parent": $RecipeSchemaType

constructor(namespace: $RecipeNamespace$Type, id: $ResourceLocation$Type, schema: $RecipeSchema$Type)

public "toString"(): string
public "getSerializer"(): $RecipeSerializer<(any)>
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchemaType$Type = ($RecipeSchemaType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchemaType_ = $RecipeSchemaType$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$DefaultRemapper" {
import {$Remapper, $Remapper$Type} from "packages/dev/latvian/mods/rhino/util/$Remapper"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"

export class $DefaultRemapper implements $Remapper {
static readonly "INSTANCE": $DefaultRemapper


public static "getTypeName"(type: string): string
public "getUnmappedClass"(from: string): string
public "getMappedField"(from: $Class$Type<(any)>, field: $Field$Type): string
public "getMappedMethod"(from: $Class$Type<(any)>, method: $Method$Type): string
public "getMappedClass"(from: $Class$Type<(any)>): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultRemapper$Type = ($DefaultRemapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultRemapper_ = $DefaultRemapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$ExplosionEventJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$Vec3, $Vec3$Type} from "packages/net/minecraft/world/phys/$Vec3"
import {$Explosion, $Explosion$Type} from "packages/net/minecraft/world/level/$Explosion"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$LevelEventJS, $LevelEventJS$Type} from "packages/dev/latvian/mods/kubejs/level/$LevelEventJS"

export class $ExplosionEventJS extends $LevelEventJS {

constructor(level: $Level$Type, explosion: $Explosion$Type)

public "getLevel"(): $Level
public "getPosition"(): $Vec3
public "getBlock"(): $BlockContainerJS
public "getY"(): double
public "getZ"(): double
public "getX"(): double
public "getExploder"(): $LivingEntity
get "level"(): $Level
get "position"(): $Vec3
get "block"(): $BlockContainerJS
get "y"(): double
get "z"(): double
get "x"(): double
get "exploder"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExplosionEventJS$Type = ($ExplosionEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExplosionEventJS_ = $ExplosionEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaMethod" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeJavaMethod extends $BaseFunction {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(method: $Method$Type, name: string)

public "toString"(): string
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getFunctionName"(): string
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "functionName"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaMethod$Type = ($NativeJavaMethod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaMethod_ = $NativeJavaMethod$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ForInLoop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$Loop, $Loop$Type} from "packages/dev/latvian/mods/rhino/ast/$Loop"

export class $ForInLoop extends $Loop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getIterator"(): $AstNode
public "setIteratedObject"(object: $AstNode$Type): void
public "setEachPosition"(eachPosition: integer): void
public "setIsForOf"(isForOf: boolean): void
public "setInPosition"(inPosition: integer): void
public "setIsForEach"(isForEach: boolean): void
public "getIteratedObject"(): $AstNode
public "getEachPosition"(): integer
public "getInPosition"(): integer
public "isForOf"(): boolean
public "setIterator"(iterator: $AstNode$Type): void
public "isForEach"(): boolean
get "iterator"(): $AstNode
set "iteratedObject"(value: $AstNode$Type)
set "eachPosition"(value: integer)
set "inPosition"(value: integer)
get "iteratedObject"(): $AstNode
get "eachPosition"(): integer
get "inPosition"(): integer
get "forOf"(): boolean
set "iterator"(value: $AstNode$Type)
get "forEach"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForInLoop$Type = ($ForInLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForInLoop_ = $ForInLoop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeConstructor$Factory, $RecipeConstructor$Factory$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeConstructor$Factory"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$RecipeConstructor, $RecipeConstructor$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeConstructor"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export class $RecipeSchema {
static readonly "DEFAULT_UNIQUE_ID_FUNCTION": $Function<($RecipeJS), (string)>
readonly "recipeType": $Class<(any)>
readonly "factory": $Supplier<(any)>
readonly "keys": ($RecipeKey<(any)>)[]
 "uniqueIdFunction": $Function<($RecipeJS), (string)>

constructor(...keys: ($RecipeKey$Type<(any)>)[])
constructor(recipeType: $Class$Type<(any)>, factory: $Supplier$Type<(any)>, ...keys: ($RecipeKey$Type<(any)>)[])

public "addConstructor"(factory: $RecipeConstructor$Factory$Type, ...keys: ($RecipeKey$Type<(any)>)[]): $RecipeSchema
public "addConstructor"(...keys: ($RecipeKey$Type<(any)>)[]): $RecipeSchema
public "constructors"(): $Int2ObjectMap<($RecipeConstructor)>
public "deserialize"(type: $RecipeTypeFunction$Type, id: $ResourceLocation$Type, json: $JsonObject$Type): $RecipeJS
public "outputCount"(): integer
public static "normalizeId"(id: string): string
public "uniqueInputId"(resultItemKey: $RecipeKey$Type<($InputItem$Type)>): $RecipeSchema
public "uniqueOutputId"(resultItemKey: $RecipeKey$Type<($OutputItem$Type)>): $RecipeSchema
public "uniqueOutputArrayId"(resultItemKey: $RecipeKey$Type<(($OutputItem$Type)[])>): $RecipeSchema
public "minRequiredArguments"(): integer
public "uuid"(): $UUID
public "uniqueId"(uniqueIdFunction: $Function$Type<($RecipeJS$Type), (string)>): $RecipeSchema
public "inputCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeSchema$Type = ($RecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeSchema_ = $RecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Icode" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Icode {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Icode$Type = ($Icode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Icode_ = $Icode$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$BooleanComponent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BooleanComponent implements $RecipeComponent<(boolean)> {
static readonly "BOOLEAN": $RecipeComponent<(boolean)>

constructor()

public "toString"(): string
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: boolean): $JsonElement
public "read"(recipe: $RecipeJS$Type, from: any): boolean
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(boolean)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(boolean)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(boolean), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(boolean), (O)>
public "asArray"(): $ArrayRecipeComponent<(boolean)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (boolean)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(boolean)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(boolean)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(boolean)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(boolean)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(boolean)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: boolean, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: boolean, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(boolean)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(boolean)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (boolean)>)>
public "checkEmpty"(key: $RecipeKey$Type<(boolean)>, value: boolean): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: boolean, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): boolean
public "replaceInput"(recipe: $RecipeJS$Type, original: boolean, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): boolean
public "checkValueHasChanged"(oldValue: boolean, newValue: boolean): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(boolean)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanComponent$Type = ($BooleanComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanComponent_ = $BooleanComponent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$SendDataFromClientMessage" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseC2SMessage, $BaseC2SMessage$Type} from "packages/dev/architectury/networking/simple/$BaseC2SMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $SendDataFromClientMessage extends $BaseC2SMessage {

constructor(c: string, d: $CompoundTag$Type)

public "write"(buf: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SendDataFromClientMessage$Type = ($SendDataFromClientMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SendDataFromClientMessage_ = $SendDataFromClientMessage$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/properties/$AddSpawnProperties" {
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $AddSpawnProperties {
 "_category": $MobCategory
 "biomes": $BiomeFilter
 "weight": integer
 "_entity": $EntityType<(any)>
 "minCount": integer
 "maxCount": integer

constructor()

public "setCategory"(s: string): void
public "setEntity"(s: string): void
set "category"(value: string)
set "entity"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AddSpawnProperties$Type = ($AddSpawnProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AddSpawnProperties_ = $AddSpawnProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/$LevelPlatformHelper" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

export interface $LevelPlatformHelper {

 "getReachDistance"(arg0: $LivingEntity$Type): double
 "getInventoryFromBlockEntity"(arg0: $BlockEntity$Type, arg1: $Direction$Type): $InventoryKJS
 "areCapsCompatible"(arg0: $ItemStack$Type, arg1: $ItemStack$Type): boolean
 "createBlockEntity"(arg0: $BlockPos$Type, arg1: $BlockState$Type, arg2: $BlockEntityInfo$Type): $BlockEntityJS
}

export namespace $LevelPlatformHelper {
const INSTANCE: $Lazy<($LevelPlatformHelper)>
function get(): $LevelPlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LevelPlatformHelper$Type = ($LevelPlatformHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LevelPlatformHelper_ = $LevelPlatformHelper$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$MapFuncUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $MapFuncUnit extends $FuncUnit {
static readonly "FACTORY": $FunctionFactory
readonly "value": $Unit
readonly "min1": $Unit
readonly "max1": $Unit
readonly "min2": $Unit
readonly "max2": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(args: ($Unit$Type)[])

public "get"(variables: $UnitVariables$Type): double
public static "map"(value: double, min1: double, max1: double, min2: double, max2: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapFuncUnit$Type = ($MapFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapFuncUnit_ = $MapFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJSTicker" {
import {$BlockEntityJS, $BlockEntityJS$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityJS"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$BlockEntityInfo, $BlockEntityInfo$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityInfo"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityCallback, $BlockEntityCallback$Type} from "packages/dev/latvian/mods/kubejs/block/entity/$BlockEntityCallback"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"

export class $BlockEntityJSTicker extends $Record implements $BlockEntityTicker<($BlockEntityJS)> {

constructor(info: $BlockEntityInfo$Type, frequency: integer, offset: integer, callback: $BlockEntityCallback$Type, server: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "offset"(): integer
public "info"(): $BlockEntityInfo
public "frequency"(): integer
public "tick"(level: $Level$Type, blockPos: $BlockPos$Type, blockState: $BlockState$Type, e: $BlockEntityJS$Type): void
public "callback"(): $BlockEntityCallback
public "server"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockEntityJSTicker$Type = ($BlockEntityJSTicker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockEntityJSTicker_ = $BlockEntityJSTicker$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$TemplateCharacters" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $TemplateCharacters extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getValue"(): string
public "setValue"(value: string): void
public "getRawValue"(): string
public "setRawValue"(rawValue: string): void
get "value"(): string
set "value"(value: string)
get "rawValue"(): string
set "rawValue"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemplateCharacters$Type = ($TemplateCharacters);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemplateCharacters_ = $TemplateCharacters$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$SoundTypeWrapper" {
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SoundTypeWrapper implements $TypeWrapperFactory<($SoundType)> {
static readonly "INSTANCE": $SoundTypeWrapper

constructor()

public "getMap"(): $Map<(string), ($SoundType)>
get "map"(): $Map<(string), ($SoundType)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundTypeWrapper$Type = ($SoundTypeWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundTypeWrapper_ = $SoundTypeWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$ButtonBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$BlockSetType, $BlockSetType$Type} from "packages/net/minecraft/world/level/block/state/properties/$BlockSetType"
import {$ShapedBlockBuilder, $ShapedBlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder"

export class $ButtonBlockBuilder extends $ShapedBlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "behaviour"(wt: $BlockSetType$Type): $ButtonBlockBuilder
public "behaviour"(wt: string): $ButtonBlockBuilder
public "arrowsCanPress"(b: boolean): $ButtonBlockBuilder
public "ticksToStayPressed"(t: integer): $ButtonBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ButtonBlockBuilder$Type = ($ButtonBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ButtonBlockBuilder_ = $ButtonBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$StringComponent" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$JsonPrimitive, $JsonPrimitive$Type} from "packages/com/google/gson/$JsonPrimitive"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$DynamicRecipeComponent, $DynamicRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$DynamicRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StringComponent extends $Record implements $RecipeComponent<(string)> {
static readonly "ANY": $RecipeComponent<(string)>
static readonly "NON_EMPTY": $RecipeComponent<(string)>
static readonly "NON_BLANK": $RecipeComponent<(string)>
static readonly "ID": $RecipeComponent<(string)>
static readonly "CHARACTER": $RecipeComponent<(character)>
static readonly "DYNAMIC": $DynamicRecipeComponent

constructor(error: string, predicate: $Predicate$Type<(string)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "write"(recipe: $RecipeJS$Type, value: string): $JsonPrimitive
public "error"(): string
public "predicate"(): $Predicate<(string)>
public "componentClass"(): $Class<(any)>
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(string)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<(string)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(string), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(string), (O)>
public "asArray"(): $ArrayRecipeComponent<(string)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (string)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(string)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(string)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(string)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(string)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(string)>, map: $Map$Type<(any), (any)>): void
public "isInput"(recipe: $RecipeJS$Type, value: string, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: string, match: $ReplacementMatch$Type): boolean
public "orSelf"(): $RecipeComponent<(string)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<(string)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (string)>)>
public "checkEmpty"(key: $RecipeKey$Type<(string)>, value: string): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: string, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): string
public "replaceInput"(recipe: $RecipeJS$Type, original: string, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): string
public "checkValueHasChanged"(oldValue: string, newValue: string): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(string)>
public "role"(): $ComponentRole
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringComponent$Type = ($StringComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringComponent_ = $StringComponent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder$Leggings" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$MutableArmorTier, $MutableArmorTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableArmorTier"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ArmorItemBuilder, $ArmorItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/custom/$ArmorItemBuilder"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$ArmorItem$Type, $ArmorItem$Type$Type} from "packages/net/minecraft/world/item/$ArmorItem$Type"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ArmorItemBuilder$Leggings extends $ArmorItemBuilder {
readonly "armorType": $ArmorItem$Type
 "armorTier": $MutableArmorTier
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArmorItemBuilder$Leggings$Type = ($ArmorItemBuilder$Leggings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArmorItemBuilder$Leggings_ = $ArmorItemBuilder$Leggings$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$LteOpUnit" {
import {$CondOpUnit, $CondOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $LteOpUnit extends $CondOpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "getBoolean"(variables: $UnitVariables$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LteOpUnit$Type = ($LteOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LteOpUnit_ = $LteOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuClickEvent" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$ChestMenuSlot, $ChestMenuSlot$Type} from "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuSlot"

export class $ChestMenuClickEvent {
readonly "slot": $ChestMenuSlot
readonly "type": $ClickType
readonly "button": integer

constructor(slot: $ChestMenuSlot$Type, type: $ClickType$Type, button: integer)

public "setHandled"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuClickEvent$Type = ($ChestMenuClickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuClickEvent_ = $ChestMenuClickEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$JsonRecipeJS" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"

export class $JsonRecipeJS extends $RecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "deserialize"(merge: boolean): void
public "serialize"(): void
public "replaceOutput"(match: $ReplacementMatch$Type, arg1: $OutputReplacement$Type): boolean
public "hasInput"(match: $ReplacementMatch$Type): boolean
public "replaceInput"(match: $ReplacementMatch$Type, arg1: $InputReplacement$Type): boolean
public "hasOutput"(match: $ReplacementMatch$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JsonRecipeJS$Type = ($JsonRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JsonRecipeJS_ = $JsonRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/net/$PaintMessage" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$NetworkManager$PacketContext, $NetworkManager$PacketContext$Type} from "packages/dev/architectury/networking/$NetworkManager$PacketContext"
import {$BaseS2CMessage, $BaseS2CMessage$Type} from "packages/dev/architectury/networking/simple/$BaseS2CMessage"
import {$MessageType, $MessageType$Type} from "packages/dev/architectury/networking/simple/$MessageType"

export class $PaintMessage extends $BaseS2CMessage {

constructor(c: $CompoundTag$Type)

public "write"(buffer: $FriendlyByteBuf$Type): void
public "getType"(): $MessageType
public "handle"(context: $NetworkManager$PacketContext$Type): void
get "type"(): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaintMessage$Type = ($PaintMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaintMessage_ = $PaintMessage$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Func2Unit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"

export class $Func2Unit extends $FuncUnit {
readonly "a": $Unit
readonly "b": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(factory: $FunctionFactory$Type, a: $Unit$Type, b: $Unit$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Func2Unit$Type = ($Func2Unit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Func2Unit_ = $Func2Unit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/$RecipePlatformHelper" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeManager, $RecipeManager$Type} from "packages/net/minecraft/world/item/crafting/$RecipeManager"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"

export interface $RecipePlatformHelper {

 "fromJson"(arg0: $RecipeSerializer$Type<(any)>, arg1: $ResourceLocation$Type, arg2: $JsonObject$Type): $Recipe<(any)>
 "getCustomIngredient"(arg0: $JsonObject$Type): $Ingredient
 "pingNewRecipes"(arg0: $Map$Type<($RecipeType$Type<(any)>), ($Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>)>): void
 "processConditions"(arg0: $RecipeManager$Type, arg1: $JsonObject$Type): boolean
 "createRecipeContext"(arg0: $ReloadableServerResources$Type): any
 "checkConditions"(arg0: $JsonObject$Type): $JsonObject
}

export namespace $RecipePlatformHelper {
const INSTANCE: $Lazy<($RecipePlatformHelper)>
function get(): $RecipePlatformHelper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipePlatformHelper$Type = ($RecipePlatformHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipePlatformHelper_ = $RecipePlatformHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeFilterParseEvent, $RecipeFilterParseEvent$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilterParseEvent"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $RecipeFilter extends $Predicate<($RecipeKJS)> {

 "test"(arg0: $RecipeKJS$Type): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
 "negate"(): $Predicate<($RecipeKJS)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>

(arg0: $RecipeKJS$Type): boolean
}

export namespace $RecipeFilter {
const PARSE: $Event<($RecipeFilterParseEvent)>
function of(cx: $Context$Type, o: any): $RecipeFilter
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($RecipeKJS)>
function isEqual<T>(arg0: any): $Predicate<($RecipeKJS)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFilter$Type = (RegExp) | ("*") | ("-") | (($RecipeFilter$Type)[]) | ({"id"?: Special.RecipeId, "input"?: $InputItem$Type, "output"?: $OutputItem$Type, "or"?: $RecipeFilter$Type, "group"?: string, "type"?: Special.RecipeType, "mod"?: Special.Mod, "not"?: $RecipeFilter$Type}) | ($RecipeFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFilter_ = $RecipeFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$BasicEnchantment" {
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$EnchantmentCategory, $EnchantmentCategory$Type} from "packages/net/minecraft/world/item/enchantment/$EnchantmentCategory"
import {$MobType, $MobType$Type} from "packages/net/minecraft/world/entity/$MobType"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$EnchantmentBuilder, $EnchantmentBuilder$Type} from "packages/dev/latvian/mods/kubejs/misc/$EnchantmentBuilder"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $BasicEnchantment extends $Enchantment {
readonly "enchantmentBuilder": $EnchantmentBuilder
readonly "category": $EnchantmentCategory

constructor(b: $EnchantmentBuilder$Type)

public "getMaxCost"(i: integer): integer
public "getDamageProtection"(i: integer, damageSource: $DamageSource$Type): integer
public "getMaxLevel"(): integer
public "getMinLevel"(): integer
public "getMinCost"(i: integer): integer
public "doPostHurt"(entity: $LivingEntity$Type, target: $Entity$Type, level: integer): void
public "isTreasureOnly"(): boolean
public "isDiscoverable"(): boolean
public "isCurse"(): boolean
public "isTradeable"(): boolean
public "canEnchant"(itemStack: $ItemStack$Type): boolean
public "getDamageBonus"(i: integer, mobType: $MobType$Type): float
public "doPostAttack"(entity: $LivingEntity$Type, target: $Entity$Type, level: integer): void
get "maxLevel"(): integer
get "minLevel"(): integer
get "treasureOnly"(): boolean
get "discoverable"(): boolean
get "curse"(): boolean
get "tradeable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicEnchantment$Type = ($BasicEnchantment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicEnchantment_ = $BasicEnchantment$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$KubeJSReloadListener" {
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$PreparableReloadListener$PreparationBarrier, $PreparableReloadListener$PreparationBarrier$Type} from "packages/net/minecraft/server/packs/resources/$PreparableReloadListener$PreparationBarrier"
import {$ResourceManagerReloadListener, $ResourceManagerReloadListener$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManagerReloadListener"
import {$Executor, $Executor$Type} from "packages/java/util/concurrent/$Executor"
import {$ResourceManager, $ResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$ResourceManager"
import {$ProfilerFiller, $ProfilerFiller$Type} from "packages/net/minecraft/util/profiling/$ProfilerFiller"
import {$ReloadableServerResources, $ReloadableServerResources$Type} from "packages/net/minecraft/server/$ReloadableServerResources"

export class $KubeJSReloadListener implements $ResourceManagerReloadListener {
static "resources": $ReloadableServerResources
static "recipeContext": any

constructor()

public "onResourceManagerReload"(resourceManager: $ResourceManager$Type): void
public "reload"(arg0: $PreparableReloadListener$PreparationBarrier$Type, arg1: $ResourceManager$Type, arg2: $ProfilerFiller$Type, arg3: $ProfilerFiller$Type, arg4: $Executor$Type, arg5: $Executor$Type): $CompletableFuture<(void)>
public "getName"(): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSReloadListener$Type = ($KubeJSReloadListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSReloadListener_ = $KubeJSReloadListener$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$SmoothstepFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SmoothstepFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmoothstepFuncUnit$Type = ($SmoothstepFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmoothstepFuncUnit_ = $SmoothstepFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ClientEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"

export class $ClientEventJS extends $PlayerEventJS {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientEventJS$Type = ($ClientEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientEventJS_ = $ClientEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$EntityBlockKJS" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$EntityBlock, $EntityBlock$Type} from "packages/net/minecraft/world/level/block/$EntityBlock"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BlockEntity, $BlockEntity$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntity"
import {$BlockKJS, $BlockKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$BlockKJS"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerLevel, $ServerLevel$Type} from "packages/net/minecraft/server/level/$ServerLevel"
import {$BlockEntityTicker, $BlockEntityTicker$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityTicker"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$GameEventListener, $GameEventListener$Type} from "packages/net/minecraft/world/level/gameevent/$GameEventListener"

export interface $EntityBlockKJS extends $BlockKJS, $EntityBlock {

 "getTicker"<T extends $BlockEntity>(level: $Level$Type, blockState: $BlockState$Type, blockEntityType: $BlockEntityType$Type<(T)>): $BlockEntityTicker<(T)>
 "newBlockEntity"(blockPos: $BlockPos$Type, blockState: $BlockState$Type): $BlockEntity
 "setNameKey"(key: string): void
 "setBlockBuilder"(b: $BlockBuilder$Type): void
 "setIsRandomlyTicking"(v: boolean): void
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$Type<($RandomTickCallbackJS$Type)>): void
 "setRequiresTool"(v: boolean): void
 "setDestroySpeed"(v: float): void
 "setLightEmission"(v: integer): void
 "getIdLocation"(): $ResourceLocation
 "getId"(): string
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "setSoundType"(v: $SoundType$Type): void
 "setFriction"(v: float): void
 "getTypeData"(): $CompoundTag
 "getBlockStates"(): $List<($BlockState)>
 "getMod"(): string
 "getListener"<T extends $BlockEntity>(arg0: $ServerLevel$Type, arg1: T): $GameEventListener
 "getBlockBuilder"(): $BlockBuilder
}

export namespace $EntityBlockKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityBlockKJS$Type = ($EntityBlockKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityBlockKJS_ = $EntityBlockKJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$ShapedKubeJSRecipe" {
import {$ShapedRecipe, $ShapedRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapedRecipe"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$CraftingBookCategory, $CraftingBookCategory$Type} from "packages/net/minecraft/world/item/crafting/$CraftingBookCategory"
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KubeJSCraftingRecipe, $KubeJSCraftingRecipe$Type} from "packages/dev/latvian/mods/kubejs/recipe/special/$KubeJSCraftingRecipe"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"

export class $ShapedKubeJSRecipe extends $ShapedRecipe implements $KubeJSCraftingRecipe {
readonly "width": integer
readonly "height": integer
readonly "result": $ItemStack

constructor(id: $ResourceLocation$Type, group: string, category: $CraftingBookCategory$Type, width: integer, height: integer, ingredients: $NonNullList$Type<($Ingredient$Type)>, result: $ItemStack$Type, mirror: boolean, ingredientActions: $List$Type<($IngredientAction$Type)>, modifyResult: $ModifyRecipeResultCallback$Type, stage: string)

public "getRemainingItems"(container: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "assemble"(container: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
public "matches"(craftingContainer: $CraftingContainer$Type, level: $Level$Type): boolean
public "kjs$getModifyResult"(): $ModifyRecipeResultCallback
public "kjs$getIngredientActions"(): $List<($IngredientAction)>
public "kjs$getStage"(): string
public "kjs$getRemainingItems"(container: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "kjs$assemble"(container: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedKubeJSRecipe$Type = ($ShapedKubeJSRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedKubeJSRecipe_ = $ShapedKubeJSRecipe$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientActionFilter" {
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $IngredientActionFilter {
 "filterIndex": integer
 "filterIngredient": $Ingredient

constructor()

public "copyFrom"(filter: $IngredientActionFilter$Type): void
public "checkFilter"(index: integer, stack: $ItemStack$Type): boolean
public static "filterOf"(o: any): $IngredientActionFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IngredientActionFilter$Type = (integer) | ($Ingredient$Type) | ({"item"?: $Ingredient$Type, "index"?: integer}) | ($IngredientActionFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IngredientActionFilter_ = $IngredientActionFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/client/$ClientHelper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClientHelper {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientHelper$Type = ($ClientHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientHelper_ = $ClientHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemSmeltedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

/**
 * Invoked when an item is smelted by a player.
 */
export class $ItemSmeltedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, smelted: $ItemStack$Type)

/**
 * The item that was smelted.
 */
public "getItem"(): $ItemStack
/**
 * The player that smelted the item.
 */
public "getEntity"(): $Player
get "item"(): $ItemStack
get "entity"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemSmeltedEventJS$Type = ($ItemSmeltedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemSmeltedEventJS_ = $ItemSmeltedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptableObject" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ConstProperties, $ConstProperties$Type} from "packages/dev/latvian/mods/rhino/$ConstProperties"
import {$Callable, $Callable$Type} from "packages/dev/latvian/mods/rhino/$Callable"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$SymbolScriptable, $SymbolScriptable$Type} from "packages/dev/latvian/mods/rhino/$SymbolScriptable"
import {$WrappedExecutable, $WrappedExecutable$Type} from "packages/dev/latvian/mods/rhino/$WrappedExecutable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"
import {$ExternalArrayData, $ExternalArrayData$Type} from "packages/dev/latvian/mods/rhino/$ExternalArrayData"

export class $ScriptableObject implements $Scriptable, $SymbolScriptable, $ConstProperties {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(scope: $Scriptable$Type, prototype: $Scriptable$Type)
constructor()

public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, key: any): any
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public static "getProperty"(obj: $Scriptable$Type, index: integer, cx: $Context$Type): any
public static "getProperty"(obj: $Scriptable$Type, key: $Symbol$Type, cx: $Context$Type): any
public static "getProperty"(obj: $Scriptable$Type, name: string, cx: $Context$Type): any
public "isEmpty"(): boolean
public "size"(): integer
public "isSealed"(cx: $Context$Type): boolean
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$Type, clazz: $Class$Type<(T)>, sealed: boolean, cx: $Context$Type): void
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$Type, clazz: $Class$Type<(T)>, cx: $Context$Type): void
public static "defineClass"<T extends $Scriptable>(scope: $Scriptable$Type, clazz: $Class$Type<(T)>, sealed: boolean, mapInheritance: boolean, cx: $Context$Type): string
public "delete"(cx: $Context$Type, key: $Symbol$Type): void
public "delete"(cx: $Context$Type, name: string): void
public "delete"(cx: $Context$Type, index: integer): void
public static "getDefaultValue"(object: $Scriptable$Type, typeHint: $Class$Type<(any)>, cx: $Context$Type): any
public "getDefaultValue"(cx: $Context$Type, typeHint: $Class$Type<(any)>): any
public "getAttributes"(cx: $Context$Type, name: string): integer
public "getAttributes"(cx: $Context$Type, sym: $Symbol$Type): integer
public "getAttributes"(cx: $Context$Type, index: integer): integer
public "getClassName"(): string
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, name: string, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "getGetterOrSetter"(name: string, index: integer, isSetter: boolean): any
public "associateValue"(key: any, value: any): any
public static "putProperty"(obj: $Scriptable$Type, index: integer, value: any, cx: $Context$Type): void
public static "putProperty"(obj: $Scriptable$Type, name: string, value: any, cx: $Context$Type): void
public static "putProperty"(obj: $Scriptable$Type, key: $Symbol$Type, value: any, cx: $Context$Type): void
public "setAttributes"(cx: $Context$Type, name: string, attributes: integer): void
public "setAttributes"(cx: $Context$Type, key: $Symbol$Type, attributes: integer): void
public "setAttributes"(cx: $Context$Type, index: integer, attributes: integer): void
public static "hasProperty"(obj: $Scriptable$Type, key: $Symbol$Type, cx: $Context$Type): boolean
public static "hasProperty"(obj: $Scriptable$Type, index: integer, cx: $Context$Type): boolean
public static "hasProperty"(obj: $Scriptable$Type, name: string, cx: $Context$Type): boolean
public "setParentScope"(m: $Scriptable$Type): void
public "isConst"(name: string): boolean
public "defineOwnProperty"(cx: $Context$Type, id: any, desc: $ScriptableObject$Type): void
public "defineProperty"(cx: $Context$Type, propertyName: string, delegateTo: any, getter: $WrappedExecutable$Type, setter: $WrappedExecutable$Type, attributes: integer): void
public "defineProperty"(cx: $Context$Type, key: $Symbol$Type, value: any, attributes: integer): void
public static "defineProperty"(destination: $Scriptable$Type, propertyName: string, value: any, attributes: integer, cx: $Context$Type): void
public "defineProperty"(cx: $Context$Type, propertyName: string, value: any, attributes: integer): void
public "defineProperty"(cx: $Context$Type, propertyName: string, clazz: $Class$Type<(any)>, attributes: integer): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getTypeOf"(): $MemberType
public "setGetterOrSetter"(cx: $Context$Type, name: string, index: integer, getterOrSetter: $Callable$Type, isSetter: boolean): void
public static "getTopScopeValue"(scope: $Scriptable$Type, key: any, cx: $Context$Type): any
public "getAssociatedValue"(key: any): any
public "putConst"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public static "getPropertyIds"(cx: $Context$Type, obj: $Scriptable$Type): (any)[]
public static "putConstProperty"(obj: $Scriptable$Type, name: string, value: any, cx: $Context$Type): void
public static "getClassPrototype"(scope: $Scriptable$Type, className: string, cx: $Context$Type): $Scriptable
public static "getTopLevelScope"(obj: $Scriptable$Type): $Scriptable
public "sealObject"(cx: $Context$Type): void
public static "redefineProperty"(obj: $Scriptable$Type, name: string, isConst: boolean, cx: $Context$Type): void
public "defineConst"(cx: $Context$Type, name: string, start: $Scriptable$Type): void
public "getIds"(cx: $Context$Type): (any)[]
public "preventExtensions"(): void
public "isExtensible"(): boolean
public static "deleteProperty"(obj: $Scriptable$Type, index: integer, cx: $Context$Type): boolean
public static "deleteProperty"(obj: $Scriptable$Type, name: string, cx: $Context$Type): boolean
public "hasInstance"(cx: $Context$Type, instance: $Scriptable$Type): boolean
public static "getObjectPrototype"(scope: $Scriptable$Type, cx: $Context$Type): $Scriptable
public static "defineConstProperty"(destination: $Scriptable$Type, propertyName: string, cx: $Context$Type): void
public static "getGeneratorFunctionPrototype"(scope: $Scriptable$Type, cx: $Context$Type): $Scriptable
public "setExternalArrayData"(cx: $Context$Type, array: $ExternalArrayData$Type): void
public "defineOwnProperties"(cx: $Context$Type, props: $ScriptableObject$Type): void
public "getExternalArrayLength"(): any
public "getExternalArrayData"(): $ExternalArrayData
public "avoidObjectDetection"(): boolean
public "defineFunctionProperties"(cx: $Context$Type, names: (string)[], clazz: $Class$Type<(any)>, attributes: integer): void
public static "getFunctionPrototype"(scope: $Scriptable$Type, cx: $Context$Type): $Scriptable
public static "getArrayPrototype"(scope: $Scriptable$Type, cx: $Context$Type): $Scriptable
public "getPrototype"(cx: $Context$Type): $Scriptable
public "setPrototype"(m: $Scriptable$Type): void
public "enumerationIteratorHasNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
public "enumerationIteratorNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
get "empty"(): boolean
get "className"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
get "typeOf"(): $MemberType
get "extensible"(): boolean
get "externalArrayLength"(): any
get "externalArrayData"(): $ExternalArrayData
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptableObject$Type = ($ScriptableObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptableObject_ = $ScriptableObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ComponentRole extends $Enum<($ComponentRole)> {
static readonly "INPUT": $ComponentRole
static readonly "OUTPUT": $ComponentRole
static readonly "OTHER": $ComponentRole


public static "values"(): ($ComponentRole)[]
public static "valueOf"(name: string): $ComponentRole
public "isOther"(): boolean
public "isInput"(): boolean
public "isOutput"(): boolean
get "other"(): boolean
get "input"(): boolean
get "output"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRole$Type = (("output") | ("input") | ("other")) | ($ComponentRole);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentRole_ = $ComponentRole$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$SwitchCase" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$List, $List$Type} from "packages/java/util/$List"

export class $SwitchCase extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "isDefault"(): boolean
public "getExpression"(): $AstNode
public "getStatements"(): $List<($AstNode)>
public "setStatements"(statements: $List$Type<($AstNode$Type)>): void
public "setExpression"(expression: $AstNode$Type): void
public "addStatement"(statement: $AstNode$Type): void
get "default"(): boolean
get "expression"(): $AstNode
get "statements"(): $List<($AstNode)>
set "statements"(value: $List$Type<($AstNode$Type)>)
set "expression"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwitchCase$Type = ($SwitchCase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SwitchCase_ = $SwitchCase$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$KeywordLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $KeywordLiteral extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, nodeType: integer)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "isBooleanLiteral"(): boolean
get "booleanLiteral"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeywordLiteral$Type = ($KeywordLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeywordLiteral_ = $KeywordLiteral$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$SinFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SinFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SinFuncUnit$Type = ($SinFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SinFuncUnit_ = $SinFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ObjectLiteral" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$DestructuringForm, $DestructuringForm$Type} from "packages/dev/latvian/mods/rhino/ast/$DestructuringForm"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ObjectProperty, $ObjectProperty$Type} from "packages/dev/latvian/mods/rhino/ast/$ObjectProperty"

export class $ObjectLiteral extends $AstNode implements $DestructuringForm {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "addElement"(element: $ObjectProperty$Type): void
public "getElements"(): $List<($ObjectProperty)>
public "setIsDestructuring"(destructuring: boolean): void
public "isDestructuring"(): boolean
public "setElements"(elements: $List$Type<($ObjectProperty$Type)>): void
get "elements"(): $List<($ObjectProperty)>
get "destructuring"(): boolean
set "elements"(value: $List$Type<($ObjectProperty$Type)>)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectLiteral$Type = ($ObjectLiteral);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectLiteral_ = $ObjectLiteral$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$JEIPlugin" {
import {$IGuiHandlerRegistration, $IGuiHandlerRegistration$Type} from "packages/mezz/jei/api/registration/$IGuiHandlerRegistration"
import {$IJeiConfigManager, $IJeiConfigManager$Type} from "packages/mezz/jei/api/runtime/config/$IJeiConfigManager"
import {$IAdvancedRegistration, $IAdvancedRegistration$Type} from "packages/mezz/jei/api/registration/$IAdvancedRegistration"
import {$IVanillaCategoryExtensionRegistration, $IVanillaCategoryExtensionRegistration$Type} from "packages/mezz/jei/api/registration/$IVanillaCategoryExtensionRegistration"
import {$FluidStack, $FluidStack$Type} from "packages/net/minecraftforge/fluids/$FluidStack"
import {$IRecipeRegistration, $IRecipeRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeRegistration"
import {$IRecipeTransferRegistration, $IRecipeTransferRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeTransferRegistration"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$FluidStack as $FluidStack$0, $FluidStack$Type as $FluidStack$0$Type} from "packages/dev/architectury/fluid/$FluidStack"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"
import {$IRecipeCatalystRegistration, $IRecipeCatalystRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCatalystRegistration"
import {$IModPlugin, $IModPlugin$Type} from "packages/mezz/jei/api/$IModPlugin"
import {$IRuntimeRegistration, $IRuntimeRegistration$Type} from "packages/mezz/jei/api/registration/$IRuntimeRegistration"
import {$IRecipeCategoryRegistration, $IRecipeCategoryRegistration$Type} from "packages/mezz/jei/api/registration/$IRecipeCategoryRegistration"
import {$IModIngredientRegistration, $IModIngredientRegistration$Type} from "packages/mezz/jei/api/registration/$IModIngredientRegistration"
import {$ISubtypeRegistration, $ISubtypeRegistration$Type} from "packages/mezz/jei/api/registration/$ISubtypeRegistration"
import {$IPlatformFluidHelper, $IPlatformFluidHelper$Type} from "packages/mezz/jei/api/helpers/$IPlatformFluidHelper"

export class $JEIPlugin implements $IModPlugin {
static readonly "ID": $ResourceLocation
 "runtime": $IJeiRuntime

constructor()

public "registerItemSubtypes"(registration: $ISubtypeRegistration$Type): void
public static "fromArchitectury"(stack: $FluidStack$0$Type): $FluidStack
public "getPluginUid"(): $ResourceLocation
public "registerRecipes"(registration: $IRecipeRegistration$Type): void
public "onRuntimeAvailable"(r: $IJeiRuntime$Type): void
public "registerVanillaCategoryExtensions"(arg0: $IVanillaCategoryExtensionRegistration$Type): void
public "registerFluidSubtypes"<T>(arg0: $ISubtypeRegistration$Type, arg1: $IPlatformFluidHelper$Type<(T)>): void
public "onConfigManagerAvailable"(arg0: $IJeiConfigManager$Type): void
public "registerGuiHandlers"(arg0: $IGuiHandlerRegistration$Type): void
public "onRuntimeUnavailable"(): void
public "registerIngredients"(arg0: $IModIngredientRegistration$Type): void
public "registerRecipeTransferHandlers"(arg0: $IRecipeTransferRegistration$Type): void
public "registerRecipeCatalysts"(arg0: $IRecipeCatalystRegistration$Type): void
public "registerAdvanced"(arg0: $IAdvancedRegistration$Type): void
public "registerCategories"(arg0: $IRecipeCategoryRegistration$Type): void
public "registerRuntime"(arg0: $IRuntimeRegistration$Type): void
get "pluginUid"(): $ResourceLocation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JEIPlugin$Type = ($JEIPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JEIPlugin_ = $JEIPlugin$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$EventHandler" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$ScriptTypePredicate, $ScriptTypePredicate$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypePredicate"
import {$EventResult, $EventResult$Type} from "packages/dev/latvian/mods/kubejs/event/$EventResult"
import {$EventHandlerContainer, $EventHandlerContainer$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandlerContainer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ScriptType, $ScriptType$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptType"
import {$ScriptTypeHolder, $ScriptTypeHolder$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptTypeHolder"
import {$EventHandlerInvoker, $EventHandlerInvoker$Type} from "packages/dev/latvian/mods/kubejs/core/mixin/common/$EventHandlerInvoker"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IEventHandler, $IEventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$IEventHandler"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"
import {$EventExceptionHandler, $EventExceptionHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventExceptionHandler"

export class $EventHandler extends $BaseFunction implements $EventHandlerInvoker {
readonly "group": $EventGroup
readonly "name": string
readonly "scriptTypePredicate": $ScriptTypePredicate
readonly "eventType": $Supplier<($Class<(any)>)>
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "toString"(): string
public "listen"(type: $ScriptType$Type, extraId: any, handler: $IEventHandler$Type): void
public "post"(type: $ScriptTypeHolder$Type, extraId: any, event: $EventJS$Type): $EventResult
public "post"(event: $EventJS$Type, extraId: any, exh: $EventExceptionHandler$Type): $EventResult
public "post"(scriptType: $ScriptTypeHolder$Type, event: $EventJS$Type, exh: $EventExceptionHandler$Type): $EventResult
public "post"(event: $EventJS$Type, extraId: any): $EventResult
public "post"(type: $ScriptTypeHolder$Type, extraId: any, event: $EventJS$Type, exh: $EventExceptionHandler$Type): $EventResult
public "post"(extraId: any, event: $EventJS$Type): boolean
public "post"(event: $EventJS$Type): boolean
public "post"(scriptType: $ScriptTypeHolder$Type, event: $EventJS$Type): $EventResult
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "findUniqueExtraIds"(type: $ScriptType$Type): $Set<(any)>
public "cancelable"(): $EventHandler
public "hasListeners"(extraId: any): boolean
public "hasListeners"(): boolean
public "forEachListener"(type: $ScriptType$Type, callback: $Consumer$Type<($EventHandlerContainer$Type)>): void
public "getHasResult"(): boolean
public "hasResult"(): $EventHandler
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EventHandler$Type = ($EventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EventHandler_ = $EventHandler$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$AstNode" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$FunctionNode, $FunctionNode$Type} from "packages/dev/latvian/mods/rhino/ast/$FunctionNode"
import {$Scope, $Scope$Type} from "packages/dev/latvian/mods/rhino/ast/$Scope"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$AstRoot, $AstRoot$Type} from "packages/dev/latvian/mods/rhino/ast/$AstRoot"

export class $AstNode extends $Node implements $Comparable<($AstNode)> {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer)
constructor()
constructor(pos: integer, len: integer)

public "getLength"(): integer
public "compareTo"(other: $AstNode$Type): integer
public "getParent"(): $AstNode
public "depth"(): integer
public "setLength"(length: integer): void
public "setParent"(parent: $AstNode$Type): void
public "shortName"(): string
public "getPosition"(): integer
public "getEnclosingFunction"(): $FunctionNode
public "getAbsolutePosition"(): integer
public "getLineno"(): integer
public "setRelative"(parentPosition: integer): void
public "setInlineComment"(inlineComment: $AstNode$Type): void
public "hasSideEffects"(): boolean
public "getInlineComment"(): $AstNode
public "getAstRoot"(): $AstRoot
public "addChild"(kid: $AstNode$Type): void
public "getEnclosingScope"(): $Scope
public static "codeBug"(): $RuntimeException
public "setBounds"(position: integer, end: integer): void
public "setPosition"(position: integer): void
get "length"(): integer
get "parent"(): $AstNode
set "length"(value: integer)
set "parent"(value: $AstNode$Type)
get "position"(): integer
get "enclosingFunction"(): $FunctionNode
get "absolutePosition"(): integer
get "lineno"(): integer
set "relative"(value: integer)
set "inlineComment"(value: $AstNode$Type)
get "inlineComment"(): $AstNode
get "astRoot"(): $AstRoot
get "enclosingScope"(): $Scope
set "position"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AstNode$Type = ($AstNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AstNode_ = $AstNode$Type;
}}
declare module "packages/dev/latvian/mods/rhino/annotations/$JSGetter" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $JSGetter extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $JSGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JSGetter$Type = ($JSGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JSGetter_ = $JSGetter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemHandlerUtils" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemHandlerUtils {

constructor()

public static "giveItemToPlayer"(player: $Player$Type, stack: $ItemStack$Type, preferredSlot: integer): void
public static "canItemStacksStackRelaxed"(a: $ItemStack$Type, b: $ItemStack$Type): boolean
public static "insertItemStacked"(inventory: $InventoryKJS$Type, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "insertItem"(dest: $InventoryKJS$Type, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public static "canItemStacksStack"(a: $ItemStack$Type, b: $ItemStack$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemHandlerUtils$Type = ($ItemHandlerUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemHandlerUtils_ = $ItemHandlerUtils$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$EntityPotionEffectsJS" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$MobEffectInstance, $MobEffectInstance$Type} from "packages/net/minecraft/world/effect/$MobEffectInstance"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $EntityPotionEffectsJS {

constructor(e: $LivingEntity$Type)

public "add"(mobEffect: $MobEffect$Type, duration: integer): void
public "add"(mobEffect: $MobEffect$Type, duration: integer, amplifier: integer): void
public "add"(mobEffect: $MobEffect$Type): void
public "add"(mobEffect: $MobEffect$Type, duration: integer, amplifier: integer, ambient: boolean, showParticles: boolean): void
public "clear"(): void
public "isActive"(mobEffect: $MobEffect$Type): boolean
public "getMap"(): $Map<($MobEffect), ($MobEffectInstance)>
public "getDuration"(mobEffect: $MobEffect$Type): integer
public "getActive"(mobEffect: $MobEffect$Type): $MobEffectInstance
public "getActive"(): $Collection<($MobEffectInstance)>
public "isApplicable"(effect: $MobEffectInstance$Type): boolean
get "map"(): $Map<($MobEffect), ($MobEffectInstance)>
get "active"(): $Collection<($MobEffectInstance)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityPotionEffectsJS$Type = ($EntityPotionEffectsJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityPotionEffectsJS_ = $EntityPotionEffectsJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeStringIterator" {
import {$ES6Iterator, $ES6Iterator$Type} from "packages/dev/latvian/mods/rhino/$ES6Iterator"

export class $NativeStringIterator extends $ES6Iterator {
static readonly "NEXT_METHOD": string
static readonly "DONE_PROPERTY": string
static readonly "RETURN_PROPERTY": string
static readonly "VALUE_PROPERTY": string
static readonly "RETURN_METHOD": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getClassName"(): string
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeStringIterator$Type = ($NativeStringIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeStringIterator_ = $NativeStringIterator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents$ScheduledEvent" {
import {$ScheduledEvents, $ScheduledEvents$Type} from "packages/dev/latvian/mods/kubejs/util/$ScheduledEvents"

export class $ScheduledEvents$ScheduledEvent {
 "scheduledEvents": $ScheduledEvents
 "id": integer
 "ofTicks": boolean
 "repeating": boolean
 "timer": long
 "endTime": long

constructor()

public "clear"(): void
public "reschedule"(): $ScheduledEvents$ScheduledEvent
public "reschedule"(timer: long): $ScheduledEvents$ScheduledEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScheduledEvents$ScheduledEvent$Type = ($ScheduledEvents$ScheduledEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScheduledEvents$ScheduledEvent_ = $ScheduledEvents$ScheduledEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/gamestages/$GameStageClientHelper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $GameStageClientHelper {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GameStageClientHelper$Type = ($GameStageClientHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GameStageClientHelper_ = $GameStageClientHelper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback" {
import {$ModifyRecipeCraftingGrid, $ModifyRecipeCraftingGrid$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeCraftingGrid"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $ModifyRecipeResultCallback {

 "modify"(arg0: $ModifyRecipeCraftingGrid$Type, arg1: $ItemStack$Type): $ItemStack

(arg0: $ModifyRecipeCraftingGrid$Type, arg1: $ItemStack$Type): $ItemStack
}

export namespace $ModifyRecipeResultCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModifyRecipeResultCallback$Type = ($ModifyRecipeResultCallback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModifyRecipeResultCallback_ = $ModifyRecipeResultCallback$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ReturnStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export class $ReturnStatement extends $AstNode {
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer, returnValue: $AstNode$Type)
constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getReturnValue"(): $AstNode
public "setReturnValue"(returnValue: $AstNode$Type): void
get "returnValue"(): $AstNode
set "returnValue"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReturnStatement$Type = ($ReturnStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReturnStatement_ = $ReturnStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/$NonnullByDefault" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $NonnullByDefault extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $NonnullByDefault {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NonnullByDefault$Type = ($NonnullByDefault);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NonnullByDefault_ = $NonnullByDefault$Type;
}}
declare module "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapperProviderHolder" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$CustomJavaToJsWrapperProvider, $CustomJavaToJsWrapperProvider$Type} from "packages/dev/latvian/mods/rhino/util/$CustomJavaToJsWrapperProvider"

export class $CustomJavaToJsWrapperProviderHolder<T> extends $Record {

constructor(predicate: $Predicate$Type<(T)>, provider: $CustomJavaToJsWrapperProvider$Type<(T)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "provider"(): $CustomJavaToJsWrapperProvider<(T)>
public "create"(object: T): $CustomJavaToJsWrapperProvider<(T)>
public "predicate"(): $Predicate<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomJavaToJsWrapperProviderHolder$Type<T> = ($CustomJavaToJsWrapperProviderHolder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomJavaToJsWrapperProviderHolder_<T> = $CustomJavaToJsWrapperProviderHolder$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/special/$ShapelessKubeJSRecipe" {
import {$RegistryAccess, $RegistryAccess$Type} from "packages/net/minecraft/core/$RegistryAccess"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$NonNullList, $NonNullList$Type} from "packages/net/minecraft/core/$NonNullList"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$IngredientAction, $IngredientAction$Type} from "packages/dev/latvian/mods/kubejs/recipe/ingredientaction/$IngredientAction"
import {$ShapelessRecipe, $ShapelessRecipe$Type} from "packages/net/minecraft/world/item/crafting/$ShapelessRecipe"
import {$List, $List$Type} from "packages/java/util/$List"
import {$KubeJSCraftingRecipe, $KubeJSCraftingRecipe$Type} from "packages/dev/latvian/mods/kubejs/recipe/special/$KubeJSCraftingRecipe"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$CraftingContainer, $CraftingContainer$Type} from "packages/net/minecraft/world/inventory/$CraftingContainer"

export class $ShapelessKubeJSRecipe extends $ShapelessRecipe implements $KubeJSCraftingRecipe {
readonly "group": string
readonly "result": $ItemStack
readonly "ingredients": $NonNullList<($Ingredient)>

constructor(original: $ShapelessRecipe$Type, ingredientActions: $List$Type<($IngredientAction$Type)>, modifyResult: $ModifyRecipeResultCallback$Type, stage: string)

public "getRemainingItems"(container: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "getSerializer"(): $RecipeSerializer<(any)>
public "assemble"(container: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
public "kjs$getModifyResult"(): $ModifyRecipeResultCallback
public "kjs$getIngredientActions"(): $List<($IngredientAction)>
public "kjs$getStage"(): string
public "kjs$getRemainingItems"(container: $CraftingContainer$Type): $NonNullList<($ItemStack)>
public "kjs$assemble"(container: $CraftingContainer$Type, registryAccess: $RegistryAccess$Type): $ItemStack
get "serializer"(): $RecipeSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapelessKubeJSRecipe$Type = ($ShapelessKubeJSRecipe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapelessKubeJSRecipe_ = $ShapelessKubeJSRecipe$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/custom/$ItemToolTierRegistryEventJS" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$MutableToolTier, $MutableToolTier$Type} from "packages/dev/latvian/mods/kubejs/item/$MutableToolTier"

/**
 * Invoked when the game is starting up and the item tool tiers are being registered.
 */
export class $ItemToolTierRegistryEventJS extends $StartupEventJS {

constructor()

/**
 * Adds a new tool tier.
 */
public "add"(id: string, tier: $Consumer$Type<($MutableToolTier$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemToolTierRegistryEventJS$Type = ($ItemToolTierRegistryEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemToolTierRegistryEventJS_ = $ItemToolTierRegistryEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$NodeVisitor" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"

export interface $NodeVisitor {

 "visit"(arg0: $AstNode$Type): boolean

(arg0: $AstNode$Type): boolean
}

export namespace $NodeVisitor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NodeVisitor$Type = ($NodeVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NodeVisitor_ = $NodeVisitor$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$GenerateClientAssetsEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$VariantBlockStateGenerator, $VariantBlockStateGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$VariantBlockStateGenerator"
import {$MultipartBlockStateGenerator, $MultipartBlockStateGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$MultipartBlockStateGenerator"
import {$AssetJsonGenerator, $AssetJsonGenerator$Type} from "packages/dev/latvian/mods/kubejs/generator/$AssetJsonGenerator"
import {$ModelGenerator, $ModelGenerator$Type} from "packages/dev/latvian/mods/kubejs/client/$ModelGenerator"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $GenerateClientAssetsEventJS extends $EventJS {
readonly "generator": $AssetJsonGenerator

constructor(gen: $AssetJsonGenerator$Type)

public "add"(location: $ResourceLocation$Type, json: $JsonElement$Type): void
public "addModel"(type: string, id: $ResourceLocation$Type, consumer: $Consumer$Type<($ModelGenerator$Type)>): void
public "addBlockState"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($VariantBlockStateGenerator$Type)>): void
public "addLang"(key: string, value: string): void
public "stencil"(target: $ResourceLocation$Type, stencil: string, colors: $JsonObject$Type): void
public "addMultipartBlockState"(id: $ResourceLocation$Type, consumer: $Consumer$Type<($MultipartBlockStateGenerator$Type)>): void
public "defaultHandheldItemModel"(id: $ResourceLocation$Type): void
public "defaultItemModel"(id: $ResourceLocation$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenerateClientAssetsEventJS$Type = ($GenerateClientAssetsEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenerateClientAssetsEventJS_ = $GenerateClientAssetsEventJS$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$TimeUnit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $TimeUnit extends $FuncUnit {
static readonly "FACTORY": $FunctionFactory
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public static "time"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimeUnit$Type = ($TimeUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimeUnit_ = $TimeUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$LivingEntityDeathEventJS" {
import {$DamageSource, $DamageSource$Type} from "packages/net/minecraft/world/damagesource/$DamageSource"
import {$LivingEntityEventJS, $LivingEntityEventJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$LivingEntityEventJS"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"

/**
 * Invoked before a living entity dies.
 * 
 * **NOTE**: You need to set hp to > 0 besides cancelling the event to prevent the entity from dying.
 */
export class $LivingEntityDeathEventJS extends $LivingEntityEventJS {

constructor(entity: $LivingEntity$Type, source: $DamageSource$Type)

/**
 * The damage source that triggers the death.
 */
public "getSource"(): $DamageSource
/**
 * The entity that dies.
 */
public "getEntity"(): $LivingEntity
get "source"(): $DamageSource
get "entity"(): $LivingEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LivingEntityDeathEventJS$Type = ($LivingEntityDeathEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LivingEntityDeathEventJS_ = $LivingEntityDeathEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValueFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $RecipeComponentValueFunction extends $BaseFunction {
readonly "recipe": $RecipeJS
readonly "componentValue": $RecipeComponentValue<(any)>
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(recipe: $RecipeJS$Type, componentValue: $RecipeComponentValue$Type<(any)>)

public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): $RecipeJS
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentValueFunction$Type = ($RecipeComponentValueFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentValueFunction_ = $RecipeComponentValueFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$DefiningClassLoader" {
import {$GeneratedClassLoader, $GeneratedClassLoader$Type} from "packages/dev/latvian/mods/rhino/$GeneratedClassLoader"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $DefiningClassLoader extends $ClassLoader implements $GeneratedClassLoader {

constructor()
constructor(parentLoader: $ClassLoader$Type)

public "loadClass"(name: string, resolve: boolean): $Class<(any)>
public "defineClass"(name: string, data: (byte)[]): $Class<(any)>
public "linkClass"(cl: $Class$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefiningClassLoader$Type = ($DefiningClassLoader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefiningClassLoader_ = $DefiningClassLoader$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$PlatformWrapper$ModInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $PlatformWrapper$ModInfo {

constructor(i: string)

public "getName"(): string
public "setName"(n: string): void
public "getId"(): string
public "getVersion"(): string
public "getCustomName"(): string
get "name"(): string
set "name"(value: string)
get "id"(): string
get "version"(): string
get "customName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformWrapper$ModInfo$Type = ($PlatformWrapper$ModInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformWrapper$ModInfo_ = $PlatformWrapper$ModInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$AfterRecipesLoadedEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$RecipeKJS, $RecipeKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$RecipeKJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$RecipeFilter, $RecipeFilter$Type} from "packages/dev/latvian/mods/kubejs/recipe/filter/$RecipeFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Recipe, $Recipe$Type} from "packages/net/minecraft/world/item/crafting/$Recipe"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AfterRecipesLoadedEventJS extends $EventJS {

constructor(r: $Map$Type<($RecipeType$Type<(any)>), ($Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>)>, n: $Map$Type<($ResourceLocation$Type), ($Recipe$Type<(any)>)>)

public "remove"(filter: $RecipeFilter$Type): integer
public "forEachRecipe"(filter: $RecipeFilter$Type, consumer: $Consumer$Type<($RecipeKJS$Type)>): void
public "countRecipes"(filter: $RecipeFilter$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AfterRecipesLoadedEventJS$Type = ($AfterRecipesLoadedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AfterRecipesLoadedEventJS_ = $AfterRecipesLoadedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaObject" {
import {$CustomProperty, $CustomProperty$Type} from "packages/dev/latvian/mods/rhino/$CustomProperty"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$SymbolScriptable, $SymbolScriptable$Type} from "packages/dev/latvian/mods/rhino/$SymbolScriptable"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Symbol, $Symbol$Type} from "packages/dev/latvian/mods/rhino/$Symbol"
import {$ScriptableObject, $ScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$ScriptableObject"
import {$Wrapper, $Wrapper$Type} from "packages/dev/latvian/mods/rhino/$Wrapper"

export class $NativeJavaObject implements $Scriptable, $SymbolScriptable, $Wrapper {

constructor(scope: $Scriptable$Type, javaObject: any, staticType: $Class$Type<(any)>, cx: $Context$Type)
constructor(scope: $Scriptable$Type, javaObject: any, staticType: $Class$Type<(any)>, isAdapter: boolean, cx: $Context$Type)
constructor()

public "get"(cx: $Context$Type, index: integer, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): any
public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, symbol: $Symbol$Type, start: $Scriptable$Type, value: any): void
public "put"(cx: $Context$Type, index: integer, start: $Scriptable$Type, value: any): void
public "delete"(cx: $Context$Type, key: $Symbol$Type): void
public "delete"(cx: $Context$Type, index: integer): void
public "delete"(cx: $Context$Type, name: string): void
public "getDefaultValue"(cx: $Context$Type, hint: $Class$Type<(any)>): any
public static "canConvert"(cx: $Context$Type, fromObj: any, to: $Class$Type<(any)>): boolean
public "unwrap"(): any
public "getClassName"(): string
public "has"(cx: $Context$Type, name: string, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, key: $Symbol$Type, start: $Scriptable$Type): boolean
public "has"(cx: $Context$Type, index: integer, start: $Scriptable$Type): boolean
public "addCustomProperty"(name: string, getter: $CustomProperty$Type): void
public "setParentScope"(m: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getIds"(cx: $Context$Type): (any)[]
public static "createInterfaceAdapter"(cx: $Context$Type, type: $Class$Type<(any)>, so: $ScriptableObject$Type): any
public "hasInstance"(cx: $Context$Type, value: $Scriptable$Type): boolean
public "getPrototype"(cx: $Context$Type): $Scriptable
public "setPrototype"(m: $Scriptable$Type): void
public "getAllIds"(cx: $Context$Type): (any)[]
public "getTypeOf"(): $MemberType
public "enumerationIteratorHasNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
public "enumerationIteratorNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
public static "unwrapped"(o: any): any
get "className"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
get "typeOf"(): $MemberType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaObject$Type = ($NativeJavaObject);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaObject_ = $NativeJavaObject$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/server/$CommandEventJS" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$ServerEventJS, $ServerEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/$ServerEventJS"
import {$CommandPerformEvent, $CommandPerformEvent$Type} from "packages/dev/architectury/event/events/common/$CommandPerformEvent"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$ParseResults, $ParseResults$Type} from "packages/com/mojang/brigadier/$ParseResults"

export class $CommandEventJS extends $ServerEventJS {
readonly "server": $MinecraftServer

constructor(e: $CommandPerformEvent$Type)

public "getException"(): $Throwable
public "getInput"(): string
public "setException"(exception: $Throwable$Type): void
public "getParseResults"(): $ParseResults<($CommandSourceStack)>
public "setParseResults"(parse: $ParseResults$Type<($CommandSourceStack$Type)>): void
public "getCommandName"(): string
get "exception"(): $Throwable
get "input"(): string
set "exception"(value: $Throwable$Type)
get "parseResults"(): $ParseResults<($CommandSourceStack)>
set "parseResults"(value: $ParseResults$Type<($CommandSourceStack$Type)>)
get "commandName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandEventJS$Type = ($CommandEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandEventJS_ = $CommandEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Color, $Color$Type} from "packages/dev/latvian/mods/rhino/mod/util/color/$Color"
import {$BlockTintFunction$Fixed, $BlockTintFunction$Fixed$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockTintFunction$Fixed"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$BlockAndTintGetter, $BlockAndTintGetter$Type} from "packages/net/minecraft/world/level/$BlockAndTintGetter"

export interface $BlockTintFunction {

 "getColor"(arg0: $BlockState$Type, arg1: $BlockAndTintGetter$Type, arg2: $BlockPos$Type, arg3: integer): $Color

(cx: $Context$Type, o: any): $BlockTintFunction
}

export namespace $BlockTintFunction {
const GRASS: $BlockTintFunction
const DEFAULT_FOLIAGE_COLOR: $Color
const FOLIAGE: $BlockTintFunction
const EVERGREEN_FOLIAGE: $BlockTintFunction$Fixed
const BIRCH_FOLIAGE: $BlockTintFunction$Fixed
const MANGROVE_FOLIAGE: $BlockTintFunction$Fixed
const WATER: $BlockTintFunction
const REDSTONE_COLORS: ($Color)[]
const REDSTONE: $BlockTintFunction
function of(cx: $Context$Type, o: any): $BlockTintFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockTintFunction$Type = (($BlockTintFunction$Type)[]) | (string) | ((state: $ItemStack, level: $BlockAndTintGetter, pos: $BlockPos, index: integer) => $Color$Type) | ($BlockTintFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockTintFunction_ = $BlockTintFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/entity/$KubeJSEntityEventHandler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSEntityEventHandler {

constructor()

public static "init"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSEntityEventHandler$Type = ($KubeJSEntityEventHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSEntityEventHandler_ = $KubeJSEntityEventHandler$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$SwitchStatement" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Jump, $Jump$Type} from "packages/dev/latvian/mods/rhino/ast/$Jump"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$SwitchCase, $SwitchCase$Type} from "packages/dev/latvian/mods/rhino/ast/$SwitchCase"

export class $SwitchStatement extends $Jump {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "setParens"(lp: integer, rp: integer): void
public "getExpression"(): $AstNode
public "setLp"(lp: integer): void
public "setRp"(rp: integer): void
public "getLp"(): integer
public "getRp"(): integer
public "setExpression"(expression: $AstNode$Type): void
public "setCases"(cases: $List$Type<($SwitchCase$Type)>): void
public "getCases"(): $List<($SwitchCase)>
public "addCase"(switchCase: $SwitchCase$Type): void
get "expression"(): $AstNode
set "lp"(value: integer)
set "rp"(value: integer)
get "lp"(): integer
get "rp"(): integer
set "expression"(value: $AstNode$Type)
set "cases"(value: $List$Type<($SwitchCase$Type)>)
get "cases"(): $List<($SwitchCase)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SwitchStatement$Type = ($SwitchStatement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SwitchStatement_ = $SwitchStatement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$BlockBuilderProvider" {
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"

export interface $BlockBuilderProvider {

 "getBlockBuilder"(): $BlockBuilder
}

export namespace $BlockBuilderProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockBuilderProvider$Type = ($BlockBuilderProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockBuilderProvider_ = $BlockBuilderProvider$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$LangEventJS" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$LangEventJS$Key, $LangEventJS$Key$Type} from "packages/dev/latvian/mods/kubejs/client/$LangEventJS$Key"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $LangEventJS extends $EventJS {
static readonly "PATTERN": $Pattern
readonly "lang": string
readonly "map": $Map<($LangEventJS$Key), (string)>

constructor(lang: string, map: $Map$Type<($LangEventJS$Key$Type), (string)>)

public "add"(namespace: string, key: string, value: string): void
public "add"(key: string, value: string): void
public "addAll"(namespace: string, map: $Map$Type<(string), (string)>): void
public "addAll"(map: $Map$Type<(string), (string)>): void
public "renameEntity"(id: $ResourceLocation$Type, name: string): void
public "renameBiome"(id: $ResourceLocation$Type, name: string): void
public "renameBlock"(block: $Block$Type, name: string): void
public "renameItem"(item: $ItemStack$Type, name: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LangEventJS$Type = ($LangEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LangEventJS_ = $LangEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/schema/minecraft/$StonecuttingRecipeSchema" {
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeSchema, $RecipeSchema$Type} from "packages/dev/latvian/mods/kubejs/recipe/schema/$RecipeSchema"
import {$OutputItem, $OutputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$OutputItem"

export interface $StonecuttingRecipeSchema {

}

export namespace $StonecuttingRecipeSchema {
const RESULT: $RecipeKey<($OutputItem)>
const INGREDIENT: $RecipeKey<($InputItem)>
const SCHEMA: $RecipeSchema
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StonecuttingRecipeSchema$Type = ($StonecuttingRecipeSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StonecuttingRecipeSchema_ = $StonecuttingRecipeSchema$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$ModelGenerator" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ModelGenerator$Element, $ModelGenerator$Element$Type} from "packages/dev/latvian/mods/kubejs/client/$ModelGenerator$Element"

export class $ModelGenerator {

constructor()

public "parent"(s: string): void
public "element"(consumer: $Consumer$Type<($ModelGenerator$Element$Type)>): void
public "toJson"(): $JsonObject
public "texture"(name: string, texture: string): void
public "textures"(json: $JsonObject$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModelGenerator$Type = ($ModelGenerator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModelGenerator_ = $ModelGenerator$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$ProcessingRecipeSchema$ItemApplicationRecipeJS" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$ModifyRecipeResultCallback, $ModifyRecipeResultCallback$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ModifyRecipeResultCallback"
import {$ProcessingRecipeSchema$ProcessingRecipeJS, $ProcessingRecipeSchema$ProcessingRecipeJS$Type} from "packages/dev/latvian/mods/kubejs/create/$ProcessingRecipeSchema$ProcessingRecipeJS"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeTypeFunction, $RecipeTypeFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeTypeFunction"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $ProcessingRecipeSchema$ItemApplicationRecipeJS extends $ProcessingRecipeSchema$ProcessingRecipeJS {
static "itemErrors": boolean
 "id": $ResourceLocation
 "type": $RecipeTypeFunction
 "newRecipe": boolean
 "removed": boolean
 "modifyResult": $ModifyRecipeResultCallback
 "originalJson": $JsonObject
 "json": $JsonObject
 "changed": boolean

constructor()

public "keepHeldItem"(): $RecipeJS
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProcessingRecipeSchema$ItemApplicationRecipeJS$Type = ($ProcessingRecipeSchema$ItemApplicationRecipeJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProcessingRecipeSchema$ItemApplicationRecipeJS_ = $ProcessingRecipeSchema$ItemApplicationRecipeJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeJavaClass" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NativeJavaObject, $NativeJavaObject$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeJavaClass extends $NativeJavaObject implements $Function {

constructor()
constructor(cx: $Context$Type, scope: $Scriptable$Type, cl: $Class$Type<(any)>, isAdapter: boolean)
constructor(cx: $Context$Type, scope: $Scriptable$Type, cl: $Class$Type<(any)>)

public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public "put"(cx: $Context$Type, name: string, start: $Scriptable$Type, value: any): void
public "toString"(): string
public "getDefaultValue"(cx: $Context$Type, hint: $Class$Type<(any)>): any
public "getClassName"(): string
public "has"(cx: $Context$Type, name: string, start: $Scriptable$Type): boolean
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "getClassObject"(): $Class<(any)>
public "getIds"(cx: $Context$Type): (any)[]
public "hasInstance"(cx: $Context$Type, value: $Scriptable$Type): boolean
public static "unwrapped"(o: any): any
get "className"(): string
get "classObject"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeJavaClass$Type = ($NativeJavaClass);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeJavaClass_ = $NativeJavaClass$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$LerpFuncUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Func3Unit, $Func3Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func3Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $LerpFuncUnit extends $Func3Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "b": $Unit
readonly "c": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type, b: $Unit$Type, c: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public static "lerp"(a: double, b: double, c: double): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LerpFuncUnit$Type = ($LerpFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LerpFuncUnit_ = $LerpFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/$ScriptFileInfo" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ScriptPackInfo, $ScriptPackInfo$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptPackInfo"
import {$ScriptSource, $ScriptSource$Type} from "packages/dev/latvian/mods/kubejs/script/$ScriptSource"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $ScriptFileInfo {
readonly "pack": $ScriptPackInfo
readonly "file": string
readonly "id": $ResourceLocation
readonly "location": string
 "lines": (string)[]

constructor(p: $ScriptPackInfo$Type, f: string)

public "getProperty"(s: string, def: string): string
public "getProperties"(s: string): $List<(string)>
public "getPriority"(): integer
public "preload"(source: $ScriptSource$Type): void
public "skipLoading"(): string
get "priority"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptFileInfo$Type = ($ScriptFileInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptFileInfo_ = $ScriptFileInfo$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/data/$DataPackEventJS" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$MultiPackResourceManager, $MultiPackResourceManager$Type} from "packages/net/minecraft/server/packs/resources/$MultiPackResourceManager"
import {$VirtualKubeJSDataPack, $VirtualKubeJSDataPack$Type} from "packages/dev/latvian/mods/kubejs/script/data/$VirtualKubeJSDataPack"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $DataPackEventJS extends $EventJS {

constructor(d: $VirtualKubeJSDataPack$Type, rm: $MultiPackResourceManager$Type)

public "add"(id: $ResourceLocation$Type, content: string): void
public "addJson"(id: $ResourceLocation$Type, json: $JsonElement$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataPackEventJS$Type = ($DataPackEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataPackEventJS_ = $DataPackEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectProperties" {
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $PainterObjectProperties {
readonly "tag": $CompoundTag

constructor(t: $CompoundTag$Type)

public "getString"(key: string, def: string): string
public "has"(key: string, type: integer): boolean
public "hasString"(key: string): boolean
public "getUnit"(key: string, def: $Unit$Type): $Unit
public "hasAny"(key: string): boolean
public "getColor"(key: string, def: $Unit$Type): $Unit
public "getResourceLocation"(key: string, def: $ResourceLocation$Type): $ResourceLocation
public "hasNumber"(key: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PainterObjectProperties$Type = ($PainterObjectProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PainterObjectProperties_ = $PainterObjectProperties$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$KubeJSForge" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $KubeJSForge {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KubeJSForge$Type = ($KubeJSForge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KubeJSForge_ = $KubeJSForge$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$IDFilter" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BiomeModifications$BiomeContext, $BiomeModifications$BiomeContext$Type} from "packages/dev/architectury/registry/level/biome/$BiomeModifications$BiomeContext"

export class $IDFilter extends $Record implements $BiomeFilter {

constructor(id: $ResourceLocation$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(ctx: $BiomeModifications$BiomeContext$Type): boolean
public "id"(): $ResourceLocation
public static "of"(cx: $Context$Type, o: any): $BiomeFilter
public static "idFilter"(cx: $Context$Type, s: string): $BiomeFilter
public "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public "negate"(): $Predicate<($BiomeModifications$BiomeContext)>
public "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BiomeModifications$BiomeContext)>
public static "isEqual"<T>(arg0: any): $Predicate<($BiomeModifications$BiomeContext)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IDFilter$Type = ($IDFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IDFilter_ = $IDFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$WithAttachedData" {
import {$AttachedData, $AttachedData$Type} from "packages/dev/latvian/mods/kubejs/util/$AttachedData"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$MessageSenderKJS, $MessageSenderKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$MessageSenderKJS"

export interface $WithAttachedData<T> extends $MessageSenderKJS {

 "getData"(): $AttachedData<(T)>
 "setStatusMessage"(message: $Component$Type): void
 "runCommandSilent"(command: string): integer
 "getName"(): $Component
 "runCommand"(command: string): integer
 "tell"(message: $Component$Type): void
 "getDisplayName"(): $Component

(): $AttachedData<(T)>
}

export namespace $WithAttachedData {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WithAttachedData$Type<T> = ($WithAttachedData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WithAttachedData_<T> = $WithAttachedData$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$StageCreationEvent" {
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"

export class $StageCreationEvent {


public "getPlayerStages"(): $Stages
public "setPlayerStages"(s: $Stages$Type): void
public "getPlayer"(): $Player
get "playerStages"(): $Stages
set "playerStages"(value: $Stages$Type)
get "player"(): $Player
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageCreationEvent$Type = ($StageCreationEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StageCreationEvent_ = $StageCreationEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/$RemoveWorldgenEventJS" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GenerationStep$Decoration, $GenerationStep$Decoration$Type} from "packages/net/minecraft/world/level/levelgen/$GenerationStep$Decoration"
import {$StartupEventJS, $StartupEventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$StartupEventJS"
import {$RemoveSpawnsProperties, $RemoveSpawnsProperties$Type} from "packages/dev/latvian/mods/kubejs/level/gen/properties/$RemoveSpawnsProperties"
import {$BiomeFilter, $BiomeFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/biome/$BiomeFilter"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"
import {$RemoveOresProperties, $RemoveOresProperties$Type} from "packages/dev/latvian/mods/kubejs/level/gen/properties/$RemoveOresProperties"

export class $RemoveWorldgenEventJS extends $StartupEventJS {

constructor()

public "removeFeatureById"(type: $GenerationStep$Decoration$Type, ids: ($ResourceLocation$Type)[]): void
public "removeFeatureById"(filter: $BiomeFilter$Type, decoration: $GenerationStep$Decoration$Type, ids: ($ResourceLocation$Type)[]): void
public "removeSpawns"(p: $Consumer$Type<($RemoveSpawnsProperties$Type)>): void
public "removeAllFeatures"(filter: $BiomeFilter$Type): void
public "removeAllFeatures"(filter: $BiomeFilter$Type, type: $GenerationStep$Decoration$Type): void
public "removeAllFeatures"(): void
public "printFeatures"(): void
public "printFeatures"(type: $GenerationStep$Decoration$Type): void
public "printFeatures"(type: $GenerationStep$Decoration$Type, filter: $BiomeFilter$Type): void
public "printSpawns"(): void
public "printSpawns"(category: $MobCategory$Type): void
public "printFiltered"(type: $GenerationStep$Decoration$Type): void
public "printFiltered"(type: $GenerationStep$Decoration$Type, filter: $BiomeFilter$Type): void
public "printFiltered"(): void
public "removeOres"(p: $Consumer$Type<($RemoveOresProperties$Type)>): void
public "removeAllSpawns"(): void
public "printFeaturesForType"(type: $GenerationStep$Decoration$Type, filter: $BiomeFilter$Type, afterRemoval: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveWorldgenEventJS$Type = ($RemoveWorldgenEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveWorldgenEventJS_ = $RemoveWorldgenEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo" {
import {$PaintingVariant, $PaintingVariant$Type} from "packages/net/minecraft/world/entity/decoration/$PaintingVariant"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$MultiNoiseBiomeSourceParameterList, $MultiNoiseBiomeSourceParameterList$Type} from "packages/net/minecraft/world/level/biome/$MultiNoiseBiomeSourceParameterList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$StructureProcessorType, $StructureProcessorType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorType"
import {$Activity, $Activity$Type} from "packages/net/minecraft/world/entity/schedule/$Activity"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FrogVariant, $FrogVariant$Type} from "packages/net/minecraft/world/entity/animal/$FrogVariant"
import {$MemoryModuleType, $MemoryModuleType$Type} from "packages/net/minecraft/world/entity/ai/memory/$MemoryModuleType"
import {$TrimMaterial, $TrimMaterial$Type} from "packages/net/minecraft/world/item/armortrim/$TrimMaterial"
import {$BuilderType, $BuilderType$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderType"
import {$StructurePoolElementType, $StructurePoolElementType$Type} from "packages/net/minecraft/world/level/levelgen/structure/pools/$StructurePoolElementType"
import {$ArgumentTypeInfo, $ArgumentTypeInfo$Type} from "packages/net/minecraft/commands/synchronization/$ArgumentTypeInfo"
import {$Instrument, $Instrument$Type} from "packages/net/minecraft/world/item/$Instrument"
import {$ParticleType, $ParticleType$Type} from "packages/net/minecraft/core/particles/$ParticleType"
import {$VillagerType, $VillagerType$Type} from "packages/net/minecraft/world/entity/npc/$VillagerType"
import {$BlockEntityType, $BlockEntityType$Type} from "packages/net/minecraft/world/level/block/entity/$BlockEntityType"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$WorldCarver, $WorldCarver$Type} from "packages/net/minecraft/world/level/levelgen/carver/$WorldCarver"
import {$PosRuleTestType, $PosRuleTestType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$PosRuleTestType"
import {$ChatType, $ChatType$Type} from "packages/net/minecraft/network/chat/$ChatType"
import {$StructurePlacementType, $StructurePlacementType$Type} from "packages/net/minecraft/world/level/levelgen/structure/placement/$StructurePlacementType"
import {$WorldPreset, $WorldPreset$Type} from "packages/net/minecraft/world/level/levelgen/presets/$WorldPreset"
import {$BlockPredicateType, $BlockPredicateType$Type} from "packages/net/minecraft/world/level/levelgen/blockpredicates/$BlockPredicateType"
import {$RegistryCallback, $RegistryCallback$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryCallback"
import {$Registrar, $Registrar$Type} from "packages/dev/architectury/registry/registries/$Registrar"
import {$Fluid, $Fluid$Type} from "packages/net/minecraft/world/level/material/$Fluid"
import {$FloatProviderType, $FloatProviderType$Type} from "packages/net/minecraft/util/valueproviders/$FloatProviderType"
import {$FoliagePlacerType, $FoliagePlacerType$Type} from "packages/net/minecraft/world/level/levelgen/feature/foliageplacers/$FoliagePlacerType"
import {$StatType, $StatType$Type} from "packages/net/minecraft/stats/$StatType"
import {$VillagerProfession, $VillagerProfession$Type} from "packages/net/minecraft/world/entity/npc/$VillagerProfession"
import {$Potion, $Potion$Type} from "packages/net/minecraft/world/item/alchemy/$Potion"
import {$RecipeType, $RecipeType$Type} from "packages/net/minecraft/world/item/crafting/$RecipeType"
import {$Structure, $Structure$Type} from "packages/net/minecraft/world/level/levelgen/structure/$Structure"
import {$Biome, $Biome$Type} from "packages/net/minecraft/world/level/biome/$Biome"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$StructureType, $StructureType$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureType"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$LevelStem, $LevelStem$Type} from "packages/net/minecraft/world/level/dimension/$LevelStem"
import {$DimensionType, $DimensionType$Type} from "packages/net/minecraft/world/level/dimension/$DimensionType"
import {$FlatLevelGeneratorPreset, $FlatLevelGeneratorPreset$Type} from "packages/net/minecraft/world/level/levelgen/flat/$FlatLevelGeneratorPreset"
import {$DamageType, $DamageType$Type} from "packages/net/minecraft/world/damagesource/$DamageType"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$TrimPattern, $TrimPattern$Type} from "packages/net/minecraft/world/item/armortrim/$TrimPattern"
import {$ResourceKey, $ResourceKey$Type} from "packages/net/minecraft/resources/$ResourceKey"
import {$NoiseGeneratorSettings, $NoiseGeneratorSettings$Type} from "packages/net/minecraft/world/level/levelgen/$NoiseGeneratorSettings"
import {$ConfiguredWorldCarver, $ConfiguredWorldCarver$Type} from "packages/net/minecraft/world/level/levelgen/carver/$ConfiguredWorldCarver"
import {$TreeDecoratorType, $TreeDecoratorType$Type} from "packages/net/minecraft/world/level/levelgen/feature/treedecorators/$TreeDecoratorType"
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Schedule, $Schedule$Type} from "packages/net/minecraft/world/entity/schedule/$Schedule"
import {$StructureProcessorList, $StructureProcessorList$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$StructureProcessorList"
import {$PoiType, $PoiType$Type} from "packages/net/minecraft/world/entity/ai/village/poi/$PoiType"
import {$BlockStateProviderType, $BlockStateProviderType$Type} from "packages/net/minecraft/world/level/levelgen/feature/stateproviders/$BlockStateProviderType"
import {$BannerPattern, $BannerPattern$Type} from "packages/net/minecraft/world/level/block/entity/$BannerPattern"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$MenuType, $MenuType$Type} from "packages/net/minecraft/world/inventory/$MenuType"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$EntityType, $EntityType$Type} from "packages/net/minecraft/world/entity/$EntityType"
import {$HeightProviderType, $HeightProviderType$Type} from "packages/net/minecraft/world/level/levelgen/heightproviders/$HeightProviderType"
import {$RuleTestType, $RuleTestType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTestType"
import {$StructureSet, $StructureSet$Type} from "packages/net/minecraft/world/level/levelgen/structure/$StructureSet"
import {$PlacedFeature, $PlacedFeature$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacedFeature"
import {$FeatureSizeType, $FeatureSizeType$Type} from "packages/net/minecraft/world/level/levelgen/feature/featuresize/$FeatureSizeType"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$LootItemFunctionType, $LootItemFunctionType$Type} from "packages/net/minecraft/world/level/storage/loot/functions/$LootItemFunctionType"
import {$Registry, $Registry$Type} from "packages/net/minecraft/core/$Registry"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BuilderFactory, $BuilderFactory$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderFactory"
import {$DensityFunction, $DensityFunction$Type} from "packages/net/minecraft/world/level/levelgen/$DensityFunction"
import {$RootPlacerType, $RootPlacerType$Type} from "packages/net/minecraft/world/level/levelgen/feature/rootplacers/$RootPlacerType"
import {$RuleBlockEntityModifierType, $RuleBlockEntityModifierType$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/rule/blockentity/$RuleBlockEntityModifierType"
import {$Enchantment, $Enchantment$Type} from "packages/net/minecraft/world/item/enchantment/$Enchantment"
import {$ConfiguredFeature, $ConfiguredFeature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$ConfiguredFeature"
import {$LootNumberProviderType, $LootNumberProviderType$Type} from "packages/net/minecraft/world/level/storage/loot/providers/number/$LootNumberProviderType"
import {$Feature, $Feature$Type} from "packages/net/minecraft/world/level/levelgen/feature/$Feature"
import {$LinkedList, $LinkedList$Type} from "packages/java/util/$LinkedList"
import {$ChunkStatus, $ChunkStatus$Type} from "packages/net/minecraft/world/level/chunk/$ChunkStatus"
import {$StructureTemplatePool, $StructureTemplatePool$Type} from "packages/net/minecraft/world/level/levelgen/structure/pools/$StructureTemplatePool"
import {$StructurePieceType, $StructurePieceType$Type} from "packages/net/minecraft/world/level/levelgen/structure/pieces/$StructurePieceType"
import {$TrunkPlacerType, $TrunkPlacerType$Type} from "packages/net/minecraft/world/level/levelgen/feature/trunkplacers/$TrunkPlacerType"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$LootScoreProviderType, $LootScoreProviderType$Type} from "packages/net/minecraft/world/level/storage/loot/providers/score/$LootScoreProviderType"
import {$TypeWrapperFactory, $TypeWrapperFactory$Type} from "packages/dev/latvian/mods/rhino/util/wrap/$TypeWrapperFactory"
import {$Codec, $Codec$Type} from "packages/com/mojang/serialization/$Codec"
import {$NormalNoise$NoiseParameters, $NormalNoise$NoiseParameters$Type} from "packages/net/minecraft/world/level/levelgen/synth/$NormalNoise$NoiseParameters"
import {$PlacementModifierType, $PlacementModifierType$Type} from "packages/net/minecraft/world/level/levelgen/placement/$PlacementModifierType"
import {$LootNbtProviderType, $LootNbtProviderType$Type} from "packages/net/minecraft/world/level/storage/loot/providers/nbt/$LootNbtProviderType"
import {$SensorType, $SensorType$Type} from "packages/net/minecraft/world/entity/ai/sensing/$SensorType"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IntProviderType, $IntProviderType$Type} from "packages/net/minecraft/util/valueproviders/$IntProviderType"
import {$RecipeSerializer, $RecipeSerializer$Type} from "packages/net/minecraft/world/item/crafting/$RecipeSerializer"
import {$PositionSourceType, $PositionSourceType$Type} from "packages/net/minecraft/world/level/gameevent/$PositionSourceType"
import {$CatVariant, $CatVariant$Type} from "packages/net/minecraft/world/entity/animal/$CatVariant"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$LootItemConditionType, $LootItemConditionType$Type} from "packages/net/minecraft/world/level/storage/loot/predicates/$LootItemConditionType"
import {$GameEvent, $GameEvent$Type} from "packages/net/minecraft/world/level/gameevent/$GameEvent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LootPoolEntryType, $LootPoolEntryType$Type} from "packages/net/minecraft/world/level/storage/loot/entries/$LootPoolEntryType"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $RegistryInfo<T> implements $Iterable<($BuilderBase<(any)>)>, $TypeWrapperFactory<(T)> {
static readonly "MAP": $Map<($ResourceKey<(any)>), ($RegistryInfo<(any)>)>
static readonly "ALL_BUILDERS": $List<($BuilderBase<(any)>)>
static readonly "SOUND_EVENT": $RegistryInfo<($SoundEvent)>
static readonly "FLUID": $RegistryInfo<($Fluid)>
static readonly "MOB_EFFECT": $RegistryInfo<($MobEffect)>
static readonly "BLOCK": $RegistryInfo<($Block)>
static readonly "ENCHANTMENT": $RegistryInfo<($Enchantment)>
static readonly "ENTITY_TYPE": $RegistryInfo<($EntityType)>
static readonly "ITEM": $RegistryInfo<($Item)>
static readonly "POTION": $RegistryInfo<($Potion)>
static readonly "PARTICLE_TYPE": $RegistryInfo<($ParticleType)>
static readonly "BLOCK_ENTITY_TYPE": $RegistryInfo<($BlockEntityType)>
static readonly "PAINTING_VARIANT": $RegistryInfo<($PaintingVariant)>
static readonly "CUSTOM_STAT": $RegistryInfo<($ResourceLocation)>
static readonly "CHUNK_STATUS": $RegistryInfo<($ChunkStatus)>
static readonly "RULE_TEST": $RegistryInfo<($RuleTestType)>
static readonly "POS_RULE_TEST": $RegistryInfo<($PosRuleTestType)>
static readonly "MENU": $RegistryInfo<($MenuType)>
static readonly "RECIPE_TYPE": $RegistryInfo<($RecipeType)>
static readonly "RECIPE_SERIALIZER": $RegistryInfo<($RecipeSerializer)>
static readonly "ATTRIBUTE": $RegistryInfo<($Attribute)>
static readonly "GAME_EVENT": $RegistryInfo<($GameEvent)>
static readonly "POSITION_SOURCE_TYPE": $RegistryInfo<($PositionSourceType)>
static readonly "STAT_TYPE": $RegistryInfo<($StatType)>
static readonly "VILLAGER_TYPE": $RegistryInfo<($VillagerType)>
static readonly "VILLAGER_PROFESSION": $RegistryInfo<($VillagerProfession)>
static readonly "POINT_OF_INTEREST_TYPE": $RegistryInfo<($PoiType)>
static readonly "MEMORY_MODULE_TYPE": $RegistryInfo<($MemoryModuleType)>
static readonly "SENSOR_TYPE": $RegistryInfo<($SensorType)>
static readonly "SCHEDULE": $RegistryInfo<($Schedule)>
static readonly "ACTIVITY": $RegistryInfo<($Activity)>
static readonly "LOOT_ENTRY": $RegistryInfo<($LootPoolEntryType)>
static readonly "LOOT_FUNCTION": $RegistryInfo<($LootItemFunctionType)>
static readonly "LOOT_ITEM": $RegistryInfo<($LootItemConditionType)>
static readonly "LOOT_NUMBER_PROVIDER": $RegistryInfo<($LootNumberProviderType)>
static readonly "LOOT_NBT_PROVIDER": $RegistryInfo<($LootNbtProviderType)>
static readonly "LOOT_SCORE_PROVIDER": $RegistryInfo<($LootScoreProviderType)>
static readonly "COMMAND_ARGUMENT_TYPE": $RegistryInfo<($ArgumentTypeInfo)>
static readonly "DIMENSION_TYPE": $RegistryInfo<($DimensionType)>
static readonly "DIMENSION": $RegistryInfo<($Level)>
static readonly "LEVEL_STEM": $RegistryInfo<($LevelStem)>
static readonly "FLOAT_PROVIDER_TYPE": $RegistryInfo<($FloatProviderType)>
static readonly "INT_PROVIDER_TYPE": $RegistryInfo<($IntProviderType)>
static readonly "HEIGHT_PROVIDER_TYPE": $RegistryInfo<($HeightProviderType)>
static readonly "BLOCK_PREDICATE_TYPE": $RegistryInfo<($BlockPredicateType)>
static readonly "NOISE_GENERATOR_SETTINGS": $RegistryInfo<($NoiseGeneratorSettings)>
static readonly "CONFIGURED_CARVER": $RegistryInfo<($ConfiguredWorldCarver)>
static readonly "CONFIGURED_FEATURE": $RegistryInfo<($ConfiguredFeature)>
static readonly "PLACED_FEATURE": $RegistryInfo<($PlacedFeature)>
static readonly "STRUCTURE": $RegistryInfo<($Structure)>
static readonly "STRUCTURE_SET": $RegistryInfo<($StructureSet)>
static readonly "PROCESSOR_LIST": $RegistryInfo<($StructureProcessorList)>
static readonly "TEMPLATE_POOL": $RegistryInfo<($StructureTemplatePool)>
static readonly "BIOME": $RegistryInfo<($Biome)>
static readonly "NOISE": $RegistryInfo<($NormalNoise$NoiseParameters)>
static readonly "DENSITY_FUNCTION": $RegistryInfo<($DensityFunction)>
static readonly "WORLD_PRESET": $RegistryInfo<($WorldPreset)>
static readonly "FLAT_LEVEL_GENERATOR_PRESET": $RegistryInfo<($FlatLevelGeneratorPreset)>
static readonly "CARVER": $RegistryInfo<($WorldCarver)>
static readonly "FEATURE": $RegistryInfo<($Feature)>
static readonly "STRUCTURE_PLACEMENT_TYPE": $RegistryInfo<($StructurePlacementType)>
static readonly "STRUCTURE_PIECE": $RegistryInfo<($StructurePieceType)>
static readonly "STRUCTURE_TYPE": $RegistryInfo<($StructureType)>
static readonly "PLACEMENT_MODIFIER": $RegistryInfo<($PlacementModifierType)>
static readonly "BLOCK_STATE_PROVIDER_TYPE": $RegistryInfo<($BlockStateProviderType)>
static readonly "FOLIAGE_PLACER_TYPE": $RegistryInfo<($FoliagePlacerType)>
static readonly "TRUNK_PLACER_TYPE": $RegistryInfo<($TrunkPlacerType)>
static readonly "TREE_DECORATOR_TYPE": $RegistryInfo<($TreeDecoratorType)>
static readonly "ROOT_PLACER_TYPE": $RegistryInfo<($RootPlacerType)>
static readonly "FEATURE_SIZE_TYPE": $RegistryInfo<($FeatureSizeType)>
static readonly "BIOME_SOURCE": $RegistryInfo<($Codec)>
static readonly "CHUNK_GENERATOR": $RegistryInfo<($Codec)>
static readonly "CONDITION": $RegistryInfo<($Codec)>
static readonly "RULE": $RegistryInfo<($Codec)>
static readonly "DENSITY_FUNCTION_TYPE": $RegistryInfo<($Codec)>
static readonly "STRUCTURE_PROCESSOR": $RegistryInfo<($StructureProcessorType)>
static readonly "STRUCTURE_POOL_ELEMENT": $RegistryInfo<($StructurePoolElementType)>
static readonly "CHAT_TYPE": $RegistryInfo<($ChatType)>
static readonly "CAT_VARIANT": $RegistryInfo<($CatVariant)>
static readonly "FROG_VARIANT": $RegistryInfo<($FrogVariant)>
static readonly "BANNER_PATTERN": $RegistryInfo<($BannerPattern)>
static readonly "INSTRUMENT": $RegistryInfo<($Instrument)>
static readonly "TRIM_MATERIAL": $RegistryInfo<($TrimMaterial)>
static readonly "TRIM_PATTERN": $RegistryInfo<($TrimPattern)>
static readonly "CREATIVE_MODE_TAB": $RegistryInfo<($CreativeModeTab)>
static readonly "DAMAGE_TYPE": $RegistryInfo<($DamageType)>
static readonly "LOOT_CONDITION_TYPE": $RegistryInfo<($LootItemConditionType)>
static readonly "LOOT_FUNCTION_TYPE": $RegistryInfo<($LootItemFunctionType)>
static readonly "LOOT_NBT_PROVIDER_TYPE": $RegistryInfo<($LootNbtProviderType)>
static readonly "LOOT_NUMBER_PROVIDER_TYPE": $RegistryInfo<($LootNumberProviderType)>
static readonly "LOOT_POOL_ENTRY_TYPE": $RegistryInfo<($LootPoolEntryType)>
static readonly "LOOT_SCORE_PROVIDER_TYPE": $RegistryInfo<($LootScoreProviderType)>
static readonly "MATERIAL_CONDITION": $RegistryInfo<($Codec)>
static readonly "MATERIAL_RULE": $RegistryInfo<($Codec)>
static readonly "PLACEMENT_MODIFIER_TYPE": $RegistryInfo<($PlacementModifierType)>
static readonly "RULE_BLOCK_ENTITY_MODIFIER": $RegistryInfo<($RuleBlockEntityModifierType)>
static readonly "STRUCTURE_PLACEMENT": $RegistryInfo<($StructurePlacementType)>
static readonly "DECORATED_POT_PATTERNS": $RegistryInfo<(string)>
static readonly "NOISE_SETTINGS": $RegistryInfo<($NoiseGeneratorSettings)>
static readonly "MULTI_NOISE_BIOME_SOURCE_PARAMETER_LIST": $RegistryInfo<($MultiNoiseBiomeSourceParameterList)>
static readonly "AFTER_VANILLA": $LinkedList<($RegistryInfo<(any)>)>
readonly "key": $ResourceKey<(any)>
readonly "objectBaseClass": $Class<(any)>
readonly "types": $Map<(string), ($BuilderType<(T)>)>
readonly "objects": $Map<($ResourceLocation), ($BuilderBase<(any)>)>
 "hasDefaultTags": boolean
 "bypassServerOnly": boolean
 "autoWrap": boolean
 "languageKeyPrefix": string


public "equals"(obj: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "wrap"(cx: $Context$Type, o: any): T
public "getValue"(id: $ResourceLocation$Type): T
public "iterator"(): $Iterator<($BuilderBase<(any)>)>
public static "of"(key: $ResourceKey$Type<(any)>): $RegistryInfo<(any)>
public static "of"<T>(key: $ResourceKey$Type<(any)>, type: $Class$Type<(T)>): $RegistryInfo<(T)>
public "entrySet"(): $Set<($Map$Entry<($ResourceKey<(T)>), (T)>)>
public "getId"(value: T): $ResourceLocation
public "hasValue"(id: $ResourceLocation$Type): boolean
public "addType"(type: string, builderType: $Class$Type<(any)>, factory: $BuilderFactory$Type): void
public "addType"(type: string, builderType: $Class$Type<(any)>, factory: $BuilderFactory$Type, isDefault: boolean): void
public "fireRegistryEvent"(): void
public "registerObjects"(arg0: $RegistryCallback$Type<(T)>): integer
public "bypassServerOnly"(): $RegistryInfo<(T)>
public "addBuilder"(builder: $BuilderBase$Type<(any)>): void
public "noAutoWrap"(): $RegistryInfo<(T)>
public "languageKeyPrefix"(prefix: string): $RegistryInfo<(T)>
public "getDefaultType"(): $BuilderType<(any)>
public "getArchitecturyRegistrar"(): $Registrar<(T)>
public "getVanillaRegistry"(): $Registry<(T)>
public "spliterator"(): $Spliterator<($BuilderBase<(any)>)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<$BuilderBase<(any)>>;
get "defaultType"(): $BuilderType<(any)>
get "architecturyRegistrar"(): $Registrar<(T)>
get "vanillaRegistry"(): $Registry<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryInfo$Type<T> = ($RegistryInfo<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryInfo_<T> = $RegistryInfo$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/unit/$VariableSubset" {
import {$VariableSet, $VariableSet$Type} from "packages/dev/latvian/mods/unit/$VariableSet"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $VariableSubset extends $VariableSet {


public "get"(entry: string): $Unit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VariableSubset$Type = ($VariableSubset);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VariableSubset_ = $VariableSubset$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/registry/$RegistryCallback" {
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $RegistryCallback<T> {

 "accept"(arg0: $ResourceLocation$Type, arg1: $Supplier$Type<(T)>): void

(arg0: $ResourceLocation$Type, arg1: $Supplier$Type<(T)>): void
}

export namespace $RegistryCallback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegistryCallback$Type<T> = ($RegistryCallback<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegistryCallback_<T> = $RegistryCallback$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$EntitySteppedOnBlockCallbackJS" {
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$BlockPos, $BlockPos$Type} from "packages/net/minecraft/core/$BlockPos"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

export class $EntitySteppedOnBlockCallbackJS {

constructor(level: $Level$Type, entity: $Entity$Type, pos: $BlockPos$Type, state: $BlockState$Type)

/**
 * Returns the BlockState
 */
public "getState"(): $BlockState
/**
 * Returns the level
 */
public "getLevel"(): $Level
/**
 * Returns the block
 */
public "getBlock"(): $BlockContainerJS
/**
 * Returns if the entity is suppressing bouncing (for players this is true if the player is crouching)
 */
public "isSuppressingBounce"(): boolean
/**
 * Returns the entity
 */
public "getEntity"(): $Entity
/**
 * Returns the block's position
 */
public "getPos"(): $BlockPos
get "state"(): $BlockState
get "level"(): $Level
get "block"(): $BlockContainerJS
get "suppressingBounce"(): boolean
get "entity"(): $Entity
get "pos"(): $BlockPos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntitySteppedOnBlockCallbackJS$Type = ($EntitySteppedOnBlockCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntitySteppedOnBlockCallbackJS_ = $EntitySteppedOnBlockCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/$UtilsWrapper" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Stat, $Stat$Type} from "packages/net/minecraft/stats/$Stat"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Random, $Random$Type} from "packages/java/util/$Random"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Lazy, $Lazy$Type} from "packages/dev/latvian/mods/kubejs/util/$Lazy"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$CountingMap, $CountingMap$Type} from "packages/dev/latvian/mods/rhino/mod/util/$CountingMap"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$DustParticleOptions, $DustParticleOptions$Type} from "packages/net/minecraft/core/particles/$DustParticleOptions"
import {$ParticleOptions, $ParticleOptions$Type} from "packages/net/minecraft/core/particles/$ParticleOptions"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Entity, $Entity$Type} from "packages/net/minecraft/world/entity/$Entity"

/**
 * A collection of utilities
 */
export interface $UtilsWrapper {

}

export namespace $UtilsWrapper {
const ERROR_PARTICLE: $DustParticleOptions
function regex(s: any): $Pattern
function regex(pattern: string, flags: integer): $Pattern
function id(id: $ResourceLocation$Type): $ResourceLocation
function id(namespace: string, path: string): $ResourceLocation
function emptyList<T>(): $List<(T)>
function isWrapped(o: any): boolean
function newMap(): $Map<(any), (any)>
function copy(o: any): any
function toTitleCase(s: string, ignoreSpecial: boolean): string
function toTitleCase(s: string): string
function parseInt(object: any, def: integer): integer
function parseDouble(object: any, def: double): double
function emptyMap<K, V>(): $Map<(K), (V)>
function newList(): $List<(any)>
function lazy<T>(supplier: $Supplier$Type<(T)>): $Lazy<(T)>
function newCountingMap(): $CountingMap
function getStat(id: $ResourceLocation$Type): $Stat<($ResourceLocation)>
function randomOf(random: $Random$Type, objects: $Collection$Type<(any)>): any
function getSystemTime(): long
function newRandom(seed: long): $Random
function getRegistryIds(id: $ResourceLocation$Type): $List<($ResourceLocation)>
function expiringLazy<T>(supplier: $Supplier$Type<(T)>, time: long): $Lazy<(T)>
function getServer(): $MinecraftServer
function supplyAsync(task: $Supplier$Type<(any)>): $CompletableFuture<(any)>
function particleOptions(o: any): $ParticleOptions
function rollChestLoot(id: $ResourceLocation$Type, entity: $Entity$Type): $List<($ItemStack)>
function rollChestLoot(id: $ResourceLocation$Type): $List<($ItemStack)>
function queueIO(runnable: $Runnable$Type): void
function parseBlockState(o: any): $BlockState
function findCreativeTab(id: $ResourceLocation$Type): $CreativeModeTab
function runAsync(task: $Runnable$Type): $CompletableFuture<(void)>
function getRandom(): $Random
function snakeCaseToCamelCase(string: string): string
function snakeCaseToTitleCase(string: string): string
function getSound(id: $ResourceLocation$Type): $SoundEvent
function getRegistry(id: $ResourceLocation$Type): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UtilsWrapper$Type = ($UtilsWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UtilsWrapper_ = $UtilsWrapper$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/op/$SubOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $SubOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SubOpUnit$Type = ($SubOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SubOpUnit_ = $SubOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$BasicMobEffect" {
import {$AttributeMap, $AttributeMap$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeMap"
import {$BasicMobEffect$Builder, $BasicMobEffect$Builder$Type} from "packages/dev/latvian/mods/kubejs/misc/$BasicMobEffect$Builder"
import {$Attribute, $Attribute$Type} from "packages/net/minecraft/world/entity/ai/attributes/$Attribute"
import {$AttributeModifier, $AttributeModifier$Type} from "packages/net/minecraft/world/entity/ai/attributes/$AttributeModifier"
import {$LivingEntity, $LivingEntity$Type} from "packages/net/minecraft/world/entity/$LivingEntity"
import {$MobEffect, $MobEffect$Type} from "packages/net/minecraft/world/effect/$MobEffect"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BasicMobEffect extends $MobEffect {

constructor(builder: $BasicMobEffect$Builder$Type)

public "addAttributeModifiers"(livingEntity: $LivingEntity$Type, attributeMap: $AttributeMap$Type, i: integer): void
public "removeAttributeModifiers"(livingEntity: $LivingEntity$Type, attributeMap: $AttributeMap$Type, i: integer): void
public "isDurationEffectTick"(i: integer, j: integer): boolean
public "applyEffectTick"(livingEntity: $LivingEntity$Type, i: integer): void
public "getAttributeModifiers"(): $Map<($Attribute), ($AttributeModifier)>
get "attributeModifiers"(): $Map<($Attribute), ($AttributeModifier)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BasicMobEffect$Type = ($BasicMobEffect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BasicMobEffect_ = $BasicMobEffect$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/$FireworksJS" {
import {$FireworksJS$Explosion, $FireworksJS$Explosion$Type} from "packages/dev/latvian/mods/kubejs/level/$FireworksJS$Explosion"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$FireworkRocketEntity, $FireworkRocketEntity$Type} from "packages/net/minecraft/world/entity/projectile/$FireworkRocketEntity"

export class $FireworksJS {
 "flight": integer
 "lifetime": integer
readonly "explosions": $List<($FireworksJS$Explosion)>

constructor()

public static "of"(o: any): $FireworksJS
public "createFireworkRocket"(w: $Level$Type, x: double, y: double, z: double): $FireworkRocketEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FireworksJS$Type = ($FireworksJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FireworksJS_ = $FireworksJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/script/data/$VirtualKubeJSDataPack" {
import {$PackResources$ResourceOutput, $PackResources$ResourceOutput$Type} from "packages/net/minecraft/server/packs/$PackResources$ResourceOutput"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$PackType, $PackType$Type} from "packages/net/minecraft/server/packs/$PackType"
import {$AbstractPackResources, $AbstractPackResources$Type} from "packages/net/minecraft/server/packs/$AbstractPackResources"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$MetadataSectionSerializer, $MetadataSectionSerializer$Type} from "packages/net/minecraft/server/packs/metadata/$MetadataSectionSerializer"
import {$IoSupplier, $IoSupplier$Type} from "packages/net/minecraft/server/packs/resources/$IoSupplier"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$ExportablePackResources, $ExportablePackResources$Type} from "packages/dev/latvian/mods/kubejs/script/data/$ExportablePackResources"

/**
 * This class is not allowed By KubeJS!
 * You should not load the class, or KubeJS will throw an error.
 * Loading the class using require() will not throw an error, but the class will be undefined.
 */
export class $VirtualKubeJSDataPack extends $AbstractPackResources implements $ExportablePackResources {
readonly "high": boolean

constructor(h: boolean)

public "toString"(): string
public "close"(): void
public "export"(root: $Path$Type): void
public "getResource"(type: $PackType$Type, location: $ResourceLocation$Type): $IoSupplier<($InputStream)>
public "hasNamespace"(key: string): boolean
public "listResources"(packType: $PackType$Type, namespace: string, path: string, visitor: $PackResources$ResourceOutput$Type): void
public "getRootResource"(...path: (string)[]): $IoSupplier<($InputStream)>
public "addData"(id: $ResourceLocation$Type, data: string): void
public "packId"(): string
public "getMetadataSection"<T>(serializer: $MetadataSectionSerializer$Type<(T)>): T
public "getNamespaces"(type: $PackType$Type): $Set<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualKubeJSDataPack$Type = ($VirtualKubeJSDataPack);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualKubeJSDataPack_ = $VirtualKubeJSDataPack$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$DegFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $DegFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DegFuncUnit$Type = ($DegFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DegFuncUnit_ = $DegFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentWithParent" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $RecipeComponentWithParent<T> extends $RecipeComponent<(T)> {

 "componentType"(): string
 "write"(recipe: $RecipeJS$Type, value: T): $JsonElement
 "read"(recipe: $RecipeJS$Type, from: any): T
 "componentClass"(): $Class<(any)>
 "isInput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
 "isOutput"(recipe: $RecipeJS$Type, value: T, match: $ReplacementMatch$Type): boolean
 "checkEmpty"(key: $RecipeKey$Type<(T)>, value: T): string
 "replaceOutput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): T
 "replaceInput"(recipe: $RecipeJS$Type, original: T, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): T
 "parentComponent"(): $RecipeComponent<(T)>
 "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
 "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
 "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>
 "key"(name: string): $RecipeKey<(T)>
 "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<(T), (O)>
 "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<(T), (O)>
 "asArray"(): $ArrayRecipeComponent<(T)>
 "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), (T)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
 "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<(T)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
 "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<(T)>
 "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, json: $JsonObject$Type): void
 "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<(T)>, map: $Map$Type<(any), (any)>): void
 "orSelf"(): $RecipeComponent<(T)>
 "asArrayOrSelf"(): $ArrayRecipeComponent<(T)>
 "asPatternKey"(): $RecipeComponent<($TinyMap<(character), (T)>)>
 "checkValueHasChanged"(oldValue: T, newValue: T): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
 "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<(T)>

(): string
}

export namespace $RecipeComponentWithParent {
function builder(): $RecipeComponentBuilder
function builder(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeComponentWithParent$Type<T> = ($RecipeComponentWithParent<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeComponentWithParent_<T> = $RecipeComponentWithParent$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/rei/$REIEntryWrappers" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Event, $Event$Type} from "packages/dev/architectury/event/$Event"

export class $REIEntryWrappers {
static readonly "EVENT": $Event<($Consumer<($REIEntryWrappers)>)>

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $REIEntryWrappers$Type = ($REIEntryWrappers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $REIEntryWrappers_ = $REIEntryWrappers$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/misc/$VillagerProfessionBuilder" {
import {$SoundEvent, $SoundEvent$Type} from "packages/net/minecraft/sounds/$SoundEvent"
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$VillagerProfession, $VillagerProfession$Type} from "packages/net/minecraft/world/entity/npc/$VillagerProfession"

export class $VillagerProfessionBuilder extends $BuilderBase<($VillagerProfession)> {
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $VillagerProfession
public "secondaryPoi"(t: ($Block$Type)[]): $VillagerProfessionBuilder
public "poiTypeTag"(t: $ResourceLocation$Type): $VillagerProfessionBuilder
public "workSound"(t: $SoundEvent$Type): $VillagerProfessionBuilder
public "requestedItems"(t: ($Item$Type)[]): $VillagerProfessionBuilder
public "poiType"(t: $ResourceLocation$Type): $VillagerProfessionBuilder
public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VillagerProfessionBuilder$Type = ($VillagerProfessionBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VillagerProfessionBuilder_ = $VillagerProfessionBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemDroppedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$ItemEntity, $ItemEntity$Type} from "packages/net/minecraft/world/entity/item/$ItemEntity"

/**
 * Invoked when a player drops an item.
 */
export class $ItemDroppedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, entity: $ItemEntity$Type)

/**
 * The item that was dropped.
 */
public "getItem"(): $ItemStack
/**
 * The item entity that was spawned when dropping.
 */
public "getItemEntity"(): $ItemEntity
get "item"(): $ItemStack
get "itemEntity"(): $ItemEntity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDroppedEventJS$Type = ($ItemDroppedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDroppedEventJS_ = $ItemDroppedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeIterator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeIterator extends $IdScriptableObject {
static readonly "ITERATOR_PROPERTY_NAME": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "getClassName"(): string
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public static "getStopIterationObject"(scope: $Scriptable$Type, cx: $Context$Type): any
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeIterator$Type = ($NativeIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeIterator_ = $NativeIterator$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ConsString" {
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"

export class $ConsString implements charseq {

constructor(str1: charseq, str2: charseq)

public "length"(): integer
public "toString"(): string
public "charAt"(index: integer): character
public "subSequence"(start: integer, end: integer): charseq
public static "compare"(arg0: charseq, arg1: charseq): integer
public "isEmpty"(): boolean
public "codePoints"(): $IntStream
public "chars"(): $IntStream
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConsString$Type = ($ConsString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConsString_ = $ConsString$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$CustomFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BaseFunction, $BaseFunction$Type} from "packages/dev/latvian/mods/rhino/$BaseFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$CustomFunction$Func, $CustomFunction$Func$Type} from "packages/dev/latvian/mods/rhino/$CustomFunction$Func"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $CustomFunction extends $BaseFunction {
static readonly "NO_ARGS": ($Class<(any)>)[]
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(functionName: string, func: $CustomFunction$Func$Type, argTypes: ($Class$Type<(any)>)[])

public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getFunctionName"(): string
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "functionName"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomFunction$Type = ($CustomFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomFunction_ = $CustomFunction$Type;
}}
declare module "packages/dev/latvian/mods/unit/$FixedColorUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$StringBuilder, $StringBuilder$Type} from "packages/java/lang/$StringBuilder"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $FixedColorUnit extends $Unit implements $UnitToken {
static readonly "WHITE": $FixedColorUnit
static readonly "BLACK": $FixedColorUnit
static readonly "TRANSPARENT": $FixedColorUnit
readonly "color": integer
readonly "alpha": boolean
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public "toString"(builder: $StringBuilder$Type): void
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public static "of"(color: integer, alpha: boolean): $FixedColorUnit
public "withAlpha"(a: $Unit$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
public "interpret"(stream: $UnitTokenStream$Type): $Unit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FixedColorUnit$Type = ($FixedColorUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FixedColorUnit_ = $FixedColorUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/player/$InventoryChangedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

/**
 * Invoked when a player's inventory changes.
 */
export class $InventoryChangedEventJS extends $PlayerEventJS {

constructor(p: $Player$Type, is: $ItemStack$Type, s: integer)

/**
 * Gets the slot that was changed.
 */
public "getSlot"(): integer
/**
 * Gets the item that was changed.
 */
public "getItem"(): $ItemStack
get "slot"(): integer
get "item"(): $ItemStack
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryChangedEventJS$Type = ($InventoryChangedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryChangedEventJS_ = $InventoryChangedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement" {
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export class $InputReplacementTransformer$Replacement extends $Record implements $InputReplacement {

constructor(arg0: $InputReplacement$Type, transformer: $InputReplacementTransformer$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "transformer"(): $InputReplacementTransformer
public "with"(): $InputReplacement
public static "of"(o: any): $InputReplacement
public "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
public "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputReplacementTransformer$Replacement$Type = ($InputReplacementTransformer$Replacement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputReplacementTransformer$Replacement_ = $InputReplacementTransformer$Replacement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$CreativeModeTabKJS" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export interface $CreativeModeTabKJS {

 "kjs$setIcon"(arg0: $ItemStack$Type): void
 "kjs$setDisplayName"(arg0: $Component$Type): void
}

export namespace $CreativeModeTabKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeModeTabKJS$Type = ($CreativeModeTabKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeModeTabKJS_ = $CreativeModeTabKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/forge/$RhinoModForge" {
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"

export class $RhinoModForge {

constructor()

public static "loaded"(event: $FMLCommonSetupEvent$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RhinoModForge$Type = ($RhinoModForge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RhinoModForge_ = $RhinoModForge$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/forge/$ForgeKubeJSEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"

export interface $ForgeKubeJSEvents {

}

export namespace $ForgeKubeJSEvents {
const ITEM_DESTROYED: $EventHandler
const ENTITY_DROPS: $EventHandler
function register(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeKubeJSEvents$Type = ($ForgeKubeJSEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeKubeJSEvents_ = $ForgeKubeJSEvents$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/cond/$CondOpUnit" {
import {$OpUnit, $OpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$OpUnit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $CondOpUnit extends $OpUnit {
readonly "symbol": $UnitSymbol
 "left": $Unit
 "right": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(symbol: $UnitSymbol$Type, left: $Unit$Type, right: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(arg0: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public "getFloat"(variables: $UnitVariables$Type): float
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CondOpUnit$Type = ($CondOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CondOpUnit_ = $CondOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/unit/$FixedBooleanUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $FixedBooleanUnit extends $Unit {
static readonly "TRUE": $FixedBooleanUnit
static readonly "FALSE": $FixedBooleanUnit
readonly "value": boolean
static "EMPTY_ARRAY": ($Unit)[]


public "get"(variables: $UnitVariables$Type): double
public "toString"(): string
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
public "bool"(): $Unit
public "boolNot"(): $Unit
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FixedBooleanUnit$Type = ($FixedBooleanUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FixedBooleanUnit_ = $FixedBooleanUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$BlockKJS" {
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$CompoundTag, $CompoundTag$Type} from "packages/net/minecraft/nbt/$CompoundTag"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SoundType, $SoundType$Type} from "packages/net/minecraft/world/level/block/$SoundType"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$BlockBuilderProvider, $BlockBuilderProvider$Type} from "packages/dev/latvian/mods/kubejs/core/$BlockBuilderProvider"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export interface $BlockKJS extends $BlockBuilderProvider {

 "setNameKey"(key: string): void
 "setBlockBuilder"(b: $BlockBuilder$Type): void
 "setIsRandomlyTicking"(v: boolean): void
 "setHasCollision"(v: boolean): void
 "setExplosionResistance"(v: float): void
 "setRandomTickCallback"(callback: $Consumer$Type<($RandomTickCallbackJS$Type)>): void
 "setRequiresTool"(v: boolean): void
 "setDestroySpeed"(v: float): void
 "setLightEmission"(v: integer): void
 "getIdLocation"(): $ResourceLocation
 "getId"(): string
 "setSpeedFactor"(v: float): void
 "setJumpFactor"(v: float): void
 "setSoundType"(v: $SoundType$Type): void
 "setFriction"(v: float): void
 "getTypeData"(): $CompoundTag
 "getBlockStates"(): $List<($BlockState)>
 "getMod"(): string
 "getBlockBuilder"(): $BlockBuilder
}

export namespace $BlockKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockKJS$Type = ($BlockKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockKJS_ = $BlockKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdFunctionCall" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export interface $IdFunctionCall {

 "execIdCall"(arg0: $IdFunctionObject$Type, arg1: $Context$Type, arg2: $Scriptable$Type, arg3: $Scriptable$Type, arg4: (any)[]): any

(arg0: $IdFunctionObject$Type, arg1: $Context$Type, arg2: $Scriptable$Type, arg3: $Scriptable$Type, arg4: (any)[]): any
}

export namespace $IdFunctionCall {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdFunctionCall$Type = ($IdFunctionCall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdFunctionCall_ = $IdFunctionCall$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement" {
import {$InputReplacementTransformer$Replacement, $InputReplacementTransformer$Replacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer$Replacement"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$InputReplacementTransformer, $InputReplacementTransformer$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacementTransformer"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $InputReplacement {

 "transform"(transformer: $InputReplacementTransformer$Type): $InputReplacementTransformer$Replacement
 "replaceInput"(recipe: $RecipeJS$Type, match: $ReplacementMatch$Type, original: $InputReplacement$Type): any
}

export namespace $InputReplacement {
function of(o: any): $InputReplacement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InputReplacement$Type = ($InputItem$Type) | ($InputReplacement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InputReplacement_ = $InputReplacement$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/$RecipeFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$NativeJavaObject, $NativeJavaObject$Type} from "packages/dev/latvian/mods/rhino/$NativeJavaObject"
import {$RecipeComponentValueFunction, $RecipeComponentValueFunction$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValueFunction"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $RecipeFunction extends $NativeJavaObject {
readonly "recipe": $RecipeJS
readonly "builderFunctions": $Map<(string), ($RecipeComponentValueFunction)>

constructor(cx: $Context$Type, scope: $Scriptable$Type, staticType: $Class$Type<(any)>, recipe: $RecipeJS$Type)

public "get"(cx: $Context$Type, name: string, start: $Scriptable$Type): any
public static "unwrapped"(o: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecipeFunction$Type = ($RecipeFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecipeFunction_ = $RecipeFunction$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$HorizontalDirectionalBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"

export class $HorizontalDirectionalBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Block
public "textureAll"(tex: string): $HorizontalDirectionalBlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HorizontalDirectionalBlockBuilder$Type = ($HorizontalDirectionalBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HorizontalDirectionalBlockBuilder_ = $HorizontalDirectionalBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$BeanProperty" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BeanProperty {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BeanProperty$Type = ($BeanProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BeanProperty_ = $BeanProperty$Type;
}}
declare module "packages/dev/latvian/mods/unit/token/$UnaryOpUnitToken" {
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnitToken, $UnitToken$Type} from "packages/dev/latvian/mods/unit/token/$UnitToken"
import {$UnitTokenStream, $UnitTokenStream$Type} from "packages/dev/latvian/mods/unit/token/$UnitTokenStream"
import {$Stack, $Stack$Type} from "packages/java/util/$Stack"

export class $UnaryOpUnitToken extends $Record implements $UnitToken {

constructor(operator: $UnitSymbol$Type, token: $UnitToken$Type)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "operator"(): $UnitSymbol
public "token"(): $UnitToken
public "interpret"(stream: $UnitTokenStream$Type): $Unit
public "nextUnaryOperator"(): boolean
public "unstack"(resultStack: $Stack$Type<($UnitToken$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnaryOpUnitToken$Type = ($UnaryOpUnitToken);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnaryOpUnitToken_ = $UnaryOpUnitToken$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$VMBridge" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$InterfaceAdapter, $InterfaceAdapter$Type} from "packages/dev/latvian/mods/rhino/$InterfaceAdapter"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"
import {$AccessibleObject, $AccessibleObject$Type} from "packages/java/lang/reflect/$AccessibleObject"

export class $VMBridge {

constructor()

public static "getInterfaceProxyHelper"(cx: $Context$Type, interfaces: ($Class$Type<(any)>)[]): any
public static "tryToMakeAccessible"(target: any, accessible: $AccessibleObject$Type): boolean
public static "newInterfaceProxy"(proxyHelper: any, adapter: $InterfaceAdapter$Type, target: any, topScope: $Scriptable$Type, cx: $Context$Type): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VMBridge$Type = ($VMBridge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VMBridge_ = $VMBridge$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/custom/$ShapedBlockBuilder" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$BlockBuilder, $BlockBuilder$Type} from "packages/dev/latvian/mods/kubejs/block/$BlockBuilder"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LootBuilder, $LootBuilder$Type} from "packages/dev/latvian/mods/kubejs/loot/$LootBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$RandomTickCallbackJS, $RandomTickCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/$RandomTickCallbackJS"

export class $ShapedBlockBuilder extends $BlockBuilder {
 "randomTickCallback": $Consumer<($RandomTickCallbackJS)>
 "lootTable": $Consumer<($LootBuilder)>
 "blockstateJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type, ...suffixes: (string)[])

public "textureAll"(tex: string): $BlockBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShapedBlockBuilder$Type = ($ShapedBlockBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShapedBlockBuilder_ = $ShapedBlockBuilder$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$Func3Unit" {
import {$FuncUnit, $FuncUnit$Type} from "packages/dev/latvian/mods/unit/function/$FuncUnit"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"

export class $Func3Unit extends $FuncUnit {
readonly "a": $Unit
readonly "b": $Unit
readonly "c": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(factory: $FunctionFactory$Type, a: $Unit$Type, b: $Unit$Type, c: $Unit$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Func3Unit$Type = ($Func3Unit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Func3Unit_ = $Func3Unit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/forge/$ItemDestroyedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$PlayerDestroyItemEvent, $PlayerDestroyItemEvent$Type} from "packages/net/minecraftforge/event/entity/player/$PlayerDestroyItemEvent"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ItemDestroyedEventJS extends $PlayerEventJS {

constructor(e: $PlayerDestroyItemEvent$Type)

public "getItem"(): $ItemStack
public "getHand"(): $InteractionHand
get "item"(): $ItemStack
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemDestroyedEventJS$Type = ($ItemDestroyedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemDestroyedEventJS_ = $ItemDestroyedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$NotificationToast" {
import {$Toast, $Toast$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$NotificationBuilder, $NotificationBuilder$Type} from "packages/dev/latvian/mods/kubejs/util/$NotificationBuilder"
import {$NotificationToast$ToastIcon, $NotificationToast$ToastIcon$Type} from "packages/dev/latvian/mods/kubejs/client/$NotificationToast$ToastIcon"
import {$ToastComponent, $ToastComponent$Type} from "packages/net/minecraft/client/gui/components/toasts/$ToastComponent"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$GuiGraphics, $GuiGraphics$Type} from "packages/net/minecraft/client/gui/$GuiGraphics"
import {$Toast$Visibility, $Toast$Visibility$Type} from "packages/net/minecraft/client/gui/components/toasts/$Toast$Visibility"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NotificationToast implements $Toast {
static readonly "ICONS": $Map<(integer), ($BiFunction<($Minecraft), (string), ($NotificationToast$ToastIcon)>)>

constructor(mc: $Minecraft$Type, notification: $NotificationBuilder$Type)

public "render"(graphics: $GuiGraphics$Type, toastComponent: $ToastComponent$Type, l: long): $Toast$Visibility
public "width"(): integer
public "height"(): integer
public "getToken"(): any
public "slotCount"(): integer
get "token"(): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotificationToast$Type = ($NotificationToast);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotificationToast_ = $NotificationToast$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$TanFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $TanFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TanFuncUnit$Type = ($TanFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TanFuncUnit_ = $TanFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/$BuiltinKubeJSClientPlugin" {
import {$KubeJSPlugin, $KubeJSPlugin$Type} from "packages/dev/latvian/mods/kubejs/$KubeJSPlugin"
import {$BindingsEvent, $BindingsEvent$Type} from "packages/dev/latvian/mods/kubejs/script/$BindingsEvent"

export class $BuiltinKubeJSClientPlugin extends $KubeJSPlugin {

constructor()

public "clientInit"(): void
public "registerBindings"(event: $BindingsEvent$Type): void
public "registerEvents"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuiltinKubeJSClientPlugin$Type = ($BuiltinKubeJSClientPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuiltinKubeJSClientPlugin_ = $BuiltinKubeJSClientPlugin$Type;
}}
declare module "packages/dev/latvian/mods/rhino/classfile/$ExceptionTableEntry" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ExceptionTableEntry {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExceptionTableEntry$Type = ($ExceptionTableEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExceptionTableEntry_ = $ExceptionTableEntry$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemClickedEventJS" {
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Player, $Player$Type} from "packages/net/minecraft/world/entity/player/$Player"
import {$RayTraceResultJS, $RayTraceResultJS$Type} from "packages/dev/latvian/mods/kubejs/entity/$RayTraceResultJS"
import {$InteractionHand, $InteractionHand$Type} from "packages/net/minecraft/world/$InteractionHand"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

/**
 * Invoked when a player right clicks with an item **without targeting anything**.
 * 
 * Not to be confused with `BlockEvents.rightClick` or `ItemEvents.entityInteracted`.
 */
export class $ItemClickedEventJS extends $PlayerEventJS {

constructor(player: $Player$Type, hand: $InteractionHand$Type, item: $ItemStack$Type)

/**
 * The ray trace result of the click.
 */
public "getTarget"(): $RayTraceResultJS
/**
 * The item that was clicked with.
 */
public "getItem"(): $ItemStack
/**
 * The hand that the item was clicked with.
 */
public "getHand"(): $InteractionHand
get "target"(): $RayTraceResultJS
get "item"(): $ItemStack
get "hand"(): $InteractionHand
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemClickedEventJS$Type = ($ItemClickedEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemClickedEventJS_ = $ItemClickedEventJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/ast/$ArrayComprehensionLoop" {
import {$AstNode, $AstNode$Type} from "packages/dev/latvian/mods/rhino/ast/$AstNode"
import {$Node, $Node$Type} from "packages/dev/latvian/mods/rhino/$Node"
import {$ForInLoop, $ForInLoop$Type} from "packages/dev/latvian/mods/rhino/ast/$ForInLoop"

export class $ArrayComprehensionLoop extends $ForInLoop {
 "target": $Node
static readonly "FUNCTION_PROP": integer
static readonly "LOCAL_PROP": integer
static readonly "LOCAL_BLOCK_PROP": integer
static readonly "REGEXP_PROP": integer
static readonly "CASEARRAY_PROP": integer
static readonly "TARGETBLOCK_PROP": integer
static readonly "VARIABLE_PROP": integer
static readonly "ISNUMBER_PROP": integer
static readonly "DIRECTCALL_PROP": integer
static readonly "SPECIALCALL_PROP": integer
static readonly "SKIP_INDEXES_PROP": integer
static readonly "OBJECT_IDS_PROP": integer
static readonly "INCRDECR_PROP": integer
static readonly "CATCH_SCOPE_PROP": integer
static readonly "LABEL_ID_PROP": integer
static readonly "MEMBER_TYPE_PROP": integer
static readonly "NAME_PROP": integer
static readonly "CONTROL_BLOCK_PROP": integer
static readonly "PARENTHESIZED_PROP": integer
static readonly "GENERATOR_END_PROP": integer
static readonly "DESTRUCTURING_ARRAY_LENGTH": integer
static readonly "DESTRUCTURING_NAMES": integer
static readonly "DESTRUCTURING_PARAMS": integer
static readonly "JSDOC_PROP": integer
static readonly "EXPRESSION_CLOSURE_PROP": integer
static readonly "DESTRUCTURING_SHORTHAND": integer
static readonly "ARROW_FUNCTION_PROP": integer
static readonly "TEMPLATE_LITERAL_PROP": integer
static readonly "LAST_PROP": integer
static readonly "BOTH": integer
static readonly "LEFT": integer
static readonly "RIGHT": integer
static readonly "NON_SPECIALCALL": integer
static readonly "SPECIALCALL_EVAL": integer
static readonly "SPECIALCALL_WITH": integer
static readonly "DECR_FLAG": integer
static readonly "POST_FLAG": integer
static readonly "PROPERTY_FLAG": integer
static readonly "ATTRIBUTE_FLAG": integer
static readonly "DESCENDANTS_FLAG": integer
static readonly "END_UNREACHED": integer
static readonly "END_DROPS_OFF": integer
static readonly "END_RETURNS": integer
static readonly "END_RETURNS_VALUE": integer
static readonly "END_YIELDS": integer

constructor(pos: integer, len: integer)
constructor(pos: integer)
constructor()

public "getBody"(): $AstNode
public "setBody"(body: $AstNode$Type): void
get "body"(): $AstNode
set "body"(value: $AstNode$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayComprehensionLoop$Type = ($ArrayComprehensionLoop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayComprehensionLoop_ = $ArrayComprehensionLoop$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/recipe/component/$MapRecipeComponent" {
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$RecipeKey, $RecipeKey$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeKey"
import {$RecipeComponentBuilder, $RecipeComponentBuilder$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentBuilder"
import {$ArrayRecipeComponent, $ArrayRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ArrayRecipeComponent"
import {$AndRecipeComponent, $AndRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$AndRecipeComponent"
import {$TinyMap, $TinyMap$Type} from "packages/dev/latvian/mods/kubejs/util/$TinyMap"
import {$InputItem, $InputItem$Type} from "packages/dev/latvian/mods/kubejs/item/$InputItem"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$RecipeJS, $RecipeJS$Type} from "packages/dev/latvian/mods/kubejs/recipe/$RecipeJS"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"
import {$MappingRecipeComponent, $MappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$MappingRecipeComponent"
import {$OutputReplacement, $OutputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$OutputReplacement"
import {$SimpleMappingRecipeComponent, $SimpleMappingRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$SimpleMappingRecipeComponent"
import {$InputReplacement, $InputReplacement$Type} from "packages/dev/latvian/mods/kubejs/recipe/$InputReplacement"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"
import {$ComponentRole, $ComponentRole$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$ComponentRole"
import {$RecipeComponentValue, $RecipeComponentValue$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponentValue"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$OrRecipeComponent, $OrRecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$OrRecipeComponent"
import {$RecipeComponent, $RecipeComponent$Type} from "packages/dev/latvian/mods/kubejs/recipe/component/$RecipeComponent"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapRecipeComponent<K, V> extends $Record implements $RecipeComponent<($TinyMap<(K), (V)>)> {
static readonly "ITEM_PATTERN_KEY": $RecipeComponent<($TinyMap<(character), ($InputItem)>)>

constructor(key: $RecipeComponent$Type<(K)>, component: $RecipeComponent$Type<(V)>, patternKey: boolean)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "componentType"(): string
public "component"(): $RecipeComponent<(V)>
public "write"(recipe: $RecipeJS$Type, value: $TinyMap$Type<(K), (V)>): $JsonObject
public "key"(): $RecipeComponent<(K)>
public "componentClass"(): $Class<(any)>
public "isInput"(recipe: $RecipeJS$Type, value: $TinyMap$Type<(K), (V)>, match: $ReplacementMatch$Type): boolean
public "isOutput"(recipe: $RecipeJS$Type, value: $TinyMap$Type<(K), (V)>, match: $ReplacementMatch$Type): boolean
public "checkEmpty"(key: $RecipeKey$Type<($TinyMap$Type<(K), (V)>)>, value: $TinyMap$Type<(K), (V)>): string
public "replaceOutput"(recipe: $RecipeJS$Type, original: $TinyMap$Type<(K), (V)>, match: $ReplacementMatch$Type, arg3: $OutputReplacement$Type): $TinyMap<(K), (V)>
public "replaceInput"(recipe: $RecipeJS$Type, original: $TinyMap$Type<(K), (V)>, match: $ReplacementMatch$Type, arg3: $InputReplacement$Type): $TinyMap<(K), (V)>
public "constructorDescription"(ctx: $DescriptionContext$Type): $TypeDescJS
public "patternKey"(): boolean
public "role"(): $ComponentRole
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read, and the mappingFrom function after the component writes to json, before that json is saved
 */
public "map"(mappingTo: $UnaryOperator$Type<(any)>, mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($TinyMap<(K), (V)>)>
public static "builder"(): $RecipeComponentBuilder
public static "builder"(...key: ($RecipeKey$Type<(any)>)[]): $RecipeComponentBuilder
public "key"(name: string): $RecipeKey<($TinyMap<(K), (V)>)>
public "or"<O>(other: $RecipeComponent$Type<(O)>): $OrRecipeComponent<($TinyMap<(K), (V)>), (O)>
public "and"<O>(other: $RecipeComponent$Type<(O)>): $AndRecipeComponent<($TinyMap<(K), (V)>), (O)>
public "asArray"(): $ArrayRecipeComponent<($TinyMap<(K), (V)>)>
public "asMap"<K>(key: $RecipeComponent$Type<(K)>): $RecipeComponent<($TinyMap<(K), ($TinyMap<(K), (V)>)>)>
/**
 * Returns a new RecipeComponent that applies the mappingTo function to the input before it is passed to this component to be read
 */
public "mapIn"(mappingTo: $UnaryOperator$Type<(any)>): $MappingRecipeComponent<($TinyMap<(K), (V)>)>
/**
 * Returns a new RecipeComponent that maps the keys in a JsonObject according to the provided map, both before the json gets passed to the component and after the component returns a written json object.
 * The mappings should be provided in the format `{recipe: "component"}` where recipe is the key as in the recipe, and component is the key as how the RecipeComponent expects it.
 * Any keys not included in the provided map will be ignored, and any keys in the provided map that are not in either the input object or output object will be ignored.
 * Note that if the input or output is not a JsonObject (ie its an ItemStack, or it is a JsonPrimitive) then that will pass through this without being modified.
 * If you wish to handle those situations use the actual map function
 */
public "simpleMap"(mappings: any): $SimpleMappingRecipeComponent<($TinyMap<(K), (V)>)>
public "readFromJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TinyMap$Type<(K), (V)>)>, json: $JsonObject$Type): void
public "writeToJson"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TinyMap$Type<(K), (V)>)>, json: $JsonObject$Type): void
public "readFromMap"(recipe: $RecipeJS$Type, cv: $RecipeComponentValue$Type<($TinyMap$Type<(K), (V)>)>, map: $Map$Type<(any), (any)>): void
public "hasPriority"(recipe: $RecipeJS$Type, from: any): boolean
public "orSelf"(): $RecipeComponent<($TinyMap<(K), (V)>)>
public "asArrayOrSelf"(): $ArrayRecipeComponent<($TinyMap<(K), (V)>)>
public "asPatternKey"(): $RecipeComponent<($TinyMap<(character), ($TinyMap<(K), (V)>)>)>
public "checkValueHasChanged"(oldValue: $TinyMap$Type<(K), (V)>, newValue: $TinyMap$Type<(K), (V)>): boolean
/**
 * Returns a new RecipeComponent that applies the mappingFrom function after the component writes to json, before that json is saved
 */
public "mapOut"(mappingFrom: $UnaryOperator$Type<($JsonElement$Type)>): $MappingRecipeComponent<($TinyMap<(K), (V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapRecipeComponent$Type<K, V> = ($MapRecipeComponent<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapRecipeComponent_<K, V> = $MapRecipeComponent$Type<(K), (V)>;
}}
declare module "packages/dev/latvian/mods/rhino/$SpecialRef" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Ref, $Ref$Type} from "packages/dev/latvian/mods/rhino/$Ref"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $SpecialRef extends $Ref {


public "get"(cx: $Context$Type): any
public "set"(cx: $Context$Type, scope: $Scriptable$Type, value: any): any
/**
 * 
 * @deprecated
 */
public "set"(cx: $Context$Type, value: any): any
public "delete"(cx: $Context$Type): boolean
public "has"(cx: $Context$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SpecialRef$Type = ($SpecialRef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SpecialRef_ = $SpecialRef$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$AndFilter" {
import {$MobFilter, $MobFilter$Type} from "packages/dev/latvian/mods/kubejs/level/gen/filter/mob/$MobFilter"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$MobSpawnSettings$SpawnerData, $MobSpawnSettings$SpawnerData$Type} from "packages/net/minecraft/world/level/biome/$MobSpawnSettings$SpawnerData"
import {$Record, $Record$Type} from "packages/java/lang/$Record"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MobCategory, $MobCategory$Type} from "packages/net/minecraft/world/entity/$MobCategory"

export class $AndFilter extends $Record implements $MobFilter {

constructor(list: $List$Type<($MobFilter$Type)>)

public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "test"(cat: $MobCategory$Type, data: $MobSpawnSettings$SpawnerData$Type): boolean
public "list"(): $List<($MobFilter)>
public static "of"(cx: $Context$Type, o: any): $MobFilter
public static "idFilter"(cx: $Context$Type, s: string): $MobFilter
public "or"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "negate"(): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
public "and"(arg0: $BiPredicate$Type<(any), (any)>): $BiPredicate<($MobCategory), ($MobSpawnSettings$SpawnerData)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AndFilter$Type = ($AndFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AndFilter_ = $AndFilter$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$IdFunctionObjectES6" {
import {$IdFunctionCall, $IdFunctionCall$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionCall"
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $IdFunctionObjectES6 extends $IdFunctionObject {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(idcall: $IdFunctionCall$Type, tag: any, id: integer, name: string, arity: integer, scope: $Scriptable$Type)

public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "setPrototype"(arg0: $Scriptable$Type): void
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdFunctionObjectES6$Type = ($IdFunctionObjectES6);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdFunctionObjectES6_ = $IdFunctionObjectES6$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$WrappedJSObjectChangeListener" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WrappedJSObjectChangeListener<T> {

 "onChanged"(arg0: T): void

(arg0: T): void
}

export namespace $WrappedJSObjectChangeListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedJSObjectChangeListener$Type<T> = ($WrappedJSObjectChangeListener<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedJSObjectChangeListener_<T> = $WrappedJSObjectChangeListener$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/create/$SequencedAssemblyItemBuilder" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$ArmorMaterial, $ArmorMaterial$Type} from "packages/net/minecraft/world/item/$ArmorMaterial"
import {$ItemBuilder, $ItemBuilder$Type} from "packages/dev/latvian/mods/kubejs/item/$ItemBuilder"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Tier, $Tier$Type} from "packages/net/minecraft/world/item/$Tier"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SequencedAssemblyItemBuilder extends $ItemBuilder {
static readonly "TOOL_TIERS": $Map<(string), ($Tier)>
static readonly "ARMOR_TIERS": $Map<(string), ($ArmorMaterial)>
 "texture": string
 "parentModel": string
 "textureJson": $JsonObject
 "modelJson": $JsonObject
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(i: $ResourceLocation$Type)

public "createObject"(): $Item
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SequencedAssemblyItemBuilder$Type = ($SequencedAssemblyItemBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SequencedAssemblyItemBuilder_ = $SequencedAssemblyItemBuilder$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$ClientEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $ClientEvents {

}

export namespace $ClientEvents {
const GROUP: $EventGroup
const HIGH_ASSETS: $EventHandler
const INIT: $EventHandler
const LOGGED_IN: $EventHandler
const LOGGED_OUT: $EventHandler
const TICK: $EventHandler
const PAINTER_UPDATED: $EventHandler
const DEBUG_LEFT: $EventHandler
const DEBUG_RIGHT: $EventHandler
const PAINT_SCREEN: $EventHandler
const ATLAS_SPRITE_REGISTRY: $EventHandler
const LANG: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientEvents$Type = ($ClientEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientEvents_ = $ClientEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/core/$InventoryKJS" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export interface $InventoryKJS {

 "getBlock"(level: $Level$Type): $BlockContainerJS
 "getSlots"(): integer
 "getStackInSlot"(slot: integer): $ItemStack
 "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
 "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
 "isMutable"(): boolean
 "setChanged"(): void
 "asContainer"(): $Container
 "countNonEmpty"(ingredient: $Ingredient$Type): integer
 "countNonEmpty"(): integer
 "getAllItems"(): $List<($ItemStack)>
 "getHeight"(): integer
 "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
 "find"(ingredient: $Ingredient$Type): integer
 "find"(): integer
 "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
 "getWidth"(): integer
 "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
 "getSlotLimit"(slot: integer): integer
 "clear"(): void
 "clear"(ingredient: $Ingredient$Type): void
 "count"(ingredient: $Ingredient$Type): integer
 "count"(): integer
 "isEmpty"(): boolean
}

export namespace $InventoryKJS {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InventoryKJS$Type = ($InventoryKJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InventoryKJS_ = $InventoryKJS$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$InterpretedFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$NativeFunction, $NativeFunction$Type} from "packages/dev/latvian/mods/rhino/$NativeFunction"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Script, $Script$Type} from "packages/dev/latvian/mods/rhino/$Script"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $InterpretedFunction extends $NativeFunction implements $Script {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer


public "exec"(cx: $Context$Type, scope: $Scriptable$Type): any
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "isScript"(): boolean
public "resumeGenerator"(cx: $Context$Type, scope: $Scriptable$Type, operation: integer, state: any, value: any): any
public "getFunctionName"(): string
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "script"(): boolean
get "functionName"(): string
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InterpretedFunction$Type = ($InterpretedFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InterpretedFunction_ = $InterpretedFunction$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FloorFuncUnit" {
import {$Func1Unit, $Func1Unit$Type} from "packages/dev/latvian/mods/unit/function/$Func1Unit"
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$FunctionFactory, $FunctionFactory$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $FloorFuncUnit extends $Func1Unit {
static readonly "FACTORY": $FunctionFactory
readonly "a": $Unit
readonly "factory": $FunctionFactory
static "EMPTY_ARRAY": ($Unit)[]

constructor(a: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloorFuncUnit$Type = ($FloorFuncUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloorFuncUnit_ = $FloorFuncUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ObjArray" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ObjArray {

constructor()

public "add"(value: any): void
public "add"(index: integer, value: any): void
public "remove"(index: integer): void
public "get"(index: integer): any
public "indexOf"(obj: any): integer
public "clear"(): void
public "lastIndexOf"(obj: any): integer
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(array: (any)[]): void
public "toArray"(): (any)[]
public "toArray"(array: (any)[], offset: integer): void
public "isSealed"(): boolean
public "set"(index: integer, value: any): void
public "peek"(): any
public "push"(value: any): void
public "pop"(): any
public "setSize"(newSize: integer): void
public "seal"(): void
get "empty"(): boolean
get "sealed"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjArray$Type = ($ObjArray);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjArray_ = $ObjArray$Type;
}}
declare module "packages/dev/latvian/mods/rhino/regexp/$RegExp" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $RegExp {
static readonly "RA_MATCH": integer
static readonly "RA_REPLACE": integer
static readonly "RA_SEARCH": integer

constructor()

public "find_split"(cx: $Context$Type, scope: $Scriptable$Type, target: string, separator: string, reObj: $Scriptable$Type, ip: (integer)[], matchlen: (integer)[], matched: (boolean)[], parensp: ((string)[])[]): integer
public "action"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[], actionType: integer): any
public "compileRegExp"(cx: $Context$Type, source: string, flags: string): any
public "wrapRegExp"(cx: $Context$Type, scope: $Scriptable$Type, compiled: any): $Scriptable
public "isRegExp"(obj: $Scriptable$Type): boolean
public "js_split"(cx: $Context$Type, scope: $Scriptable$Type, target: string, args: (any)[]): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RegExp$Type = ($RegExp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RegExp_ = $RegExp$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/bindings/event/$EntityEvents" {
import {$Extra, $Extra$Type} from "packages/dev/latvian/mods/kubejs/event/$Extra"
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $EntityEvents {

}

export namespace $EntityEvents {
const GROUP: $EventGroup
const SUPPORTS_ENTITY_TYPE: $Extra
const DEATH: $EventHandler
const HURT: $EventHandler
const CHECK_SPAWN: $EventHandler
const SPAWNED: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityEvents$Type = ($EntityEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityEvents_ = $EntityEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/event/$Extra" {
import {$Extra$Transformer, $Extra$Transformer$Type} from "packages/dev/latvian/mods/kubejs/event/$Extra$Transformer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TypeDescJS, $TypeDescJS$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$TypeDescJS"
import {$DescriptionContext, $DescriptionContext$Type} from "packages/dev/latvian/mods/kubejs/typings/desc/$DescriptionContext"

export class $Extra {
static readonly "STRING": $Extra
static readonly "REQUIRES_STRING": $Extra
static readonly "ID": $Extra
static readonly "REQUIRES_ID": $Extra
static readonly "REGISTRY": $Extra
static readonly "REQUIRES_REGISTRY": $Extra
 "transformer": $Extra$Transformer
 "identity": boolean
 "required": boolean
 "validator": $Predicate<(any)>
 "toString": $Extra$Transformer
 "describeType": $Function<($DescriptionContext), ($TypeDescJS)>

constructor()

public "toString"(factory: $Extra$Transformer$Type): $Extra
public "identity"(): $Extra
public "copy"(): $Extra
public "transformer"(factory: $Extra$Transformer$Type): $Extra
public "validator"(validator: $Predicate$Type<(any)>): $Extra
public "required"(): $Extra
public "describeType"(describeType: $Function$Type<($DescriptionContext$Type), ($TypeDescJS$Type)>): $Extra
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Extra$Type = ($Extra);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Extra_ = $Extra$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenGroup" {
import {$Painter, $Painter$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$Painter"
import {$ScreenDrawMode, $ScreenDrawMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$ScreenDrawMode"
import {$PainterObjectStorage, $PainterObjectStorage$Type} from "packages/dev/latvian/mods/kubejs/client/painter/$PainterObjectStorage"
import {$AlignMode, $AlignMode$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$AlignMode"
import {$BoxObject, $BoxObject$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$BoxObject"
import {$PaintScreenEventJS, $PaintScreenEventJS$Type} from "packages/dev/latvian/mods/kubejs/client/painter/screen/$PaintScreenEventJS"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export class $ScreenGroup extends $BoxObject {
readonly "storage": $PainterObjectStorage
 "scaleX": $Unit
 "scaleY": $Unit
 "paddingW": $Unit
 "paddingH": $Unit
 "w": $Unit
 "h": $Unit
 "alignX": $AlignMode
 "alignY": $AlignMode
 "x": $Unit
 "y": $Unit
 "z": $Unit
 "draw": $ScreenDrawMode
 "id": string
 "parent": $PainterObjectStorage
 "visible": $Unit

constructor(painter: $Painter$Type)

public "draw"(event: $PaintScreenEventJS$Type): void
public "preDraw"(event: $PaintScreenEventJS$Type): void
public static "checkSpecialEquality"(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScreenGroup$Type = ($ScreenGroup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScreenGroup_ = $ScreenGroup$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$NativeCollectionIterator" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$NativeCollectionIterator$Type, $NativeCollectionIterator$Type$Type} from "packages/dev/latvian/mods/rhino/$NativeCollectionIterator$Type"
import {$ES6Iterator, $ES6Iterator$Type} from "packages/dev/latvian/mods/rhino/$ES6Iterator"
import {$Hashtable$Entry, $Hashtable$Entry$Type} from "packages/dev/latvian/mods/rhino/$Hashtable$Entry"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $NativeCollectionIterator extends $ES6Iterator {
static readonly "NEXT_METHOD": string
static readonly "DONE_PROPERTY": string
static readonly "RETURN_PROPERTY": string
static readonly "VALUE_PROPERTY": string
static readonly "RETURN_METHOD": string
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor(scope: $Scriptable$Type, className: string, type: $NativeCollectionIterator$Type$Type, iterator: $Iterator$Type<($Hashtable$Entry$Type)>, cx: $Context$Type)
constructor(tag: string)

public "getClassName"(): string
get "className"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NativeCollectionIterator$Type = ($NativeCollectionIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NativeCollectionIterator_ = $NativeCollectionIterator$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$BaseFunction" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Function, $Function$Type} from "packages/dev/latvian/mods/rhino/$Function"
import {$IdFunctionObject, $IdFunctionObject$Type} from "packages/dev/latvian/mods/rhino/$IdFunctionObject"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$IdScriptableObject, $IdScriptableObject$Type} from "packages/dev/latvian/mods/rhino/$IdScriptableObject"
import {$Scriptable, $Scriptable$Type} from "packages/dev/latvian/mods/rhino/$Scriptable"

export class $BaseFunction extends $IdScriptableObject implements $Function {
static readonly "EMPTY": integer
static readonly "READONLY": integer
static readonly "DONTENUM": integer
static readonly "PERMANENT": integer
static readonly "UNINITIALIZED_CONST": integer
static readonly "CONST": integer

constructor()
constructor(isGenerator: boolean)
constructor(scope: $Scriptable$Type, prototype: $Scriptable$Type)

public "toString"(): string
public "getLength"(): integer
public "getClassName"(): string
public "createObject"(cx: $Context$Type, scope: $Scriptable$Type): $Scriptable
public "call"(cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "construct"(cx: $Context$Type, scope: $Scriptable$Type, args: (any)[]): $Scriptable
public "execIdCall"(f: $IdFunctionObject$Type, cx: $Context$Type, scope: $Scriptable$Type, thisObj: $Scriptable$Type, args: (any)[]): any
public "getTypeOf"(): $MemberType
public "getFunctionName"(): string
public "hasInstance"(cx: $Context$Type, instance: $Scriptable$Type): boolean
public "setImmunePrototypeProperty"(value: any): void
public "getArity"(): integer
public "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
public "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
public "delete"(arg0: $Context$Type, arg1: integer): void
public "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
public "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
public "setParentScope"(arg0: $Scriptable$Type): void
public "getParentScope"(): $Scriptable
public "getAllIds"(cx: $Context$Type): (any)[]
public "getIds"(arg0: $Context$Type): (any)[]
public "getPrototype"(arg0: $Context$Type): $Scriptable
public "setPrototype"(arg0: $Scriptable$Type): void
get "length"(): integer
get "className"(): string
get "typeOf"(): $MemberType
get "functionName"(): string
set "immunePrototypeProperty"(value: any)
get "arity"(): integer
set "parentScope"(value: $Scriptable$Type)
get "parentScope"(): $Scriptable
set "prototype"(value: $Scriptable$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BaseFunction$Type = ($BaseFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BaseFunction_ = $BaseFunction$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$ScriptRuntime$MessageProvider" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ScriptRuntime$MessageProvider {

 "getMessage"(arg0: string, arg1: (any)[]): string

(arg0: string, arg1: (any)[]): string
}

export namespace $ScriptRuntime$MessageProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScriptRuntime$MessageProvider$Type = ($ScriptRuntime$MessageProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScriptRuntime$MessageProvider_ = $ScriptRuntime$MessageProvider$Type;
}}
declare module "packages/dev/latvian/mods/unit/operator/$BoolNotOpUnit" {
import {$UnitVariables, $UnitVariables$Type} from "packages/dev/latvian/mods/unit/$UnitVariables"
import {$UnitSymbol, $UnitSymbol$Type} from "packages/dev/latvian/mods/unit/token/$UnitSymbol"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"
import {$UnaryOpUnit, $UnaryOpUnit$Type} from "packages/dev/latvian/mods/unit/operator/$UnaryOpUnit"

export class $BoolNotOpUnit extends $UnaryOpUnit {
readonly "symbol": $UnitSymbol
 "unit": $Unit
static "EMPTY_ARRAY": ($Unit)[]

constructor(unit: $Unit$Type)

public "get"(variables: $UnitVariables$Type): double
public "getBoolean"(variables: $UnitVariables$Type): boolean
public "getInt"(variables: $UnitVariables$Type): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoolNotOpUnit$Type = ($BoolNotOpUnit);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoolNotOpUnit_ = $BoolNotOpUnit$Type;
}}
declare module "packages/dev/latvian/mods/rhino/mod/util/color/$Color" {
import {$SpecialEquality, $SpecialEquality$Type} from "packages/dev/latvian/mods/rhino/util/$SpecialEquality"
import {$TextColor, $TextColor$Type} from "packages/net/minecraft/network/chat/$TextColor"

export interface $Color extends $SpecialEquality {

 "createTextColorJS"(): $TextColor
 "getArgbJS"(): integer
 "getRgbJS"(): integer
 "getSerializeJS"(): string
 "getHexJS"(): string
 "getFireworkColorJS"(): integer
 "specialEquals"(o: any, shallow: boolean): boolean

(): $TextColor
}

export namespace $Color {
function checkSpecialEquality(o: any, o1: any, shallow: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Color$Type = (("") | ("light_blue_dye") | ("BLUE_DYE") | ("purple_dye") | ("dark_red") | ("lightGrayDye") | ("DARK_AQUA") | ("none") | ("green_dye") | ("blackDye") | ("dark_blue") | ("red") | ("pink_dye") | ("aqua") | ("white") | ("WHITE_DYE") | ("dark_gray") | ("LIGHT_PURPLE") | ("BROWN_DYE") | ("BLACK") | ("darkPurple") | ("NONE") | ("LIGHT_BLUE_DYE") | ("AQUA") | ("lightBlueDye") | ("limeDye") | ("PURPLE_DYE") | ("GREEN_DYE") | ("magenta_dye") | ("-") | ("lime_dye") | ("yellowDye") | ("grayDye") | ("purpleDye") | ("DARK_PURPLE") | ("ORANGE_DYE") | ("darkGray") | ("brownDye") | ("YELLOW") | ("LIME_DYE") | ("blueDye") | ("white_dye") | ("pinkDye") | ("blue_dye") | ("cyanDye") | ("GOLD") | ("GRAY") | ("MAGENTA_DYE") | ("BLUE") | ("yellow") | ("darkBlue") | ("transparent") | ("orange_dye") | ("red_dye") | ("dark_purple") | ("gold") | ("gray") | ("light_purple") | ("darkRed") | ("greenDye") | ("DARK_RED") | ("redDye") | ("GRAY_DYE") | ("orangeDye") | ("yellow_dye") | ("black_dye") | ("magentaDye") | ("WHITE") | ("green") | ("LIGHT_GRAY_DYE") | ("BLACK_DYE") | ("darkGreen") | ("RED_DYE") | ("dark_green") | ("black") | ("lightPurple") | ("PINK_DYE") | ("DARK_BLUE") | ("GREEN") | ("darkAqua") | ("gray_dye") | ("CYAN_DYE") | ("RED") | ("brown_dye") | ("cyan_dye") | ("blue") | ("whiteDye") | ("dark_aqua") | ("YELLOW_DYE") | ("DARK_GREEN") | ("DARK_GRAY")) | (`#${string}`) | (integer) | ($Color);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Color_ = $Color$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateMirrorCallbackJS" {
import {$Direction, $Direction$Type} from "packages/net/minecraft/core/$Direction"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$Rotation, $Rotation$Type} from "packages/net/minecraft/world/level/block/$Rotation"
import {$Mirror, $Mirror$Type} from "packages/net/minecraft/world/level/block/$Mirror"
import {$BlockStateModifyCallbackJS, $BlockStateModifyCallbackJS$Type} from "packages/dev/latvian/mods/kubejs/block/callbacks/$BlockStateModifyCallbackJS"

export class $BlockStateMirrorCallbackJS extends $BlockStateModifyCallbackJS {

constructor(state: $BlockState$Type, mirror: $Mirror$Type)

/**
 * Gets the rotation of the direction passed in relative to this mirror
 */
public "getRotation"(dir: $Direction$Type): $Rotation
/**
 * Mirrors the direction passed in
 */
public "mirror"(dir: $Direction$Type): $Direction
/**
 * Gets the Mirror
 */
public "getMirror"(): $Mirror
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStateMirrorCallbackJS$Type = ($BlockStateMirrorCallbackJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStateMirrorCallbackJS_ = $BlockStateMirrorCallbackJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/create/events/$CreateEvents" {
import {$EventHandler, $EventHandler$Type} from "packages/dev/latvian/mods/kubejs/event/$EventHandler"
import {$EventGroup, $EventGroup$Type} from "packages/dev/latvian/mods/kubejs/event/$EventGroup"

export interface $CreateEvents {

}

export namespace $CreateEvents {
const GROUP: $EventGroup
const SPECIAL_FLUID: $EventHandler
const SPECIAL_SPOUT: $EventHandler
const BOILER_HEATER: $EventHandler
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreateEvents$Type = ($CreateEvents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreateEvents_ = $CreateEvents$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$CreativeTabIngredient" {
import {$KubeJSIngredientSerializer, $KubeJSIngredientSerializer$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredientSerializer"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$Ingredient$Value, $Ingredient$Value$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient$Value"
import {$CreativeModeTab, $CreativeModeTab$Type} from "packages/net/minecraft/world/item/$CreativeModeTab"
import {$FriendlyByteBuf, $FriendlyByteBuf$Type} from "packages/net/minecraft/network/$FriendlyByteBuf"
import {$IIngredientSerializer, $IIngredientSerializer$Type} from "packages/net/minecraftforge/common/crafting/$IIngredientSerializer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntList, $IntList$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntList"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$KubeJSIngredient, $KubeJSIngredient$Type} from "packages/dev/latvian/mods/kubejs/platform/forge/ingredient/$KubeJSIngredient"

export class $CreativeTabIngredient extends $KubeJSIngredient {
static readonly "SERIALIZER": $KubeJSIngredientSerializer<($CreativeTabIngredient)>
readonly "tab": $CreativeModeTab
static readonly "EMPTY": $Ingredient
 "values": ($Ingredient$Value)[]
 "itemStacks": ($ItemStack)[]
 "stackingIds": $IntList

constructor(json: $JsonObject$Type)
constructor(buf: $FriendlyByteBuf$Type)
constructor(tab: $CreativeModeTab$Type)

public "test"(stack: $ItemStack$Type): boolean
public "write"(buf: $FriendlyByteBuf$Type): void
public "toJson"(json: $JsonObject$Type): void
public "getSerializer"(): $IIngredientSerializer<(any)>
public "self"(): $Ingredient
public static "not"<T>(arg0: $Predicate$Type<(any)>): $Predicate<(T)>
public static "isEqual"<T>(arg0: any): $Predicate<(T)>
get "serializer"(): $IIngredientSerializer<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CreativeTabIngredient$Type = ($CreativeTabIngredient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CreativeTabIngredient_ = $CreativeTabIngredient$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/gui/chest/$ChestMenuInventoryClickEvent" {
import {$ClickType, $ClickType$Type} from "packages/net/minecraft/world/inventory/$ClickType"
import {$Slot, $Slot$Type} from "packages/net/minecraft/world/inventory/$Slot"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"

export class $ChestMenuInventoryClickEvent {
readonly "type": $ClickType
readonly "button": integer

constructor(slot: $Slot$Type, type: $ClickType$Type, button: integer)

public "getIndex"(): integer
public "getItem"(): $ItemStack
public "setItem"(item: $ItemStack$Type): void
get "index"(): integer
get "item"(): $ItemStack
set "item"(value: $ItemStack$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChestMenuInventoryClickEvent$Type = ($ChestMenuInventoryClickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChestMenuInventoryClickEvent_ = $ChestMenuInventoryClickEvent$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/util/$AttachedData" {
import {$HashMap, $HashMap$Type} from "packages/java/util/$HashMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AttachedData<T> extends $HashMap<(string), (any)> {

constructor(p: T)

public "add"(key: string, data: any): void
public "getParent"(): T
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
get "parent"(): T
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AttachedData$Type<T> = ($AttachedData<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AttachedData_<T> = $AttachedData$Type<(T)>;
}}
declare module "packages/dev/latvian/mods/kubejs/server/tag/$TagEventFilter" {
import {$TagWrapper, $TagWrapper$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagWrapper"
import {$TagEventJS, $TagEventJS$Type} from "packages/dev/latvian/mods/kubejs/server/tag/$TagEventJS"
import {$ExtraCodecs$TagOrElementLocation, $ExtraCodecs$TagOrElementLocation$Type} from "packages/net/minecraft/util/$ExtraCodecs$TagOrElementLocation"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export interface $TagEventFilter {

 "testTagOrElementLocation"(element: $ExtraCodecs$TagOrElementLocation$Type): boolean
 "testElementId"(arg0: $ResourceLocation$Type): boolean
 "add"(wrapper: $TagWrapper$Type): integer
 "remove"(wrapper: $TagWrapper$Type): integer
 "unwrap"(): $Stream<($TagEventFilter)>

(element: $ExtraCodecs$TagOrElementLocation$Type): boolean
}

export namespace $TagEventFilter {
function of(event: $TagEventJS$Type, o: any): $TagEventFilter
function unwrap(event: $TagEventJS$Type, array: (any)[]): $TagEventFilter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TagEventFilter$Type = ($TagEventFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TagEventFilter_ = $TagEventFilter$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$ItemModificationEventJS" {
import {$Item, $Item$Type} from "packages/net/minecraft/world/item/$Item"
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"

/**
 * Invoked after all items are registered to modify them.
 */
export class $ItemModificationEventJS extends $EventJS {

constructor()

/**
 * Modifies items matching the given ingredient.
 * 
 * **NOTE**: tag ingredients are not supported at this time.
 */
public "modify"(arg0: $Ingredient$Type, c: $Consumer$Type<($Item$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ItemModificationEventJS$Type = ($ItemModificationEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ItemModificationEventJS_ = $ItemModificationEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/fluid/$FlowingFluidBuilder" {
import {$Component, $Component$Type} from "packages/net/minecraft/network/chat/$Component"
import {$FlowingFluid, $FlowingFluid$Type} from "packages/net/minecraft/world/level/material/$FlowingFluid"
import {$FluidBuilder, $FluidBuilder$Type} from "packages/dev/latvian/mods/kubejs/fluid/$FluidBuilder"
import {$RegistryInfo, $RegistryInfo$Type} from "packages/dev/latvian/mods/kubejs/registry/$RegistryInfo"
import {$BuilderBase, $BuilderBase$Type} from "packages/dev/latvian/mods/kubejs/registry/$BuilderBase"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"

export class $FlowingFluidBuilder extends $BuilderBase<($FlowingFluid)> {
readonly "fluidBuilder": $FluidBuilder
readonly "id": $ResourceLocation
 "translationKey": string
 "displayName": $Component
 "formattedDisplayName": boolean

constructor(b: $FluidBuilder$Type)

public "getRegistryType"(): $RegistryInfo<(any)>
get "registryType"(): $RegistryInfo<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlowingFluidBuilder$Type = ($FlowingFluidBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlowingFluidBuilder_ = $FlowingFluidBuilder$Type;
}}
declare module "packages/dev/latvian/mods/rhino/$Scriptable" {
import {$Context, $Context$Type} from "packages/dev/latvian/mods/rhino/$Context"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IdEnumerationIterator, $IdEnumerationIterator$Type} from "packages/dev/latvian/mods/rhino/$IdEnumerationIterator"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MemberType, $MemberType$Type} from "packages/dev/latvian/mods/rhino/$MemberType"

export interface $Scriptable extends $IdEnumerationIterator {

 "get"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): any
 "get"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type): any
 "put"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type, arg3: any): void
 "put"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type, arg3: any): void
 "delete"(arg0: $Context$Type, arg1: string): void
 "delete"(arg0: $Context$Type, arg1: integer): void
 "getDefaultValue"(arg0: $Context$Type, arg1: $Class$Type<(any)>): any
 "getClassName"(): string
 "has"(arg0: $Context$Type, arg1: string, arg2: $Scriptable$Type): boolean
 "has"(arg0: $Context$Type, arg1: integer, arg2: $Scriptable$Type): boolean
 "setParentScope"(arg0: $Scriptable$Type): void
 "getParentScope"(): $Scriptable
 "getAllIds"(cx: $Context$Type): (any)[]
 "getTypeOf"(): $MemberType
 "enumerationIteratorHasNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
 "enumerationIteratorNext"(cx: $Context$Type, currentId: $Consumer$Type<(any)>): boolean
 "getIds"(arg0: $Context$Type): (any)[]
 "hasInstance"(arg0: $Context$Type, arg1: $Scriptable$Type): boolean
 "getPrototype"(arg0: $Context$Type): $Scriptable
 "setPrototype"(arg0: $Scriptable$Type): void
}

export namespace $Scriptable {
const NOT_FOUND: any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Scriptable$Type = ($Scriptable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Scriptable_ = $Scriptable$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/stages/$StageEventJS" {
import {$StageChangeEvent, $StageChangeEvent$Type} from "packages/dev/latvian/mods/kubejs/stages/$StageChangeEvent"
import {$PlayerEventJS, $PlayerEventJS$Type} from "packages/dev/latvian/mods/kubejs/player/$PlayerEventJS"
import {$Stages, $Stages$Type} from "packages/dev/latvian/mods/kubejs/stages/$Stages"

export class $StageEventJS extends $PlayerEventJS {

constructor(e: $StageChangeEvent$Type)

public "getPlayerStages"(): $Stages
public "getStage"(): string
get "playerStages"(): $Stages
get "stage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StageEventJS$Type = ($StageEventJS);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StageEventJS_ = $StageEventJS$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/block/state/$BlockStatePredicate" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuleTest, $RuleTest$Type} from "packages/net/minecraft/world/level/levelgen/structure/templatesystem/$RuleTest"
import {$BlockState, $BlockState$Type} from "packages/net/minecraft/world/level/block/state/$BlockState"
import {$OreConfiguration$TargetBlockState, $OreConfiguration$TargetBlockState$Type} from "packages/net/minecraft/world/level/levelgen/feature/configurations/$OreConfiguration$TargetBlockState"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$Block, $Block$Type} from "packages/net/minecraft/world/level/block/$Block"
import {$ReplacementMatch, $ReplacementMatch$Type} from "packages/dev/latvian/mods/kubejs/recipe/$ReplacementMatch"

export interface $BlockStatePredicate extends $Predicate<($BlockState)>, $ReplacementMatch {

 "test"(arg0: $BlockState$Type): boolean
 "check"(targetStates: $List$Type<($OreConfiguration$TargetBlockState$Type)>): boolean
 "getBlockIds"(): $Set<($ResourceLocation)>
 "asRuleTest"(): $RuleTest
 "testBlock"(block: $Block$Type): boolean
 "getBlocks"(): $Collection<($Block)>
 "getBlockStates"(): $Collection<($BlockState)>
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
 "negate"(): $Predicate<($BlockState)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>

(arg0: $BlockState$Type): boolean
}

export namespace $BlockStatePredicate {
const AIR_ID: $ResourceLocation
function of(o: any): $BlockStatePredicate
function fromString(s: string): $BlockStatePredicate
function ruleTestOf(o: any): $RuleTest
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<($BlockState)>
function isEqual<T>(arg0: any): $Predicate<($BlockState)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockStatePredicate$Type = (($BlockStatePredicate$Type)[]) | ({"or"?: $BlockStatePredicate$Type, "not"?: $BlockStatePredicate$Type}) | ($Block$Type) | (Special.BlockTag) | (RegExp) | ("*") | ("-") | ($BlockStatePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockStatePredicate_ = $BlockStatePredicate$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg3" {
import {$FunctionFactory$FuncSupplier, $FunctionFactory$FuncSupplier$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$FuncSupplier"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $FunctionFactory$Arg3 extends $FunctionFactory$FuncSupplier {

 "create"(args: ($Unit$Type)[]): $Unit
 "createArg"(arg0: $Unit$Type, arg1: $Unit$Type, arg2: $Unit$Type): $Unit

(args: ($Unit$Type)[]): $Unit
}

export namespace $FunctionFactory$Arg3 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionFactory$Arg3$Type = ($FunctionFactory$Arg3);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionFactory$Arg3_ = $FunctionFactory$Arg3$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg2" {
import {$FunctionFactory$FuncSupplier, $FunctionFactory$FuncSupplier$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$FuncSupplier"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $FunctionFactory$Arg2 extends $FunctionFactory$FuncSupplier {

 "create"(args: ($Unit$Type)[]): $Unit
 "createArg"(arg0: $Unit$Type, arg1: $Unit$Type): $Unit

(args: ($Unit$Type)[]): $Unit
}

export namespace $FunctionFactory$Arg2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionFactory$Arg2$Type = ($FunctionFactory$Arg2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionFactory$Arg2_ = $FunctionFactory$Arg2$Type;
}}
declare module "packages/dev/latvian/mods/unit/function/$FunctionFactory$Arg1" {
import {$FunctionFactory$FuncSupplier, $FunctionFactory$FuncSupplier$Type} from "packages/dev/latvian/mods/unit/function/$FunctionFactory$FuncSupplier"
import {$Unit, $Unit$Type} from "packages/dev/latvian/mods/unit/$Unit"

export interface $FunctionFactory$Arg1 extends $FunctionFactory$FuncSupplier {

 "create"(args: ($Unit$Type)[]): $Unit
 "createArg"(arg0: $Unit$Type): $Unit

(args: ($Unit$Type)[]): $Unit
}

export namespace $FunctionFactory$Arg1 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FunctionFactory$Arg1$Type = ($FunctionFactory$Arg1);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FunctionFactory$Arg1_ = $FunctionFactory$Arg1$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/item/$RangedWrapper" {
import {$InventoryKJS, $InventoryKJS$Type} from "packages/dev/latvian/mods/kubejs/core/$InventoryKJS"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Ingredient, $Ingredient$Type} from "packages/net/minecraft/world/item/crafting/$Ingredient"
import {$Level, $Level$Type} from "packages/net/minecraft/world/level/$Level"
import {$ItemStack, $ItemStack$Type} from "packages/net/minecraft/world/item/$ItemStack"
import {$BlockContainerJS, $BlockContainerJS$Type} from "packages/dev/latvian/mods/kubejs/level/$BlockContainerJS"
import {$Container, $Container$Type} from "packages/net/minecraft/world/$Container"

export class $RangedWrapper implements $InventoryKJS {

constructor(compose: $InventoryKJS$Type, minSlot: integer, maxSlotExclusive: integer)

public "getSlots"(): integer
public "getStackInSlot"(slot: integer): $ItemStack
public "insertItem"(slot: integer, stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "isMutable"(): boolean
public "extractItem"(slot: integer, amount: integer, simulate: boolean): $ItemStack
public "isItemValid"(slot: integer, stack: $ItemStack$Type): boolean
public "setStackInSlot"(slot: integer, stack: $ItemStack$Type): void
public "getSlotLimit"(slot: integer): integer
public "getBlock"(level: $Level$Type): $BlockContainerJS
public "insertItem"(stack: $ItemStack$Type, simulate: boolean): $ItemStack
public "setChanged"(): void
public "asContainer"(): $Container
public "countNonEmpty"(ingredient: $Ingredient$Type): integer
public "countNonEmpty"(): integer
public "getAllItems"(): $List<($ItemStack)>
public "getHeight"(): integer
public "find"(ingredient: $Ingredient$Type): integer
public "find"(): integer
public "getWidth"(): integer
public "clear"(): void
public "clear"(ingredient: $Ingredient$Type): void
public "count"(ingredient: $Ingredient$Type): integer
public "count"(): integer
public "isEmpty"(): boolean
get "slots"(): integer
get "mutable"(): boolean
get "allItems"(): $List<($ItemStack)>
get "height"(): integer
get "width"(): integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RangedWrapper$Type = ($RangedWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RangedWrapper_ = $RangedWrapper$Type;
}}
declare module "packages/dev/latvian/mods/kubejs/integration/forge/jei/$RemoveJEIRecipesEvent" {
import {$EventJS, $EventJS$Type} from "packages/dev/latvian/mods/kubejs/event/$EventJS"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IRecipeCategory, $IRecipeCategory$Type} from "packages/mezz/jei/api/recipe/category/$IRecipeCategory"
import {$ResourceLocation, $ResourceLocation$Type} from "packages/net/minecraft/resources/$ResourceLocation"
import {$IJeiRuntime, $IJeiRuntime$Type} from "packages/mezz/jei/api/runtime/$IJeiRuntime"

export class $RemoveJEIRecipesEvent extends $EventJS {

constructor(r: $IJeiRuntime$Type)

public "remove"(category: $ResourceLocation$Type, recipesToRemove: ($ResourceLocation$Type)[]): void
public "getCategoryIds"(): $Collection<($ResourceLocation)>
public "getCategories"(): $Collection<($IRecipeCategory)>
get "categoryIds"(): $Collection<($ResourceLocation)>
get "categories"(): $Collection<($IRecipeCategory)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RemoveJEIRecipesEvent$Type = ($RemoveJEIRecipesEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RemoveJEIRecipesEvent_ = $RemoveJEIRecipesEvent$Type;
}}
